
// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
          printf("%s:%i: ", __FILE__, __LINE__); \
      printf(__VA_ARGS__); \
      fflush(stdout); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#include <getopt.h>

#if (CFG_COMPILER == CFG_COMPILER_MSVC)
  #define FFTW_DLL
#endif

#include <fftw3.h>
#include <sys/stat.h>
#include <sys/types.h>

#define _xmds_malloc fftw_malloc
#define xmds_free fftw_free

#if   defined(CBLAS_MKL)
  #include <mkl.h>
#elif defined(CBLAS_VECLIB)
  #include <Accelerate/Accelerate.h>
#elif defined(CBLAS_ATLAS)
  extern "C" {
    #include <cblas.h>
  }
#elif defined(CBLAS_GSL)
  #include <gsl/gsl_cblas.h>
#endif

#define DSFMT_DO_NOT_USE_OLD_NAMES
#if CFG_HAVE_SSE2
  #define HAVE_SSE2
#elif CFG_HAVE_ALTIVEC
  #define HAVE_ALTIVEC
#endif

#define DSFMT_MEXP 19937

#include <dSFMT/dSFMT.h>
#include <dSFMT/dSFMT.c>

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Auto-vectorisation defines

#define _MAKE_AUTOVEC_VARIABLE(x) real* const __restrict__ x ## _autovec = (real*) x
#define _AUTOVEC(x) (x ## _autovec)

// ********************************************************
//   Geometry defines
#define _lattice_x ((int)1502)
#define _min_x     (_x[0])
#define _max_x     (_x[_lattice_x-1])

#define _lattice_nx ((int)1502)
#define _min_nx     ((long)0)
#define _max_nx     ((long)1502)
#define _dnx        ((long)1)

#define _lattice_kx ((int)1502)
#define _min_kx     (_kx[0])
#define _max_kx     (_kx[_lattice_kx-1])

#define _lattice_nx_twiddle ((int)1502)
#define _min_nx_twiddle     ((long)0)
#define _max_nx_twiddle     ((long)1502)
#define _dnx_twiddle        ((long)1)

#define _lattice_x_4f ((int)1502)
#define _min_x_4f     (_x_4f[0])
#define _max_x_4f     (_x_4f[_lattice_x_4f-1])

// ********************************************************
//   field x defines
#define _x_ndims 1


// vector pos_space_terms defines
#define _x_pos_space_terms_ncomponents 1

// vector wavefunction defines
#define _x_wavefunction_ncomponents 1

// vector driving_noise defines
#define _x_driving_noise_ncomponents 1

// ********************************************************
//   segment 1 (SI fixed-step integrator) defines
// vector segment1_x_operators_operator0_field defines
#define _x_segment1_x_operators_operator0_field_ncomponents 1

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 1


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 2


#define _mg0_output_lattice_t ((int)11)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 2

// ********************************************************
//   field mg1_sampling defines
#define _mg1_sampling_ndims 1


// ********************************************************
//   field mg1_output defines
#define _mg1_output_ndims 2


#define _mg1_output_lattice_t ((int)11)
#define _mg1_output_min_t     (_mg1_output_t[0])
#define _mg1_output_max_t     (_mg1_output_t[_mg1_output_lattice_t-1])
#define _mg1_output_dt        (_mg1_output_t[_index_t+1]-_mg1_output_t[_index_t])

// vector raw defines
#define _mg1_output_raw_ncomponents 2

// ********************************************************
//   field mg2_sampling defines
#define _mg2_sampling_ndims 1


// ********************************************************
//   field mg2_output defines
#define _mg2_output_ndims 2


#define _mg2_output_lattice_t ((int)11)
#define _mg2_output_min_t     (_mg2_output_t[0])
#define _mg2_output_max_t     (_mg2_output_t[_mg2_output_lattice_t-1])
#define _mg2_output_dt        (_mg2_output_t[_index_t+1]-_mg2_output_t[_index_t])

// vector raw defines
#define _mg2_output_raw_ncomponents 2


// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;

_basis_map _x_pos_space_terms_basis_map;
_basis_map _x_wavefunction_basis_map;
_basis_map _x_driving_noise_basis_map;

real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
  /* 0 */ "(kx)",
  /* 1 */ "(nx)",
  /* 2 */ "(x)",
  /* 3 */ "(x_4f)",
};

// ********************************************************
//   'Globals' element globals

#line 16 "th_spgpe_gs.xmds"

real R_tilde;
real rho0_tilde;                                                        
real t_lim;                     
real kth;                       
real sgT;               
real mu;

#line 363 "th_spgpe_gs.cc"

// ********************************************************
//   Command line argument processing globals
real chi = 0.0786; 
real omega_bar = 0.0057; 
real k0 = 7.0; 

// ********************************************************
//   FFTW3 globals
const real _inverse_sqrt_2pi = 1.0 / sqrt(2.0 * M_PI); 
string _fftwWisdomPath;

// ********************************************************
//   Geometry globals
real* _x = NULL;
real* _dx_array = (real*) xmds_malloc(sizeof(real) * (_lattice_x));

long* _nx = NULL;

real* _kx = NULL;
real* _dkx_array = (real*) xmds_malloc(sizeof(real) * (_lattice_kx));

long* _nx_twiddle = NULL;

real* _x_4f = NULL;
real* _dx_4f_array = (real*) xmds_malloc(sizeof(real) * (_lattice_x_4f));

// ********************************************************
//   MMT globals
const real _hermite_zeros_x[] = {
  -54.328926130872055, -53.96241809944158, -53.661986551031596,
  -53.39618607966144, -53.15298067808064, -52.92615831397634,
  -52.71198801563665, -52.50800901629689, -52.31249097464213,
  -52.12415896387552, -51.94203950889288, -51.765368098571166,
  -51.5935304947436, -51.42602381313066, -51.262429766574236,
  -51.102395705936516, -50.94562083733587, -50.79184597903793,
  -50.64084580159866, -50.492422849471424, -50.346402866001846,
  -50.20263108880324, -50.060969278934266, -49.92129331280579,
  -49.783491211118616, -49.64746151114597, -49.51311191159503,
  -49.38035813596413, -49.24912297259201, -49.11933545877167,
  -48.99093018320942, -48.863846686389174, -48.73802894246357,
  -48.61342490944391, -48.4899861369396, -48.36766742264341,
  -48.246426510318464, -48.12622382328404, -48.00702222840013,
  -47.88878682636782, -47.77148476482559, -47.655085071265304,
  -47.53955850324634, -47.42487741375286, -47.31101562985484,
  -47.197948343091475, -47.085652010214, -46.974104263107506,
  -46.86328382687221, -46.75317044516938, -46.6437448120594,
  -46.53498850964739, -46.42688395094156, -46.31941432739748,
  -46.21256356068394, -46.106316258260875, -46.00065767240461,
  -45.89557366235727, -45.79105065931231, -45.687075633979504,
  -45.58363606649914, -45.48071991849915, -45.37831560711164,
  -45.27641198078117, -45.17499829671607, -45.07406419984687,
  -44.97359970317066, -44.87359516936987, -44.774041293605926,
  -44.674929087396606, -44.57624986349425, -44.4779952216892,
  -44.380157035470624, -44.28272743948078, -44.18569881770632,
  -44.0890637923539, -43.99281521336156, -43.896946148502096,
  -43.801449874038084, -43.70631986589031, -43.61154979128667,
  -43.51713350085829, -43.42306502115531, -43.3293385475538,
  -43.235948437529935, -43.14288920427823, -43.05015551065153,
  -42.957742163404696, -42.865644107721366, -42.77385642200913,
  -42.68237431294506, -42.59119311075828, -42.50030826473558,
  -42.40971533893615, -42.31941000810563, -42.22938805377599,
  -42.13964536054276, -42.05017791250818, -41.960981789883036,
  -41.8720531657371, -41.783388302890664, -41.69498355094012,
  -41.60683534341025, -41.51894019502645, -41.43129469910121,
  -41.343895525028486, -41.25673941588099, -41.169823186104885,
  -41.0831437193075, -40.996697966133105, -40.910482942222444,
  -40.82449572625254, -40.73873345805194, -40.65319333678937,
  -40.567872619230535, -40.48276861806123, -40.397878700273374,
  -40.31320028561063, -40.22873084507155, -40.144467899467394,
  -40.060409018031976, -39.976551817081706, -39.89289395872311,
  -39.809433149606086, -39.726167139721, -39.643093721237626,
  -39.56021072738376, -39.477516031362605, -39.395007545306726,
  -39.31268321926739, -39.230541040237604, -39.14857903120731,
  -39.066795250250316, -38.9851877896405, -38.90375477499684,
  -38.822494364456084, -38.741404747871776, -38.660484146038684,
  -38.579730809941644, -38.49914302002783, -38.41871908550205,
  -38.33845734364298, -38.258356159141066, -38.178413923456056,
  -38.09862905419436, -38.018999994504554, -37.93952521249137,
  -37.86020320064674, -37.78103247529752, -37.70201157606961,
  -37.6231390653673, -37.544413527867675, -37.465833570029574,
  -37.38739781961649, -37.309104925232745, -37.23095355587307,
  -37.15294240048423, -37.0750701675391, -36.9973355846226,
  -36.919737398028474, -36.842274372367385, -36.76494529018563,
  -36.68774895159384, -36.610684173905724, -36.53374979128642,
  -36.456944654409995, -36.380267630125935, -36.30371760113451,
  -36.22729346567035, -36.150994137194004, -36.074818544091826,
  -35.99876562938319, -35.92283435043498, -35.84702367868369,
  -35.77133259936403, -35.69576011124455, -35.62030522636969,
  -35.54496696980808, -35.46974437940719, -35.39463650555383,
  -35.31964241094027, -35.24476117033643, -35.169991870366914,
  -35.095333609293945, -35.02078549680492, -34.94634665380506,
  -34.87201621221548, -34.79779331477503, -34.7236771148474,
  -34.64966677623233, -34.575761472981405, -34.50196038921772,
  -34.42826271895986, -34.35466766594988, -34.28117444348483,
  -34.20778227425243, -34.13449039017018, -34.061298032227896,
  -33.98820445033401, -33.9152089031651, -33.84231065801852,
  -33.76950899066842, -33.69680318522489, -33.62419253399585,
  -33.55167633735231, -33.47925390359602, -33.406924548830204,
  -33.33468759683311, -33.26254237893377, -33.19048823389081,
  -33.1185245077735, -33.04665055384524, -32.97486573244971,
  -32.903169410899004, -32.83156096336426, -32.76003977076836,
  -32.68860522068086, -32.617256707215184, -32.54599363092742,
  -32.47481539871768, -32.40372142373303, -32.332711125272304,
  -32.2617839286933, -32.19093926532087, -32.12017657235782,
  -32.04949529279676, -31.978894875333943, -31.908374774284873,
  -31.83793444950126, -31.767573366289746, -31.697290995332054,
  -31.6270868126067, -31.556960299312216, -31.486910941791628,
  -31.41693823145858, -31.3470416647246, -31.277220742927895,
  -31.207474972263256, -31.13780386371346, -31.06820693298174,
  -30.998683700425552, -30.929233690991577, -30.85985643415174,
  -30.79055146384066, -30.721318318393852, -30.652156540487294,
  -30.583065677077965, -30.514045279345407, -30.445094902634416,
  -30.37621410639858, -30.307402454144892, -30.238659513379336,
  -30.169984855553388, -30.101378056011402, -30.032838693938945,
  -29.96436635231198, -29.89596061784695, -29.82762108095162,
  -29.75934733567692, -29.69113897966931, -29.622995614124328,
  -29.554916843740536, -29.486902276674428, -29.418951524496112,
  -29.351064202145594, -29.283239927889813, -29.215478323280472,
  -29.147779013112523, -29.08014162538315, -29.01256579125168,
  -28.94505114499996, -28.877597323993474, -28.81020396864294,
  -28.742870722366725, -28.675597231553578, -28.608383145526332,
  -28.541228116505774, -28.47413179957535, -28.40709385264633,
  -28.340113936423467, -28.27319171437134, -28.20632685268108,
  -28.139519020237596, -28.072767888587467, -28.006073131907062,
  -27.939434426971506, -27.87285145312371, -27.806323892244244,
  -27.739851428721288, -27.67343374942146, -27.607070543660736,
  -27.54076150317591, -27.47450632209655, -27.408304696917284,
  -27.34215632647052, -27.27606091189966, -27.21001815663244,
  -27.144027766355045, -27.078089448986194, -27.01220291465199,
  -26.946367875660826, -26.88058404647881, -26.814851143705486,
  -26.749168886049947, -26.68353699430729, -26.61795519133531,
  -26.552423202031655, -26.486940753311192, -26.421507574083794,
  -26.35612339523236, -26.29078794959121, -26.225500971924685,
  -26.160262198906103, -26.095071369097077, -26.02992822292702,
  -25.964832502672852, -25.89978395243924, -25.83478231813894,
  -25.76982734747332, -25.704918789913357, -25.640056396680777,
  -25.575239920729402, -25.510469116726945, -25.44574374103669,
  -25.3810635516999, -25.316428308417954, -25.251837772535183,
  -25.187291707021604, -25.122789876455972, -25.058332047009127,
  -24.993917986427544, -24.929547464017045, -24.865220250626596,
  -24.800936118632766, -24.73669484192378, -24.672496195884285,
  -24.608339957380053, -24.544225904742863, -24.480153817755774,
  -24.416123477638333, -24.352134667032274, -24.288187169987076,
  -24.224280771945836, -24.160415259731504, -24.096590421532984,
  -24.032806046891622, -23.969061926687708, -23.905357853127303,
  -23.84169361972924, -23.778069021311882, -23.714483853980838,
  -23.650937915115904, -23.58743100335891, -23.523962918601303,
  -23.460533461972037, -23.397142435825547, -23.33378964372992,
  -23.27047489045518, -23.207197981961745, -23.143958725388924,
  -23.080756929043694, -23.017592402389525, -22.954464956035373,
  -22.891374401724743, -22.828320552324957, -22.765303221816538,
  -22.70232222528264, -22.639377378898736, -22.57646849992229,
  -22.513595406682608, -22.45075791857089, -22.387955856030235,
  -22.325189040545883, -22.262457294635563, -22.199760441839835,
  -22.137098306712698, -22.07447071481224, -22.011877492691372,
  -21.949318467888652, -21.88679346891933, -21.82430232526636,
  -21.761844867371565, -21.69942092662691, -21.637030335365903,
  -21.574672926855015, -21.51234853528521, -21.45005699576369,
  -21.387798144305567, -21.32557181782568, -21.26337785413059,
  -21.201216091910542, -21.139086370731597, -21.076988531027805,
  -21.014922414093448, -20.95288786207549, -20.890884717965925,
  -20.828912825594305, -20.766972029620433, -20.705062175526955,
  -20.643183109612163, -20.581334678982806, -20.519516731547064,
  -20.45772911600746, -20.395971681854032, -20.334244279357325,
  -20.27254675956176, -20.210878974278813, -20.149240776080415,
  -20.087632018292346, -20.02605255498779, -19.964502240980803,
  -19.902980931820007, -19.841488483782303, -19.78002475386653,
  -19.718589599787418, -19.65718287996938, -19.595804453540488,
  -19.534454180326506, -19.473131920844946, -19.411837536299196,
  -19.350570888572722, -19.28933184022331, -19.22812025447742,
  -19.166935995224467, -19.105778927011333, -19.044648915036767,
  -18.98354582514601, -18.922469523825296, -18.86141987819655,
  -18.800396756012063, -18.73940002564926, -18.678429556105467,
  -18.61748521699277, -18.556566878532976, -18.495674411552436,
  -18.434807687477207, -18.373966578327988, -18.31315095671521,
  -18.252360695834284, -18.19159566946068, -18.130855751945244,
  -18.07014081820945, -18.009450743740715, -17.94878540458775,
  -17.888144677356117, -17.827528439203473, -17.76693656783528,
  -17.70636894150018, -17.645825438985717, -17.585305939613914,
  -17.52481032323688, -17.46433847023266, -17.403890261500866,
  -17.34346557845848, -17.283064303035772, -17.22268631767206,
  -17.162331505311702, -17.10199974939999, -17.041690933879106,
  -16.981404943184213, -16.921141662239457, -16.86090097645409,
  -16.800682771718552, -16.740486934400636, -16.68031335134175,
  -16.620161909853064, -16.5600324977118, -16.499925003157543,
  -16.439839314888562, -16.379775322058173, -16.319732914271096,
  -16.259711981579983, -16.199712414481716, -16.139734103914044,
  -16.079776941252042, -16.01984081830463, -15.959925627311215,
  -15.900031260938242, -15.840157612275895, -15.780304574834702,
  -15.720472042542266, -15.660659909739985, -15.600868071179812,
  -15.541096422021017, -15.481344857826995, -15.421613274562151,
  -15.361901568588669, -15.302209636663502, -15.242537375935212,
  -15.182884683940959, -15.123251458603418, -15.063637598227833,
  -15.004043001498966, -14.944467567478199, -14.884911195600559,
  -14.825373785671848, -14.765855237865694, -14.706355452720768,
  -14.646874331137866, -14.587411774377152, -14.527967684055358,
  -14.468541962142986, -14.409134510961579, -14.349745233181002,
  -14.2903740318167, -14.231020810227097, -14.171685472110841,
  -14.112367921504232, -14.05306806277857, -13.99378580063757,
  -13.934521040114795, -13.875273686571074, -13.81604364569198,
  -13.756830823485322, -13.697635126278639, -13.63845646071671,
  -13.579294733759115, -13.52014985267778, -13.461021725054593,
  -13.401910258778937, -13.342815362045366, -13.283736943351201,
  -13.224674911494214, -13.165629175570276, -13.106599644971041,
  -13.047586229381674, -12.988588838778565, -12.929607383427042,
  -12.870641773879184, -12.811691920971528, -12.752757735822913,
  -12.693839129832256, -12.634936014676368, -12.576048302307832,
  -12.517175904952833, -12.458318735109, -12.399476705543314,
  -12.340649729290057, -12.281837719648633, -12.223040590181581,
  -12.164258254712456, -12.105490627323837, -12.0467376223553,
  -11.987999154401372, -11.929275138309531, -11.870565489178286,
  -11.811870122355167, -11.753188953434725, -11.694521898256697,
  -11.635868872903956, -11.577229793700704, -11.518604577210501,
  -11.459993140234404, -11.401395399809083, -11.34281127320496,
  -11.284240677924373, -11.225683531699712, -11.167139752491611,
  -11.108609258487139, -11.050091968097973, -10.991587799958657,
  -10.933096672924755, -10.874618506071172, -10.816153218690316,
  -10.757700730290416, -10.699260960593763, -10.640833829534998,
  -10.5824192572594, -10.524017164121195, -10.46562747068186,
  -10.407250097708465, -10.348884966171973, -10.290531997245646,
  -10.232191112303319, -10.173862232917848, -10.115545280859424,
  -10.057240178094006, -9.998946846781678, -9.940665209275085,
  -9.882395188117844, -9.82413670604295, -9.765889685971246,
  -9.707654051009829, -9.649429724450544, -9.591216629768413,
  -9.533014690620133, -9.474823830842558, -9.416643974451162,
  -9.35847504563857, -9.300316968773062, -9.242169668397075,
  -9.18403306922575, -9.125907096145443, -9.067791674212287,
  -9.009686728650752, -8.95159218485218, -8.893507968373351,
  -8.835434004935106, -8.777370220420876, -8.719316540875303,
  -8.661272892502836, -8.603239201666335, -8.54521539488569,
  -8.487201398836447, -8.429197140348434, -8.371202546404396,
  -8.31321754413864, -8.255242060835704, -8.197276023928998,
  -8.139319360999488, -8.08137199977435, -8.023433868125661,
  -7.965504894069098, -7.907585005762617, -7.849674131505154,
  -7.7917721997353455, -7.733879139030237, -7.675994878104,
  -7.618119345806677, -7.560252471122877, -7.502394183170566,
  -7.444544411199777, -7.386703084591376, -7.328870132855819,
  -7.271045485631924, -7.21322907268563, -7.155420823908775,
  -7.097620669317891, -7.039828539052975, -6.982044363376299,
  -6.924268072671206, -6.866499597440894, -6.808738868307268,
  -6.750985816009716, -6.693240371403953, -6.635502465460837,
  -6.577772029265211, -6.520048994014739, -6.462333291018735,
  -6.404624851697027, -6.346923607578796, -6.28922949030144,
  -6.231542431609444, -6.173862363353233, -6.11618921748805,
  -6.058522926072834, -6.000863421269096, -5.943210635339807,
  -5.8855645006483, -5.82792494965714, -5.770291914927053,
  -5.712665329115801, -5.655045124977107, -5.597431235359573,
  -5.5398235932055755, -5.482222131550199, -5.424626783520158,
  -5.367037482332735, -5.309454161294699, -5.251876753801243,
  -5.1943051933349365, -5.136739413464667, -5.079179347844574,
  -5.021624930213017, -4.964076094391522, -4.9065327742837415,
  -4.8489949038744316, -4.791462417228399, -4.733935248489471,
  -4.676413331879486, -4.618896601697259, -4.561384992317562,
  -4.503878438190103, -4.446376873838523, -4.388880233859384,
  -4.33138845292115, -4.273901465763194, -4.216419207194799,
  -4.158941612094155, -4.101468615407355, -4.044000152147421,
  -3.9865361573933136, -3.929076566288929, -3.871621314042117,
  -3.8141703359237256, -3.7567235672665973, -3.6992809434646023,
  -3.6418423999716665, -3.5844078723007975, -3.526977296023122,
  -3.4695506067669224, -3.4121277402166625, -3.354708632112034,
  -3.297293218247004, -3.2398814344688454, -3.182473216677204,
  -3.1250685008231285, -3.0676672229081228, -3.010269318983207,
  -2.952874725147976, -2.895483377549651, -2.8380952123821213,
  -2.7807101658850364, -2.723328174342844, -2.6659491740838916,
  -2.6085731014794384, -2.551199892942758, -2.493829484928218,
  -2.436461813930321, -2.379096816482811, -2.3217344291577184,
  -2.2643745885644577, -2.2070172313489014, -2.1496622941924604,
  -2.092309713811154, -2.034959426954715, -1.977611370405662,
  -1.920265480978378, -1.8629216955182064, -1.8055799509005352,
  -1.7482401840299027, -1.690902331839065, -1.6335663312880973,
  -1.5762321193635016, -1.5188996330772628, -1.4615688094660038,
  -1.404239585590017, -1.3469118985324098, -1.2895856853981644,
  -1.2322608833132909, -1.1749374294238804, -1.1176152608952008,
  -1.0602943149108364, -1.0029745286717888, -0.945655839395532,
  -0.8883381843151706, -0.8310215006785162, -0.7737057257471671,
  -0.7163907967957006, -0.6590766511106907, -0.6017632259898676,
  -0.5444504587411902, -0.48713828668196585, -0.4298266471379511,
  -0.3725154774425194, -0.31520471493569163, -0.2578942969632464,
  -0.20058416087591344, -0.1432742440284399, -0.08596448377855989,
  -0.028654817486422266, 0.028654817486422266, 0.08596448377855989,
  0.1432742440284399, 0.20058416087591344, 0.2578942969632464,
  0.31520471493569163, 0.3725154774425194, 0.4298266471379511,
  0.48713828668196585, 0.5444504587411902, 0.6017632259898676,
  0.6590766511106907, 0.7163907967957006, 0.7737057257471671,
  0.8310215006785162, 0.8883381843151706, 0.945655839395532,
  1.0029745286717888, 1.0602943149108364, 1.1176152608952008,
  1.1749374294238804, 1.2322608833132909, 1.2895856853981644,
  1.3469118985324098, 1.404239585590017, 1.4615688094660038,
  1.5188996330772628, 1.5762321193635016, 1.6335663312880973,
  1.690902331839065, 1.7482401840299027, 1.8055799509005352,
  1.8629216955182064, 1.920265480978378, 1.977611370405662,
  2.034959426954715, 2.092309713811154, 2.1496622941924604,
  2.2070172313489014, 2.2643745885644577, 2.3217344291577184,
  2.379096816482811, 2.436461813930321, 2.493829484928218,
  2.551199892942758, 2.6085731014794384, 2.6659491740838916,
  2.723328174342844, 2.7807101658850364, 2.8380952123821213,
  2.895483377549651, 2.952874725147976, 3.010269318983207,
  3.0676672229081228, 3.1250685008231285, 3.182473216677204,
  3.2398814344688454, 3.297293218247004, 3.354708632112034,
  3.4121277402166625, 3.4695506067669224, 3.526977296023122,
  3.5844078723007975, 3.6418423999716665, 3.6992809434646023,
  3.7567235672665973, 3.8141703359237256, 3.871621314042117,
  3.929076566288929, 3.9865361573933136, 4.044000152147421,
  4.101468615407355, 4.158941612094155, 4.216419207194799,
  4.273901465763194, 4.33138845292115, 4.388880233859384,
  4.446376873838523, 4.503878438190103, 4.561384992317562,
  4.618896601697259, 4.676413331879486, 4.733935248489471,
  4.791462417228399, 4.8489949038744316, 4.9065327742837415,
  4.964076094391522, 5.021624930213017, 5.079179347844574,
  5.136739413464667, 5.1943051933349365, 5.251876753801243,
  5.309454161294699, 5.367037482332735, 5.424626783520158,
  5.482222131550199, 5.5398235932055755, 5.597431235359573,
  5.655045124977107, 5.712665329115801, 5.770291914927053,
  5.82792494965714, 5.8855645006483, 5.943210635339807,
  6.000863421269096, 6.058522926072834, 6.11618921748805,
  6.173862363353233, 6.231542431609444, 6.28922949030144,
  6.346923607578796, 6.404624851697027, 6.462333291018735,
  6.520048994014739, 6.577772029265211, 6.635502465460837,
  6.693240371403953, 6.750985816009716, 6.808738868307268,
  6.866499597440894, 6.924268072671206, 6.982044363376299,
  7.039828539052975, 7.097620669317891, 7.155420823908775,
  7.21322907268563, 7.271045485631924, 7.328870132855819,
  7.386703084591376, 7.444544411199777, 7.502394183170566,
  7.560252471122877, 7.618119345806677, 7.675994878104,
  7.733879139030237, 7.7917721997353455, 7.849674131505154,
  7.907585005762617, 7.965504894069098, 8.023433868125661,
  8.08137199977435, 8.139319360999488, 8.197276023928998,
  8.255242060835704, 8.31321754413864, 8.371202546404396,
  8.429197140348434, 8.487201398836447, 8.54521539488569,
  8.603239201666335, 8.661272892502836, 8.719316540875303,
  8.777370220420876, 8.835434004935106, 8.893507968373351,
  8.95159218485218, 9.009686728650752, 9.067791674212287,
  9.125907096145443, 9.18403306922575, 9.242169668397075,
  9.300316968773062, 9.35847504563857, 9.416643974451162,
  9.474823830842558, 9.533014690620133, 9.591216629768413,
  9.649429724450544, 9.707654051009829, 9.765889685971246,
  9.82413670604295, 9.882395188117844, 9.940665209275085,
  9.998946846781678, 10.057240178094006, 10.115545280859424,
  10.173862232917848, 10.232191112303319, 10.290531997245646,
  10.348884966171973, 10.407250097708465, 10.46562747068186,
  10.524017164121195, 10.5824192572594, 10.640833829534998,
  10.699260960593763, 10.757700730290416, 10.816153218690316,
  10.874618506071172, 10.933096672924755, 10.991587799958657,
  11.050091968097973, 11.108609258487139, 11.167139752491611,
  11.225683531699712, 11.284240677924373, 11.34281127320496,
  11.401395399809083, 11.459993140234404, 11.518604577210501,
  11.577229793700704, 11.635868872903956, 11.694521898256697,
  11.753188953434725, 11.811870122355167, 11.870565489178286,
  11.929275138309531, 11.987999154401372, 12.0467376223553,
  12.105490627323837, 12.164258254712456, 12.223040590181581,
  12.281837719648633, 12.340649729290057, 12.399476705543314,
  12.458318735109, 12.517175904952833, 12.576048302307832,
  12.634936014676368, 12.693839129832256, 12.752757735822913,
  12.811691920971528, 12.870641773879184, 12.929607383427042,
  12.988588838778565, 13.047586229381674, 13.106599644971041,
  13.165629175570276, 13.224674911494214, 13.283736943351201,
  13.342815362045366, 13.401910258778937, 13.461021725054593,
  13.52014985267778, 13.579294733759115, 13.63845646071671,
  13.697635126278639, 13.756830823485322, 13.81604364569198,
  13.875273686571074, 13.934521040114795, 13.99378580063757,
  14.05306806277857, 14.112367921504232, 14.171685472110841,
  14.231020810227097, 14.2903740318167, 14.349745233181002,
  14.409134510961579, 14.468541962142986, 14.527967684055358,
  14.587411774377152, 14.646874331137866, 14.706355452720768,
  14.765855237865694, 14.825373785671848, 14.884911195600559,
  14.944467567478199, 15.004043001498966, 15.063637598227833,
  15.123251458603418, 15.182884683940959, 15.242537375935212,
  15.302209636663502, 15.361901568588669, 15.421613274562151,
  15.481344857826995, 15.541096422021017, 15.600868071179812,
  15.660659909739985, 15.720472042542266, 15.780304574834702,
  15.840157612275895, 15.900031260938242, 15.959925627311215,
  16.01984081830463, 16.079776941252042, 16.139734103914044,
  16.199712414481716, 16.259711981579983, 16.319732914271096,
  16.379775322058173, 16.439839314888562, 16.499925003157543,
  16.5600324977118, 16.620161909853064, 16.68031335134175,
  16.740486934400636, 16.800682771718552, 16.86090097645409,
  16.921141662239457, 16.981404943184213, 17.041690933879106,
  17.10199974939999, 17.162331505311702, 17.22268631767206,
  17.283064303035772, 17.34346557845848, 17.403890261500866,
  17.46433847023266, 17.52481032323688, 17.585305939613914,
  17.645825438985717, 17.70636894150018, 17.76693656783528,
  17.827528439203473, 17.888144677356117, 17.94878540458775,
  18.009450743740715, 18.07014081820945, 18.130855751945244,
  18.19159566946068, 18.252360695834284, 18.31315095671521,
  18.373966578327988, 18.434807687477207, 18.495674411552436,
  18.556566878532976, 18.61748521699277, 18.678429556105467,
  18.73940002564926, 18.800396756012063, 18.86141987819655,
  18.922469523825296, 18.98354582514601, 19.044648915036767,
  19.105778927011333, 19.166935995224467, 19.22812025447742,
  19.28933184022331, 19.350570888572722, 19.411837536299196,
  19.473131920844946, 19.534454180326506, 19.595804453540488,
  19.65718287996938, 19.718589599787418, 19.78002475386653,
  19.841488483782303, 19.902980931820007, 19.964502240980803,
  20.02605255498779, 20.087632018292346, 20.149240776080415,
  20.210878974278813, 20.27254675956176, 20.334244279357325,
  20.395971681854032, 20.45772911600746, 20.519516731547064,
  20.581334678982806, 20.643183109612163, 20.705062175526955,
  20.766972029620433, 20.828912825594305, 20.890884717965925,
  20.95288786207549, 21.014922414093448, 21.076988531027805,
  21.139086370731597, 21.201216091910542, 21.26337785413059,
  21.32557181782568, 21.387798144305567, 21.45005699576369,
  21.51234853528521, 21.574672926855015, 21.637030335365903,
  21.69942092662691, 21.761844867371565, 21.82430232526636,
  21.88679346891933, 21.949318467888652, 22.011877492691372,
  22.07447071481224, 22.137098306712698, 22.199760441839835,
  22.262457294635563, 22.325189040545883, 22.387955856030235,
  22.45075791857089, 22.513595406682608, 22.57646849992229,
  22.639377378898736, 22.70232222528264, 22.765303221816538,
  22.828320552324957, 22.891374401724743, 22.954464956035373,
  23.017592402389525, 23.080756929043694, 23.143958725388924,
  23.207197981961745, 23.27047489045518, 23.33378964372992,
  23.397142435825547, 23.460533461972037, 23.523962918601303,
  23.58743100335891, 23.650937915115904, 23.714483853980838,
  23.778069021311882, 23.84169361972924, 23.905357853127303,
  23.969061926687708, 24.032806046891622, 24.096590421532984,
  24.160415259731504, 24.224280771945836, 24.288187169987076,
  24.352134667032274, 24.416123477638333, 24.480153817755774,
  24.544225904742863, 24.608339957380053, 24.672496195884285,
  24.73669484192378, 24.800936118632766, 24.865220250626596,
  24.929547464017045, 24.993917986427544, 25.058332047009127,
  25.122789876455972, 25.187291707021604, 25.251837772535183,
  25.316428308417954, 25.3810635516999, 25.44574374103669,
  25.510469116726945, 25.575239920729402, 25.640056396680777,
  25.704918789913357, 25.76982734747332, 25.83478231813894,
  25.89978395243924, 25.964832502672852, 26.02992822292702,
  26.095071369097077, 26.160262198906103, 26.225500971924685,
  26.29078794959121, 26.35612339523236, 26.421507574083794,
  26.486940753311192, 26.552423202031655, 26.61795519133531,
  26.68353699430729, 26.749168886049947, 26.814851143705486,
  26.88058404647881, 26.946367875660826, 27.01220291465199,
  27.078089448986194, 27.144027766355045, 27.21001815663244,
  27.27606091189966, 27.34215632647052, 27.408304696917284,
  27.47450632209655, 27.54076150317591, 27.607070543660736,
  27.67343374942146, 27.739851428721288, 27.806323892244244,
  27.87285145312371, 27.939434426971506, 28.006073131907062,
  28.072767888587467, 28.139519020237596, 28.20632685268108,
  28.27319171437134, 28.340113936423467, 28.40709385264633,
  28.47413179957535, 28.541228116505774, 28.608383145526332,
  28.675597231553578, 28.742870722366725, 28.81020396864294,
  28.877597323993474, 28.94505114499996, 29.01256579125168,
  29.08014162538315, 29.147779013112523, 29.215478323280472,
  29.283239927889813, 29.351064202145594, 29.418951524496112,
  29.486902276674428, 29.554916843740536, 29.622995614124328,
  29.69113897966931, 29.75934733567692, 29.82762108095162,
  29.89596061784695, 29.96436635231198, 30.032838693938945,
  30.101378056011402, 30.169984855553388, 30.238659513379336,
  30.307402454144892, 30.37621410639858, 30.445094902634416,
  30.514045279345407, 30.583065677077965, 30.652156540487294,
  30.721318318393852, 30.79055146384066, 30.85985643415174,
  30.929233690991577, 30.998683700425552, 31.06820693298174,
  31.13780386371346, 31.207474972263256, 31.277220742927895,
  31.3470416647246, 31.41693823145858, 31.486910941791628,
  31.556960299312216, 31.6270868126067, 31.697290995332054,
  31.767573366289746, 31.83793444950126, 31.908374774284873,
  31.978894875333943, 32.04949529279676, 32.12017657235782,
  32.19093926532087, 32.2617839286933, 32.332711125272304,
  32.40372142373303, 32.47481539871768, 32.54599363092742,
  32.617256707215184, 32.68860522068086, 32.76003977076836,
  32.83156096336426, 32.903169410899004, 32.97486573244971,
  33.04665055384524, 33.1185245077735, 33.19048823389081,
  33.26254237893377, 33.33468759683311, 33.406924548830204,
  33.47925390359602, 33.55167633735231, 33.62419253399585,
  33.69680318522489, 33.76950899066842, 33.84231065801852,
  33.9152089031651, 33.98820445033401, 34.061298032227896,
  34.13449039017018, 34.20778227425243, 34.28117444348483,
  34.35466766594988, 34.42826271895986, 34.50196038921772,
  34.575761472981405, 34.64966677623233, 34.7236771148474,
  34.79779331477503, 34.87201621221548, 34.94634665380506,
  35.02078549680492, 35.095333609293945, 35.169991870366914,
  35.24476117033643, 35.31964241094027, 35.39463650555383,
  35.46974437940719, 35.54496696980808, 35.62030522636969,
  35.69576011124455, 35.77133259936403, 35.84702367868369,
  35.92283435043498, 35.99876562938319, 36.074818544091826,
  36.150994137194004, 36.22729346567035, 36.30371760113451,
  36.380267630125935, 36.456944654409995, 36.53374979128642,
  36.610684173905724, 36.68774895159384, 36.76494529018563,
  36.842274372367385, 36.919737398028474, 36.9973355846226,
  37.0750701675391, 37.15294240048423, 37.23095355587307,
  37.309104925232745, 37.38739781961649, 37.465833570029574,
  37.544413527867675, 37.6231390653673, 37.70201157606961,
  37.78103247529752, 37.86020320064674, 37.93952521249137,
  38.018999994504554, 38.09862905419436, 38.178413923456056,
  38.258356159141066, 38.33845734364298, 38.41871908550205,
  38.49914302002783, 38.579730809941644, 38.660484146038684,
  38.741404747871776, 38.822494364456084, 38.90375477499684,
  38.9851877896405, 39.066795250250316, 39.14857903120731,
  39.230541040237604, 39.31268321926739, 39.395007545306726,
  39.477516031362605, 39.56021072738376, 39.643093721237626,
  39.726167139721, 39.809433149606086, 39.89289395872311,
  39.976551817081706, 40.060409018031976, 40.144467899467394,
  40.22873084507155, 40.31320028561063, 40.397878700273374,
  40.48276861806123, 40.567872619230535, 40.65319333678937,
  40.73873345805194, 40.82449572625254, 40.910482942222444,
  40.996697966133105, 41.0831437193075, 41.169823186104885,
  41.25673941588099, 41.343895525028486, 41.43129469910121,
  41.51894019502645, 41.60683534341025, 41.69498355094012,
  41.783388302890664, 41.8720531657371, 41.960981789883036,
  42.05017791250818, 42.13964536054276, 42.22938805377599,
  42.31941000810563, 42.40971533893615, 42.50030826473558,
  42.59119311075828, 42.68237431294506, 42.77385642200913,
  42.865644107721366, 42.957742163404696, 43.05015551065153,
  43.14288920427823, 43.235948437529935, 43.3293385475538,
  43.42306502115531, 43.51713350085829, 43.61154979128667,
  43.70631986589031, 43.801449874038084, 43.896946148502096,
  43.99281521336156, 44.0890637923539, 44.18569881770632,
  44.28272743948078, 44.380157035470624, 44.4779952216892,
  44.57624986349425, 44.674929087396606, 44.774041293605926,
  44.87359516936987, 44.97359970317066, 45.07406419984687,
  45.17499829671607, 45.27641198078117, 45.37831560711164,
  45.48071991849915, 45.58363606649914, 45.687075633979504,
  45.79105065931231, 45.89557366235727, 46.00065767240461,
  46.106316258260875, 46.21256356068394, 46.31941432739748,
  46.42688395094156, 46.53498850964739, 46.6437448120594,
  46.75317044516938, 46.86328382687221, 46.974104263107506,
  47.085652010214, 47.197948343091475, 47.31101562985484,
  47.42487741375286, 47.53955850324634, 47.655085071265304,
  47.77148476482559, 47.88878682636782, 48.00702222840013,
  48.12622382328404, 48.246426510318464, 48.36766742264341,
  48.4899861369396, 48.61342490944391, 48.73802894246357,
  48.863846686389174, 48.99093018320942, 49.11933545877167,
  49.24912297259201, 49.38035813596413, 49.51311191159503,
  49.64746151114597, 49.783491211118616, 49.92129331280579,
  50.060969278934266, 50.20263108880324, 50.346402866001846,
  50.492422849471424, 50.64084580159866, 50.79184597903793,
  50.94562083733587, 51.102395705936516, 51.262429766574236,
  51.42602381313066, 51.5935304947436, 51.765368098571166,
  51.94203950889288, 52.12415896387552, 52.31249097464213,
  52.50800901629689, 52.71198801563665, 52.92615831397634,
  53.15298067808064, 53.39618607966144, 53.661986551031596,
  53.96241809944158, 54.328926130872055
  };
const real _hermite_gauss_weights_x[] = {
  0.42569184393634385, 0.3249567967276586, 0.2802986015980284,
  0.25315713324910166, 0.23424380680372367, 0.22000503548177544,
  0.2087374637630829, 0.19950463254617876, 0.1917414980133161,
  0.18508328778673924, 0.17928209342441523, 0.17416246859778775,
  0.16959611701205476, 0.16548665072122593, 0.16175999128288557,
  0.1583580940186295, 0.15523471242947257, 0.1523524605408998,
  0.14968072645243646, 0.14719415938604596, 0.14487155217180486,
  0.14269500220754397, 0.1406492721626895, 0.13872129634891353,
  0.13689979502138885, 0.1351749696262274, 0.13353825963655888,
  0.13198214669807298, 0.13049999558554157, 0.12908592398252508,
  0.12773469512487529, 0.12644162868537906, 0.12520252631296663,
  0.12401360908268529, 0.12287146462499367, 0.12177300224310428,
  0.12071541459598996, 0.11969614484349853, 0.11871285836709539,
  0.11776341831361917, 0.11684586436446308, 0.1159583942551442,
  0.11509934759939439, 0.11426719171846339, 0.1134605091688146,
  0.11267798673375132, 0.11191840567768785, 0.11118063311032408,
  0.11046361428324351, 0.10976636574119807, 0.10908796917674628,
  0.10842756593906401, 0.10778435209350773, 0.10715757397680346,
  0.10654652419097209, 0.10595053797854054, 0.10536898994389694,
  0.10480129107816961, 0.10424688605833059, 0.10370525078497772,
  0.10317589013836426, 0.10265833593625949, 0.10215214505534585,
  0.10165689772007491, 0.10117219592764994, 0.10069766200541516,
  0.10023293728066235, 0.09977768085909958, 0.09933156849706454,
  0.09889429155943263, 0.09846555605786883, 0.09804508176173332,
  0.09763260137195404, 0.09722785975803222, 0.09683061324818976,
  0.09644062896864734, 0.09605768423134357, 0.09568156596319645,
  0.09531207017224008, 0.09494900145370064, 0.09459217252378982,
  0.09424140378977827, 0.09389652294166041, 0.09355736457561047,
  0.09322376983864708, 0.09289558609346668, 0.09257266660975222,
  0.09225487026677055, 0.09194206128273988, 0.0916341089505213,
  0.09133088739787532, 0.09103227535664357, 0.09073815594429689,
  0.09044841646512801, 0.09016294821199165, 0.08988164628908217,
  0.08960440943728767, 0.08933113987558143, 0.0890617431445232,
  0.08879612796147152, 0.08853420608482916, 0.08827589218342669,
  0.0880211037119185, 0.08776976079520621, 0.08752178611655628,
  0.08727710481219045, 0.08703564437176525, 0.08679733454365546,
  0.0865621072430484, 0.0863298964665416, 0.08610063821088505,
  0.0858742703939818, 0.08565073278304056, 0.08542996691980542,
  0.08521191605655698, 0.08499652509076279, 0.08478374050284093,
  0.08457351029882272, 0.08436578395404308, 0.08416051235934185,
  0.08395764777044173, 0.08375714375842327, 0.0835589551638577,
  0.0833630380522295, 0.08316934967084066, 0.08297784840687716,
  0.08278849374988154, 0.08260124625359619, 0.08241606750003366,
  0.08223292006432227, 0.08205176748191588, 0.08187257421821456,
  0.08169530563589425, 0.08151992796687017, 0.08134640828427941,
  0.08117471447535055, 0.08100481521504703, 0.08083667994158816,
  0.08067027883263767, 0.08050558278248804, 0.0803425633782808,
  0.08018119288080275, 0.08002144420274408, 0.07986329088955597,
  0.07970670709946451, 0.07955166758663282, 0.0793981476820025,
  0.07924612327722888, 0.07909557080823244, 0.07894646723863978,
  0.0787987900452287, 0.07865251720308553, 0.07850762717143787,
  0.07836409887963512, 0.07822191171459207, 0.07808104550660151,
  0.07794148051872928, 0.07780319743408812, 0.07766617734369033,
  0.07753040173650198, 0.07739585248829535, 0.07726251185059116,
  0.07713036244135019, 0.07699938723490778, 0.07686956955249888,
  0.07674089305329578, 0.07661334172595152, 0.07648689987927863,
  0.07636155213404133, 0.07623728341598315, 0.07611407894706386,
  0.07599192423777111, 0.0758708050812111, 0.07575070754432163,
  0.07563161796244051, 0.07551352293159026, 0.07539640930265773,
  0.0752802641753062, 0.07516507489144102, 0.07505082902932042,
  0.07493751439885658, 0.0748251190343337, 0.0747136311907832,
  0.07460303933733504, 0.07449333215311961, 0.07438449852287148,
  0.07427652752991684, 0.07416940845387826, 0.07406313076494245,
  0.07395768412014925, 0.07385305835826679, 0.07374924349648006,
  0.07364622972617024, 0.0735440074083847, 0.07344256707123759,
  0.07334189940496766, 0.07324199525886514, 0.07314284563834851,
  0.07304444170072161, 0.07294677475176947, 0.07284983624329901,
  0.0727536177695563, 0.07265811106393154, 0.07256330799676602,
  0.07246920057129719, 0.07237578092193502, 0.07228304131117161,
  0.07219097412615842, 0.07209957187739956, 0.07200882719507291,
  0.07191873282704178, 0.07182928163681052, 0.07174046660033274,
  0.0716522808041679, 0.07156471744317455, 0.07147776981861285,
  0.07139143133571327, 0.07130569550124372, 0.07122055592248036,
  0.07113600630414924, 0.071052040446984, 0.07096865224648805,
  0.07088583568922371, 0.07080358485355366, 0.07072189390564018,
  0.07064075709893715, 0.07056016877256552, 0.07048012334889295,
  0.07040061533257472, 0.07032163930887161, 0.07024318994209426,
  0.07016526197422795, 0.07008785022303576, 0.0700109495812948,
  0.06993455501502713, 0.06985866156210267, 0.06978326433110003,
  0.0697083584999752, 0.06963393931470767, 0.06956000208814096,
  0.06948654219874285, 0.06941355508944382, 0.06934103626664846,
  0.06926898129859904, 0.0691973858147497, 0.06912624550459714,
  0.06905555611651193, 0.0689853134568723, 0.06891551338868247,
  0.06884615183096442, 0.06877722475781645, 0.06870872819713343,
  0.0686406582298179, 0.06857301098905963, 0.06850578265908301,
  0.06843896947470625, 0.06837256772003739, 0.06830657372808256,
  0.06824098387949852, 0.06817579460230284, 0.06811100237047892,
  0.06804660370361709, 0.06798259516618448, 0.06791897336644911,
  0.06785573495608845, 0.06779287662944396, 0.06773039512267766,
  0.06766828721303215, 0.06760654971846894, 0.06754517949678,
  0.06748417344507901, 0.06742352849884065, 0.06736324163188813,
  0.06730330985510528, 0.06724373021664243, 0.06718449980039679,
  0.06712561572621205, 0.06706707514890095, 0.067008875257812,
  0.06695101327653648, 0.06689348646195661, 0.06683629210388979,
  0.0667794275247941, 0.06672289007889486, 0.06666667715215968,
  0.06661078616129519, 0.06655521455372093, 0.0664999598066947,
  0.06644501942752543, 0.06639039095232262, 0.06633607194590566,
  0.06628206000170263, 0.0662283527407914, 0.066174947811829,
  0.06612184289064758, 0.0660690356793822, 0.06601652390691544,
  0.06596430532766084, 0.06591237772187342, 0.06586073889472537,
  0.0658093866762073, 0.06575831892084968, 0.0657075335072066,
  0.0656570283376292, 0.06560680133774037, 0.06555685045631414,
  0.06550717366485953, 0.06545776895735106, 0.06540863434984921,
  0.06535976788023039, 0.06531116760768764, 0.065262831612795,
  0.06521475799705113, 0.06516694488245034, 0.06511939041120679,
  0.0650720927459428, 0.0650250500687671, 0.0649782605812646,
  0.06493172250445141, 0.06488543407816452, 0.06483939356103942,
  0.06479359923014433, 0.0647480493806605, 0.06470274232601218,
  0.06465767639704502, 0.06461284994243066, 0.06456826132782363,
  0.06452390893596882, 0.06447979116651908, 0.06443590643577007,
  0.06439225317621233, 0.06434882983641668, 0.0643056348813906,
  0.06426266679131559, 0.06421992406227739, 0.06417740520554428,
  0.06413510874744996, 0.06409303322953425, 0.06405117720782735,
  0.06400953925318555, 0.06396811795053678, 0.06392691189916926,
  0.06388591971253849, 0.06384514001772763, 0.063804571455556,
  0.06376421268027828, 0.06372406235963904, 0.06368411917450884,
  0.06364438181842332, 0.06360484899844752, 0.0635655194335576,
  0.0635263918558061, 0.06348746500939827, 0.06344873765079441,
  0.06341020854847419, 0.06337187648294007, 0.06333374024642151,
  0.06329579864279233, 0.06325805048735982, 0.06322049460689437,
  0.0631831298393861, 0.06314595503387173, 0.06310896905029359,
  0.06307217075951699, 0.06303555904310122, 0.06299913279305581,
  0.06296289091201332, 0.06292683231277582, 0.06289095591843186,
  0.06285526066221242, 0.06281974548718666, 0.06278440934638573,
  0.0627492512025244, 0.06271427002789504, 0.06267946480439648,
  0.06264483452334677, 0.06261037818526756, 0.0625760947999001,
  0.06254198338615564, 0.0625080429718414, 0.06247427259366576,
  0.062440671297112914, 0.062407238136437254, 0.06237397217435717,
  0.0623408724821251, 0.062307938139461325, 0.062275168234285576,
  0.062242561862726316, 0.062210118129148465, 0.062177836145863606,
  0.06214571503310633, 0.062113753919011416, 0.062081951939437455,
  0.06205030823801389, 0.06201882196584685, 0.06198749228161023,
  0.061956318351521086, 0.061925299349000644, 0.06189443445479502,
  0.06186372285686447, 0.06183316375033715, 0.061802756337256515,
  0.06177249982680757, 0.061742393434853, 0.0617124363843372,
  0.06168262790475504, 0.061652967232370404, 0.061623453610028245,
  0.061594086287133656, 0.061564864519548124, 0.061535787569546946,
  0.06150685470577585, 0.061478065203055834, 0.061449418342561964,
  0.061420913411493576, 0.0613925497031459, 0.06136432651690598,
  0.06133624315803866, 0.06130829893775519, 0.06128049317306485,
  0.06125282518680334, 0.06122529430750863, 0.06119789986929575,
  0.06117064121204501, 0.06114351768101233, 0.061116528627114274,
  0.061089673406569886, 0.06106295138106659, 0.06103636191758544,
  0.06100990438838752, 0.060983578170928636, 0.06095738264790088,
  0.060931317207107705, 0.06090538124134826, 0.06087957414861288,
  0.06085389533166625, 0.060828344198294776, 0.06080292016125309,
  0.06077762263793505, 0.06075245105070058, 0.060727404826522474,
  0.06070248339711069, 0.060677686198821384, 0.06065301267272871,
  0.06062846226420453, 0.06060403442340973, 0.060579728604798294,
  0.06055554426738554, 0.06053148087447934, 0.06050753789374648,
  0.060483714797252994, 0.06046001106122737, 0.06043642616616172,
  0.060412959596814, 0.06038961084197704, 0.0603663793946507,
  0.060343264751814084, 0.06032026641454295, 0.06029738388794945,
  0.060274616681068455, 0.060251964306848836, 0.06022942628211834,
  0.060207002127615934, 0.060184691367916175, 0.0601624935312951,
  0.060140408149829475, 0.06011843475936624, 0.06009657289936387,
  0.06007482211298177, 0.06005318194695415, 0.06003165195168785,
  0.060010231681018725, 0.0599889206924714, 0.05996771854695204,
  0.05994662480883775, 0.05992563904601103, 0.05990476082968243,
  0.0598839897345006, 0.059863325338397735, 0.059842767222676646,
  0.05982231497191839, 0.05980196817394342, 0.05978172641982191,
  0.059761589303823845, 0.059741556423428564, 0.05972162737918552,
  0.05970180177488656, 0.05968207921731038, 0.059662459316367066,
  0.059642941684987835, 0.059623525939172084, 0.05960421169782944,
  0.05958499858294826, 0.0595658862193565, 0.059546874234895554,
  0.05952796226022092, 0.05950914992893329, 0.05949043687741756,
  0.05947182274496036, 0.05945330717362189, 0.05943488980818063,
  0.059416570296266596, 0.05939834828820251, 0.059380223437001306,
  0.0593621953984663, 0.0593442638309293, 0.05932642839548702,
  0.05930868875580193, 0.05929104457818197, 0.059273495531503656,
  0.05925604128720099, 0.05923868151926951, 0.0592214159042339,
  0.05920424412112098, 0.05918716585142636, 0.05917018077913672,
  0.05915328859068364, 0.0591364889749574, 0.059119781623168756,
  0.05910316622901802, 0.05908664248853217, 0.059070210100125045,
  0.0590538687645044, 0.059037618184726935, 0.05902145806616549,
  0.05900538811646233, 0.0589894080455006, 0.058973517565486015,
  0.0589577163907825, 0.05894200423802856, 0.058926380826019975,
  0.05891084587578609, 0.058895399110509575, 0.05888004025549695,
  0.05886476903821807, 0.05884958518825984, 0.058834488437348315,
  0.05881947851924289, 0.058804555169825135, 0.05878971812700056,
  0.05877496713077991, 0.05876030192315397, 0.05874572224813889,
  0.05873122785177038, 0.05871681848210175, 0.058702493889099115,
  0.058688253824700734, 0.05867409804286028, 0.058660026299371254,
  0.058646038352039055, 0.058632133960510535, 0.0586183128863552,
  0.05860457489303026, 0.05859091974583922, 0.05857734721197465,
  0.05856385706043636, 0.05855044906208519, 0.05853712298957769,
  0.05852387861739542, 0.05851071572181251, 0.058497634080868874,
  0.05848463347441115, 0.058471713683999775, 0.05845887449297595,
  0.058446115686408104, 0.058433437051096826, 0.058420838375530006,
  0.058408319449929996, 0.05839588006619961, 0.05838352001792117,
  0.05837123910034641, 0.05835903711039093, 0.05834691384660541,
  0.05833486910921197, 0.05832290270001416, 0.05831101442247716,
  0.05829920408165224, 0.05828747148420208, 0.058275816438354305,
  0.05826423875393805, 0.058252738242348924, 0.0582413147165212,
  0.05822996799097092, 0.058218697881733485, 0.05820750420638072,
  0.058196386784009596, 0.05818534543521123, 0.058174379982110405,
  0.058163490248324505, 0.05815267605892444, 0.05814193724049759,
  0.058131273621070643, 0.05812068503016272, 0.05811017129871258,
  0.05809973225911564, 0.05808936774520863, 0.05807907759227168,
  0.05806886163695695, 0.05805871971737513, 0.05804865167301118,
  0.05803865734475844, 0.05802873657490468, 0.05801888920710664,
  0.058009115086391054, 0.05799941405916628, 0.05798978597317926,
  0.05798023067754778, 0.057970748022725234, 0.05796133786050152,
  0.057952000043972884, 0.057942734427604455, 0.05793354086714075,
  0.05792441921963837, 0.057915369343480454, 0.057906391098315003,
  0.057897484345102626, 0.05788864894606571, 0.057879884764713986,
  0.05787119166581856, 0.057862569515430846, 0.05785401818082923,
  0.0578455375305773, 0.0578371274344541, 0.05782878776349973,
  0.057820518389950656, 0.057812319187314505, 0.057804190030282906,
  0.057796130794795564, 0.057788141357969676, 0.05778022159814321,
  0.05777237139483286, 0.05776459062878086, 0.05775687918188575,
  0.057749236937249045, 0.05774166377911576, 0.05773415959294657,
  0.05772672426533649, 0.057719357684036174, 0.05771205973797862,
  0.057704830317228444, 0.057697669312984146, 0.05769057661761901,
  0.05768355212461218, 0.05767659572858732, 0.057669707325277514,
  0.05766288681155726, 0.057656134085410024, 0.0576494490459217,
  0.057642831593312426, 0.05763628162886292, 0.057629799054997356,
  0.05762338377519677, 0.05761703569406125, 0.05761075471726456,
  0.05760454075154702, 0.057598393704747675, 0.05759231348576999,
  0.057586300004595255, 0.057580353172265716, 0.05757447290086584,
  0.05756865910357475, 0.05756291169459325, 0.057557230589182905,
  0.05755161570365774, 0.05754606695537101, 0.05754058426271115,
  0.057535167545096993, 0.05752981672298315, 0.05752453171787429,
  0.05751931245227132, 0.057514158849710194, 0.057509070834723945,
  0.05750404833289998, 0.05749909127081819, 0.05749419957604303,
  0.05748937317718181, 0.057484612003831134, 0.05747991598658103,
  0.057475285057013645, 0.0574707191477269, 0.05746621819228876,
  0.05746178212526547, 0.057457410882193784, 0.057453104399603966,
  0.05744886261501845, 0.057444685466912074, 0.057440572894739944,
  0.05743652483894419, 0.05743254124091958, 0.05742862204303405,
  0.05742476718861361, 0.057420976621944814, 0.05741725028830257,
  0.057413588133869986, 0.057409990105818716, 0.057406456152274986,
  0.05740298622228627, 0.05739958026587573, 0.05739623823400693,
  0.05739296007857586, 0.0573897457524254, 0.05738659520934968,
  0.057383508404065316, 0.05738048529223422, 0.05737752583045264,
  0.057374629976234645, 0.05737179768805104, 0.057369028925271764,
  0.05736632364821695, 0.057363681818125234, 0.0573611033971483,
  0.05735858834837923, 0.05735613663581293, 0.05735374822438376,
  0.05735142307992416, 0.0573491611691829, 0.05734696245984434,
  0.057344826920488104, 0.05734275452061046, 0.057340745230616906,
  0.05733879902183305, 0.05733691586648032, 0.05733509573768993,
  0.05733333860949804, 0.05733164445685391, 0.05733001325560759,
  0.05732844498250665, 0.05732693961520193, 0.05732549713226403,
  0.05732411751312537, 0.05732280073815264, 0.05732154678859092,
  0.0573203556466105, 0.05731922729523333, 0.057318161718416645,
  0.05731715890099447, 0.0573162188287108, 0.057315341488187926,
  0.05731452686695306, 0.0573137749534129, 0.057313085736891346,
  0.057312459207581254, 0.05731189535657482, 0.057311394175850544,
  0.0573109556583079, 0.05731057979769629, 0.0573102665886815,
  0.05731001602680152, 0.057309828108517175, 0.05730970283113539,
  0.05730964019289649, 0.05730964019289649, 0.05730970283113539,
  0.057309828108517175, 0.05731001602680152, 0.0573102665886815,
  0.05731057979769629, 0.0573109556583079, 0.057311394175850544,
  0.05731189535657482, 0.057312459207581254, 0.057313085736891346,
  0.0573137749534129, 0.05731452686695306, 0.057315341488187926,
  0.0573162188287108, 0.05731715890099447, 0.057318161718416645,
  0.05731922729523333, 0.0573203556466105, 0.05732154678859092,
  0.05732280073815264, 0.05732411751312537, 0.05732549713226403,
  0.05732693961520193, 0.05732844498250665, 0.05733001325560759,
  0.05733164445685391, 0.05733333860949804, 0.05733509573768993,
  0.05733691586648032, 0.05733879902183305, 0.057340745230616906,
  0.05734275452061046, 0.057344826920488104, 0.05734696245984434,
  0.0573491611691829, 0.05735142307992416, 0.05735374822438376,
  0.05735613663581293, 0.05735858834837923, 0.0573611033971483,
  0.057363681818125234, 0.05736632364821695, 0.057369028925271764,
  0.05737179768805104, 0.057374629976234645, 0.05737752583045264,
  0.05738048529223422, 0.057383508404065316, 0.05738659520934968,
  0.0573897457524254, 0.05739296007857586, 0.05739623823400693,
  0.05739958026587573, 0.05740298622228627, 0.057406456152274986,
  0.057409990105818716, 0.057413588133869986, 0.05741725028830257,
  0.057420976621944814, 0.05742476718861361, 0.05742862204303405,
  0.05743254124091958, 0.05743652483894419, 0.057440572894739944,
  0.057444685466912074, 0.05744886261501845, 0.057453104399603966,
  0.057457410882193784, 0.05746178212526547, 0.05746621819228876,
  0.0574707191477269, 0.057475285057013645, 0.05747991598658103,
  0.057484612003831134, 0.05748937317718181, 0.05749419957604303,
  0.05749909127081819, 0.05750404833289998, 0.057509070834723945,
  0.057514158849710194, 0.05751931245227132, 0.05752453171787429,
  0.05752981672298315, 0.057535167545096993, 0.05754058426271115,
  0.05754606695537101, 0.05755161570365774, 0.057557230589182905,
  0.05756291169459325, 0.05756865910357475, 0.05757447290086584,
  0.057580353172265716, 0.057586300004595255, 0.05759231348576999,
  0.057598393704747675, 0.05760454075154702, 0.05761075471726456,
  0.05761703569406125, 0.05762338377519677, 0.057629799054997356,
  0.05763628162886292, 0.057642831593312426, 0.0576494490459217,
  0.057656134085410024, 0.05766288681155726, 0.057669707325277514,
  0.05767659572858732, 0.05768355212461218, 0.05769057661761901,
  0.057697669312984146, 0.057704830317228444, 0.05771205973797862,
  0.057719357684036174, 0.05772672426533649, 0.05773415959294657,
  0.05774166377911576, 0.057749236937249045, 0.05775687918188575,
  0.05776459062878086, 0.05777237139483286, 0.05778022159814321,
  0.057788141357969676, 0.057796130794795564, 0.057804190030282906,
  0.057812319187314505, 0.057820518389950656, 0.05782878776349973,
  0.0578371274344541, 0.0578455375305773, 0.05785401818082923,
  0.057862569515430846, 0.05787119166581856, 0.057879884764713986,
  0.05788864894606571, 0.057897484345102626, 0.057906391098315003,
  0.057915369343480454, 0.05792441921963837, 0.05793354086714075,
  0.057942734427604455, 0.057952000043972884, 0.05796133786050152,
  0.057970748022725234, 0.05798023067754778, 0.05798978597317926,
  0.05799941405916628, 0.058009115086391054, 0.05801888920710664,
  0.05802873657490468, 0.05803865734475844, 0.05804865167301118,
  0.05805871971737513, 0.05806886163695695, 0.05807907759227168,
  0.05808936774520863, 0.05809973225911564, 0.05811017129871258,
  0.05812068503016272, 0.058131273621070643, 0.05814193724049759,
  0.05815267605892444, 0.058163490248324505, 0.058174379982110405,
  0.05818534543521123, 0.058196386784009596, 0.05820750420638072,
  0.058218697881733485, 0.05822996799097092, 0.0582413147165212,
  0.058252738242348924, 0.05826423875393805, 0.058275816438354305,
  0.05828747148420208, 0.05829920408165224, 0.05831101442247716,
  0.05832290270001416, 0.05833486910921197, 0.05834691384660541,
  0.05835903711039093, 0.05837123910034641, 0.05838352001792117,
  0.05839588006619961, 0.058408319449929996, 0.058420838375530006,
  0.058433437051096826, 0.058446115686408104, 0.05845887449297595,
  0.058471713683999775, 0.05848463347441115, 0.058497634080868874,
  0.05851071572181251, 0.05852387861739542, 0.05853712298957769,
  0.05855044906208519, 0.05856385706043636, 0.05857734721197465,
  0.05859091974583922, 0.05860457489303026, 0.0586183128863552,
  0.058632133960510535, 0.058646038352039055, 0.058660026299371254,
  0.05867409804286028, 0.058688253824700734, 0.058702493889099115,
  0.05871681848210175, 0.05873122785177038, 0.05874572224813889,
  0.05876030192315397, 0.05877496713077991, 0.05878971812700056,
  0.058804555169825135, 0.05881947851924289, 0.058834488437348315,
  0.05884958518825984, 0.05886476903821807, 0.05888004025549695,
  0.058895399110509575, 0.05891084587578609, 0.058926380826019975,
  0.05894200423802856, 0.0589577163907825, 0.058973517565486015,
  0.0589894080455006, 0.05900538811646233, 0.05902145806616549,
  0.059037618184726935, 0.0590538687645044, 0.059070210100125045,
  0.05908664248853217, 0.05910316622901802, 0.059119781623168756,
  0.0591364889749574, 0.05915328859068364, 0.05917018077913672,
  0.05918716585142636, 0.05920424412112098, 0.0592214159042339,
  0.05923868151926951, 0.05925604128720099, 0.059273495531503656,
  0.05929104457818197, 0.05930868875580193, 0.05932642839548702,
  0.0593442638309293, 0.0593621953984663, 0.059380223437001306,
  0.05939834828820251, 0.059416570296266596, 0.05943488980818063,
  0.05945330717362189, 0.05947182274496036, 0.05949043687741756,
  0.05950914992893329, 0.05952796226022092, 0.059546874234895554,
  0.0595658862193565, 0.05958499858294826, 0.05960421169782944,
  0.059623525939172084, 0.059642941684987835, 0.059662459316367066,
  0.05968207921731038, 0.05970180177488656, 0.05972162737918552,
  0.059741556423428564, 0.059761589303823845, 0.05978172641982191,
  0.05980196817394342, 0.05982231497191839, 0.059842767222676646,
  0.059863325338397735, 0.0598839897345006, 0.05990476082968243,
  0.05992563904601103, 0.05994662480883775, 0.05996771854695204,
  0.0599889206924714, 0.060010231681018725, 0.06003165195168785,
  0.06005318194695415, 0.06007482211298177, 0.06009657289936387,
  0.06011843475936624, 0.060140408149829475, 0.0601624935312951,
  0.060184691367916175, 0.060207002127615934, 0.06022942628211834,
  0.060251964306848836, 0.060274616681068455, 0.06029738388794945,
  0.06032026641454295, 0.060343264751814084, 0.0603663793946507,
  0.06038961084197704, 0.060412959596814, 0.06043642616616172,
  0.06046001106122737, 0.060483714797252994, 0.06050753789374648,
  0.06053148087447934, 0.06055554426738554, 0.060579728604798294,
  0.06060403442340973, 0.06062846226420453, 0.06065301267272871,
  0.060677686198821384, 0.06070248339711069, 0.060727404826522474,
  0.06075245105070058, 0.06077762263793505, 0.06080292016125309,
  0.060828344198294776, 0.06085389533166625, 0.06087957414861288,
  0.06090538124134826, 0.060931317207107705, 0.06095738264790088,
  0.060983578170928636, 0.06100990438838752, 0.06103636191758544,
  0.06106295138106659, 0.061089673406569886, 0.061116528627114274,
  0.06114351768101233, 0.06117064121204501, 0.06119789986929575,
  0.06122529430750863, 0.06125282518680334, 0.06128049317306485,
  0.06130829893775519, 0.06133624315803866, 0.06136432651690598,
  0.0613925497031459, 0.061420913411493576, 0.061449418342561964,
  0.061478065203055834, 0.06150685470577585, 0.061535787569546946,
  0.061564864519548124, 0.061594086287133656, 0.061623453610028245,
  0.061652967232370404, 0.06168262790475504, 0.0617124363843372,
  0.061742393434853, 0.06177249982680757, 0.061802756337256515,
  0.06183316375033715, 0.06186372285686447, 0.06189443445479502,
  0.061925299349000644, 0.061956318351521086, 0.06198749228161023,
  0.06201882196584685, 0.06205030823801389, 0.062081951939437455,
  0.062113753919011416, 0.06214571503310633, 0.062177836145863606,
  0.062210118129148465, 0.062242561862726316, 0.062275168234285576,
  0.062307938139461325, 0.0623408724821251, 0.06237397217435717,
  0.062407238136437254, 0.062440671297112914, 0.06247427259366576,
  0.0625080429718414, 0.06254198338615564, 0.0625760947999001,
  0.06261037818526756, 0.06264483452334677, 0.06267946480439648,
  0.06271427002789504, 0.0627492512025244, 0.06278440934638573,
  0.06281974548718666, 0.06285526066221242, 0.06289095591843186,
  0.06292683231277582, 0.06296289091201332, 0.06299913279305581,
  0.06303555904310122, 0.06307217075951699, 0.06310896905029359,
  0.06314595503387173, 0.0631831298393861, 0.06322049460689437,
  0.06325805048735982, 0.06329579864279233, 0.06333374024642151,
  0.06337187648294007, 0.06341020854847419, 0.06344873765079441,
  0.06348746500939827, 0.0635263918558061, 0.0635655194335576,
  0.06360484899844752, 0.06364438181842332, 0.06368411917450884,
  0.06372406235963904, 0.06376421268027828, 0.063804571455556,
  0.06384514001772763, 0.06388591971253849, 0.06392691189916926,
  0.06396811795053678, 0.06400953925318555, 0.06405117720782735,
  0.06409303322953425, 0.06413510874744996, 0.06417740520554428,
  0.06421992406227739, 0.06426266679131559, 0.0643056348813906,
  0.06434882983641668, 0.06439225317621233, 0.06443590643577007,
  0.06447979116651908, 0.06452390893596882, 0.06456826132782363,
  0.06461284994243066, 0.06465767639704502, 0.06470274232601218,
  0.0647480493806605, 0.06479359923014433, 0.06483939356103942,
  0.06488543407816452, 0.06493172250445141, 0.0649782605812646,
  0.0650250500687671, 0.0650720927459428, 0.06511939041120679,
  0.06516694488245034, 0.06521475799705113, 0.065262831612795,
  0.06531116760768764, 0.06535976788023039, 0.06540863434984921,
  0.06545776895735106, 0.06550717366485953, 0.06555685045631414,
  0.06560680133774037, 0.0656570283376292, 0.0657075335072066,
  0.06575831892084968, 0.0658093866762073, 0.06586073889472537,
  0.06591237772187342, 0.06596430532766084, 0.06601652390691544,
  0.0660690356793822, 0.06612184289064758, 0.066174947811829,
  0.0662283527407914, 0.06628206000170263, 0.06633607194590566,
  0.06639039095232262, 0.06644501942752543, 0.0664999598066947,
  0.06655521455372093, 0.06661078616129519, 0.06666667715215968,
  0.06672289007889486, 0.0667794275247941, 0.06683629210388979,
  0.06689348646195661, 0.06695101327653648, 0.067008875257812,
  0.06706707514890095, 0.06712561572621205, 0.06718449980039679,
  0.06724373021664243, 0.06730330985510528, 0.06736324163188813,
  0.06742352849884065, 0.06748417344507901, 0.06754517949678,
  0.06760654971846894, 0.06766828721303215, 0.06773039512267766,
  0.06779287662944396, 0.06785573495608845, 0.06791897336644911,
  0.06798259516618448, 0.06804660370361709, 0.06811100237047892,
  0.06817579460230284, 0.06824098387949852, 0.06830657372808256,
  0.06837256772003739, 0.06843896947470625, 0.06850578265908301,
  0.06857301098905963, 0.0686406582298179, 0.06870872819713343,
  0.06877722475781645, 0.06884615183096442, 0.06891551338868247,
  0.0689853134568723, 0.06905555611651193, 0.06912624550459714,
  0.0691973858147497, 0.06926898129859904, 0.06934103626664846,
  0.06941355508944382, 0.06948654219874285, 0.06956000208814096,
  0.06963393931470767, 0.0697083584999752, 0.06978326433110003,
  0.06985866156210267, 0.06993455501502713, 0.0700109495812948,
  0.07008785022303576, 0.07016526197422795, 0.07024318994209426,
  0.07032163930887161, 0.07040061533257472, 0.07048012334889295,
  0.07056016877256552, 0.07064075709893715, 0.07072189390564018,
  0.07080358485355366, 0.07088583568922371, 0.07096865224648805,
  0.071052040446984, 0.07113600630414924, 0.07122055592248036,
  0.07130569550124372, 0.07139143133571327, 0.07147776981861285,
  0.07156471744317455, 0.0716522808041679, 0.07174046660033274,
  0.07182928163681052, 0.07191873282704178, 0.07200882719507291,
  0.07209957187739956, 0.07219097412615842, 0.07228304131117161,
  0.07237578092193502, 0.07246920057129719, 0.07256330799676602,
  0.07265811106393154, 0.0727536177695563, 0.07284983624329901,
  0.07294677475176947, 0.07304444170072161, 0.07314284563834851,
  0.07324199525886514, 0.07334189940496766, 0.07344256707123759,
  0.0735440074083847, 0.07364622972617024, 0.07374924349648006,
  0.07385305835826679, 0.07395768412014925, 0.07406313076494245,
  0.07416940845387826, 0.07427652752991684, 0.07438449852287148,
  0.07449333215311961, 0.07460303933733504, 0.0747136311907832,
  0.0748251190343337, 0.07493751439885658, 0.07505082902932042,
  0.07516507489144102, 0.0752802641753062, 0.07539640930265773,
  0.07551352293159026, 0.07563161796244051, 0.07575070754432163,
  0.0758708050812111, 0.07599192423777111, 0.07611407894706386,
  0.07623728341598315, 0.07636155213404133, 0.07648689987927863,
  0.07661334172595152, 0.07674089305329578, 0.07686956955249888,
  0.07699938723490778, 0.07713036244135019, 0.07726251185059116,
  0.07739585248829535, 0.07753040173650198, 0.07766617734369033,
  0.07780319743408812, 0.07794148051872928, 0.07808104550660151,
  0.07822191171459207, 0.07836409887963512, 0.07850762717143787,
  0.07865251720308553, 0.0787987900452287, 0.07894646723863978,
  0.07909557080823244, 0.07924612327722888, 0.0793981476820025,
  0.07955166758663282, 0.07970670709946451, 0.07986329088955597,
  0.08002144420274408, 0.08018119288080275, 0.0803425633782808,
  0.08050558278248804, 0.08067027883263767, 0.08083667994158816,
  0.08100481521504703, 0.08117471447535055, 0.08134640828427941,
  0.08151992796687017, 0.08169530563589425, 0.08187257421821456,
  0.08205176748191588, 0.08223292006432227, 0.08241606750003366,
  0.08260124625359619, 0.08278849374988154, 0.08297784840687716,
  0.08316934967084066, 0.0833630380522295, 0.0835589551638577,
  0.08375714375842327, 0.08395764777044173, 0.08416051235934185,
  0.08436578395404308, 0.08457351029882272, 0.08478374050284093,
  0.08499652509076279, 0.08521191605655698, 0.08542996691980542,
  0.08565073278304056, 0.0858742703939818, 0.08610063821088505,
  0.0863298964665416, 0.0865621072430484, 0.08679733454365546,
  0.08703564437176525, 0.08727710481219045, 0.08752178611655628,
  0.08776976079520621, 0.0880211037119185, 0.08827589218342669,
  0.08853420608482916, 0.08879612796147152, 0.0890617431445232,
  0.08933113987558143, 0.08960440943728767, 0.08988164628908217,
  0.09016294821199165, 0.09044841646512801, 0.09073815594429689,
  0.09103227535664357, 0.09133088739787532, 0.0916341089505213,
  0.09194206128273988, 0.09225487026677055, 0.09257266660975222,
  0.09289558609346668, 0.09322376983864708, 0.09355736457561047,
  0.09389652294166041, 0.09424140378977827, 0.09459217252378982,
  0.09494900145370064, 0.09531207017224008, 0.09568156596319645,
  0.09605768423134357, 0.09644062896864734, 0.09683061324818976,
  0.09722785975803222, 0.09763260137195404, 0.09804508176173332,
  0.09846555605786883, 0.09889429155943263, 0.09933156849706454,
  0.09977768085909958, 0.10023293728066235, 0.10069766200541516,
  0.10117219592764994, 0.10165689772007491, 0.10215214505534585,
  0.10265833593625949, 0.10317589013836426, 0.10370525078497772,
  0.10424688605833059, 0.10480129107816961, 0.10536898994389694,
  0.10595053797854054, 0.10654652419097209, 0.10715757397680346,
  0.10778435209350773, 0.10842756593906401, 0.10908796917674628,
  0.10976636574119807, 0.11046361428324351, 0.11118063311032408,
  0.11191840567768785, 0.11267798673375132, 0.1134605091688146,
  0.11426719171846339, 0.11509934759939439, 0.1159583942551442,
  0.11684586436446308, 0.11776341831361917, 0.11871285836709539,
  0.11969614484349853, 0.12071541459598996, 0.12177300224310428,
  0.12287146462499367, 0.12401360908268529, 0.12520252631296663,
  0.12644162868537906, 0.12773469512487529, 0.12908592398252508,
  0.13049999558554157, 0.13198214669807298, 0.13353825963655888,
  0.1351749696262274, 0.13689979502138885, 0.13872129634891353,
  0.1406492721626895, 0.14269500220754397, 0.14487155217180486,
  0.14719415938604596, 0.14968072645243646, 0.1523524605408998,
  0.15523471242947257, 0.1583580940186295, 0.16175999128288557,
  0.16548665072122593, 0.16959611701205476, 0.17416246859778775,
  0.17928209342441523, 0.18508328778673924, 0.1917414980133161,
  0.19950463254617876, 0.2087374637630829, 0.22000503548177544,
  0.23424380680372367, 0.25315713324910166, 0.2802986015980284,
  0.3249567967276586, 0.42569184393634385
  };

// ********************************************************
//   field x globals
// vector pos_space_terms globals
size_t _x_pos_space_terms_alloc_size = 0;
complex* _x_pos_space_terms = NULL;
complex* _active_x_pos_space_terms = NULL;

ptrdiff_t _x_pos_space_terms_basis = -1;

// vector wavefunction globals
size_t _x_wavefunction_alloc_size = 0;
complex* _x_wavefunction = NULL;
complex* _active_x_wavefunction = NULL;

ptrdiff_t _x_wavefunction_basis = -1;

// vector driving_noise globals
size_t _x_driving_noise_alloc_size = 0;
complex* _x_driving_noise = NULL;
complex* _active_x_driving_noise = NULL;

ptrdiff_t _x_driving_noise_basis = -1;

uint32_t _gen_driving_noise_seeds[10];
dsfmt_t* _gen_driving_noise;

// ********************************************************
//   Stochastic globals
real* _dkx_array_invsqrt = (real*) xmds_malloc(sizeof(real) * (_lattice_kx));

// ********************************************************
//   segment 1 (SI fixed-step integrator) globals
complex* _segment1_oldCopy_x_wavefunction;

// vector segment1_x_operators_operator0_field globals
size_t _x_segment1_x_operators_operator0_field_alloc_size = 0;
complex* _x_segment1_x_operators_operator0_field = NULL;
complex* _active_x_segment1_x_operators_operator0_field = NULL;

// ********************************************************
//   segment 2 (Breakpoint) globals
long _breakpointAutoNameCounter = 0;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;

// ********************************************************
//   field mg1_output globals
real* _mg1_output_t = NULL;
unsigned long _mg1_output_index_t = 0;

// vector raw globals
size_t _mg1_output_raw_alloc_size = 0;
real* _mg1_output_raw = NULL;
real* _active_mg1_output_raw = NULL;

// ********************************************************
//   field mg2_output globals
real* _mg2_output_t = NULL;
unsigned long _mg2_output_index_t = 0;

// vector raw globals
size_t _mg2_output_raw_alloc_size = 0;
real* _mg2_output_raw = NULL;
real* _active_mg2_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Transform Multiplexer function prototypes
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field x function prototypes
void _x_pos_space_terms_initialise();
void _x_pos_space_terms_basis_transform(ptrdiff_t new_basis);
void _x_pos_space_terms_evaluate();

void _x_wavefunction_initialise();
void _x_wavefunction_basis_transform(ptrdiff_t new_basis);

void _x_driving_noise_basis_transform(ptrdiff_t new_basis);
void _x_driving_noise_evaluate(real _step);
void _x_driving_noise_split(real _new_step, real _old_step, complex* _old_array);

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (SI fixed-step integrator) function prototypes
void _segment1();
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_ip_evolve(int _exponent);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);

void _segment1_x_operators_calculate_operator0_field();

void _segment1_x_operators_evaluate_operator1(real _step);

// ********************************************************
//   segment 2 (Breakpoint) function prototypes
void _segment2();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   output function prototypes
void _write_output();

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
//   moment group 1 function prototypes
void _mg1_sample();
void _mg1_process();
void _mg1_write_out(FILE* _outfile);

// ********************************************************
//   field mg1_output function prototypes
void _mg1_output_raw_initialise();

// ********************************************************
//   moment group 2 function prototypes
void _mg2_sample();
void _mg2_process();
void _mg2_write_out(FILE* _outfile);

// ********************************************************
//   field mg2_output function prototypes
void _mg2_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'th_spgpe_gs' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"chi", required_argument, 0, 'c'},
        {"omega_bar", required_argument, 0, 'o'},
        {"k0", required_argument, 0, 'k'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hc:o:k:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'c':
        chi = strtod(optarg, NULL);
        break;
      
      case 'o':
        omega_bar = strtod(optarg, NULL);
        break;
      
      case 'k':
        k0 = strtod(optarg, NULL);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  #line 29 "th_spgpe_gs.xmds"
  
  R_tilde = sqrt(2.0)*1/(pow(chi,1.0/3.0)*omega_bar);
  rho0_tilde = pow(chi,-2.0/3.0);                 
  kth = 0.12;     
  t_lim = log(4.0)/(omega_bar*1.1);
  sgT = sqrt(2.0*kth);                    
  mu=rho0_tilde;
  
  #line 1652 "th_spgpe_gs.cc"
  // **********************************************
  
    
  
  _x_pos_space_terms_alloc_size = MAX(_x_pos_space_terms_alloc_size, (_lattice_x_4f) * _x_pos_space_terms_ncomponents);
  _x_pos_space_terms_alloc_size = MAX(_x_pos_space_terms_alloc_size, (_lattice_x) * _x_pos_space_terms_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents);
  _mg2_output_raw_alloc_size = MAX(_mg2_output_raw_alloc_size, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_raw_ncomponents);
  _mg1_output_raw_alloc_size = MAX(_mg1_output_raw_alloc_size, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_raw_ncomponents);
  _x_segment1_x_operators_operator0_field_alloc_size = MAX(_x_segment1_x_operators_operator0_field_alloc_size, (_lattice_nx) * _x_segment1_x_operators_operator0_field_ncomponents);
  _x_driving_noise_alloc_size = MAX(_x_driving_noise_alloc_size, (_lattice_x) * _x_driving_noise_ncomponents);
  _x_driving_noise_alloc_size = MAX(_x_driving_noise_alloc_size, (_lattice_kx) * _x_driving_noise_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_x_4f) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_x) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_nx) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_kx) * _x_wavefunction_ncomponents);
  _x = (real*) xmds_malloc(sizeof(real) * (_lattice_x+1));
  
  _nx = (long*) xmds_malloc(sizeof(long) * (_lattice_nx+1));
  
  _kx = (real*) xmds_malloc(sizeof(real) * (_lattice_kx+1));
  
  _nx_twiddle = (long*) xmds_malloc(sizeof(long) * (_lattice_nx_twiddle+1));
  
  _x_4f = (real*) xmds_malloc(sizeof(real) * (_lattice_x_4f+1));
  
  _x_pos_space_terms = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_pos_space_terms_alloc_size,1));
  _active_x_pos_space_terms = _x_pos_space_terms;
  
  
  _x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _active_x_wavefunction = _x_wavefunction;
  
  
  _x_driving_noise = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_driving_noise_alloc_size,1));
  _active_x_driving_noise = _x_driving_noise;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  _mg1_output_t = (real*) xmds_malloc(sizeof(real) * (_mg1_output_lattice_t+1));
  
  
  _mg1_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg1_output_raw_alloc_size,1));
  _active_mg1_output_raw = _mg1_output_raw;
  _mg2_output_t = (real*) xmds_malloc(sizeof(real) * (_mg2_output_lattice_t+1));
  
  
  _mg2_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg2_output_raw_alloc_size,1));
  _active_mg2_output_raw = _mg2_output_raw;
  
  
  // Run-time validation checks
  
  if (0 >= sqrt(1/(omega_bar)))
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'sqrt(1/(omega_bar))' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)0, (real)sqrt(1/(omega_bar)));
  
  if (t_lim <= 0.0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The interval for segment 1 is not positive!\n"
                           "Interval = %e\n", t_lim);
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    _x[_index_x] = _hermite_zeros_x[_index_x] * sqrt(1/(omega_bar)) / sqrt(1.0);
    _dx_array[_index_x] = _hermite_gauss_weights_x[_index_x] * sqrt(1/(omega_bar)) / sqrt(1.0);
  }
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++)
    _nx[_index_nx] = _min_nx + _index_nx*_dnx;
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    _kx[_index_kx] = _hermite_zeros_x[_index_kx] * (1.0 / (sqrt(1/(omega_bar)))) / sqrt(1.0);
    _dkx_array[_index_kx] = _hermite_gauss_weights_x[_index_kx] * (1.0 / (sqrt(1/(omega_bar)))) / sqrt(1.0);
  }
  for (long _index_nx_twiddle = 0; _index_nx_twiddle < _lattice_nx_twiddle; _index_nx_twiddle++)
    _nx_twiddle[_index_nx_twiddle] = _min_nx_twiddle + _index_nx_twiddle*_dnx_twiddle;
  for (long _index_x_4f = 0; _index_x_4f < _lattice_x_4f; _index_x_4f++) {
    _x_4f[_index_x_4f] = _hermite_zeros_x[_index_x_4f] * sqrt(1/(omega_bar)) / sqrt(2.0);
    _dx_4f_array[_index_x_4f] = _hermite_gauss_weights_x[_index_x_4f] * sqrt(1/(omega_bar)) / sqrt(2.0);
  }
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  _active_mg1_output_raw = _mg1_output_raw;
  _mg1_output_raw_initialise();
  _active_mg2_output_raw = _mg2_output_raw;
  _mg2_output_raw_initialise();
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    _dkx_array_invsqrt[_index_kx] = (real)1.0/sqrt(_dkx_array[_index_kx] * (1.0));
  }
  
  #if HAVE_DEV_URANDOM
    uint32_t __seeds[10];
    FILE *__urandom_fp = fopen("/dev/urandom", "r");
  
    if (__urandom_fp == NULL) {
        _LOG(_ERROR_LOG_LEVEL, "Unable to seed random number generator from /dev/urandom.  Is it accessible?\n");
        // Implicit quit
    }
  
    size_t __entries_read = 0;
    __entries_read = fread(__seeds, sizeof(uint32_t), 10, __urandom_fp);
  
    if (__entries_read != 10) {
      _LOG(_ERROR_LOG_LEVEL, "Unable to read from /dev/urandom while seeding the random number generator.\n");
        // Implicit quit
    }
  
    fclose(__urandom_fp);
  
    for (unsigned long _i0=0; _i0 < 10; _i0++) {
      _gen_driving_noise_seeds[_i0] = (uint32_t) __seeds[_i0];
    }
  
  #else
  #error Do not have a run-time random number source! Please supply seeds manually.
  #endif
  
  // load wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX // Don't load wisdom on windows
  {
    char _hostName[256];
    gethostname(_hostName, 256);
    _hostName[255] = '\0'; // just in case
    
    string _pathToWisdom = getenv("HOME");
    _pathToWisdom += "/.xmds/wisdom/";
    
    string _wisdomFileName = _hostName;
    _wisdomFileName += ".wisdom";
    _wisdomFileName += ".fftw3";
    
    FILE *_fp = NULL;
    
    _fp = fopen(_pathToWisdom.c_str(), "r");
    if (_fp) {
      fclose(_fp);
    } else {
      int _result = mkdir((string(getenv("HOME")) + "/.xmds").c_str(), S_IRWXU);
      if (mkdir(_pathToWisdom.c_str(), S_IRWXU)) {
        // We failed to create the ~/.xmds/wisdom directory
        _LOG(_WARNING_LOG_LEVEL, "Warning: Cannot find enlightenment, the path to wisdom ~/.xmds/wisdom doesn't seem to exist and we couldn't create it.\n"
                                 "         I'll use the current path instead.\n");
        _pathToWisdom = ""; // present directory
      }
      
    }
    
    _fftwWisdomPath = _pathToWisdom + _wisdomFileName;
    
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "r")) != NULL) {
      _LOG(_SIMULATION_LOG_LEVEL, "Found enlightenment... (Importing wisdom)\n");
      fftw_import_wisdom_from_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (2 * _x_pos_space_terms_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_pos_space_terms_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_pos_space_terms);
  }
  _basis_transform = &_x_pos_space_terms_basis_map[_basis_pair(3, 2)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_pos_space_terms_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_pos_space_terms_ncomponents * 2
  );
  
  _basis_transform = &_x_pos_space_terms_basis_map[_basis_pair(2, 3)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_pos_space_terms_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_pos_space_terms_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_pos_space_terms_alloc_size); // vector 'pos_space_terms' needs an out-of-place transform
  
  if (2 * _x_wavefunction_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_wavefunction_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_wavefunction);
  }
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 0)];
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 1)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 0)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 2)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 0)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 3)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 1)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 2)];
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 1)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 3)];
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 2)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 3)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_wavefunction_alloc_size); // vector 'wavefunction' needs an out-of-place transform
  
  if (2 * _x_driving_noise_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_driving_noise_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_driving_noise);
  }
  _basis_transform = &_x_driving_noise_basis_map[_basis_pair(2, 0)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents * 2
  );
  
  _basis_transform = &_x_driving_noise_basis_map[_basis_pair(0, 2)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_driving_noise_alloc_size); // vector 'driving_noise' needs an out-of-place transform
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Save wisdom
  #if CFG_OSAPI == CFG_OSAPI_POSIX
  {
    FILE *_wisdomFile = NULL;
    if ( (_wisdomFile = fopen(_fftwWisdomPath.c_str(), "w")) != NULL) {
      fftw_export_wisdom_to_file(_wisdomFile);
      fclose(_wisdomFile);
    }
  }
  #endif // POSIX
  
  fftw_cleanup();
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_x_pos_space_terms);
  _active_x_pos_space_terms = _x_pos_space_terms = NULL;
  
  
  xmds_free(_x_wavefunction);
  _active_x_wavefunction = _x_wavefunction = NULL;
  
  
  xmds_free(_x_driving_noise);
  _active_x_driving_noise = _x_driving_noise = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  xmds_free(_mg1_output_raw);
  _active_mg1_output_raw = _mg1_output_raw = NULL;
  
  xmds_free(_mg2_output_raw);
  _active_mg2_output_raw = _mg2_output_raw = NULL;
  
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Transform Multiplexer function implementations
// x_4f <---> nx transform
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for x_4f <---> nx transform...");
    
    long _even_x_4f = (_lattice_x_4f + 1)/2;
    long _odd_x_4f = _lattice_x_4f/2;
    long _even_nx = (_lattice_nx + 1)/2;
    long _odd_nx = _lattice_nx/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_x_4f * _even_nx);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_x_4f * _odd_nx);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx * _even_x_4f);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx * _odd_x_4f);
    
    for (long _i0 = 0; _i0 < _even_x_4f; _i0++) {
      long __i0 = _lattice_x_4f - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(2.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx);
      const real expFactor2 = exp(-_root * _root / _lattice_nx);
      const real normalisation = 1.0/sqrt(sqrt(1/(omega_bar)));
      for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx - _i1 - 1) / _lattice_nx) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_x_4f) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_x_4f + (_odd_x_4f -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dx_4f_array[__i0];
            _mmt_matrix_backward_odd[(_odd_x_4f -1 - _i0) * _odd_nx + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_x_4f + _i0] = \
            hermiteGauss * correctionFactor * _dx_4f_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x_4f;
      for (long _i1 = 0; _i1 < _lattice_x_4f/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_x_4f - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_x_4f+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_x_4f+1)/2,
                  /* B */ source_data + _i0 * _lattice_x_4f * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_x_4f/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_x_4f/2,
                  /* B */ source_data + (_i0 * _lattice_x_4f + (_lattice_x_4f+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_x_4f+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_x_4f * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_x_4f/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx/2,
                  /* B */ source_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_x_4f + (_lattice_x_4f+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x_4f;
      for (long _i1 = 0; _i1 < _lattice_x_4f/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_x_4f - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// x <---> nx transform
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for x <---> nx transform...");
    
    long _even_x = (_lattice_x + 1)/2;
    long _odd_x = _lattice_x/2;
    long _even_nx = (_lattice_nx + 1)/2;
    long _odd_nx = _lattice_nx/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_x * _even_nx);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_x * _odd_nx);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx * _even_x);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx * _odd_x);
    
    for (long _i0 = 0; _i0 < _even_x; _i0++) {
      long __i0 = _lattice_x - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(1.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx);
      const real expFactor2 = exp(-_root * _root / _lattice_nx);
      const real normalisation = 1.0/sqrt(sqrt(1/(omega_bar)));
      for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx - _i1 - 1) / _lattice_nx) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_x) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_x + (_odd_x -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dx_array[__i0];
            _mmt_matrix_backward_odd[(_odd_x -1 - _i0) * _odd_nx + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_x + _i0] = \
            hermiteGauss * correctionFactor * _dx_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x;
      for (long _i1 = 0; _i1 < _lattice_x/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_x - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_x+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_x+1)/2,
                  /* B */ source_data + _i0 * _lattice_x * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_x/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_x/2,
                  /* B */ source_data + (_i0 * _lattice_x + (_lattice_x+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_x+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_x * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_x/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx/2,
                  /* B */ source_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_x + (_lattice_x+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x;
      for (long _i1 = 0; _i1 < _lattice_x/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_x - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// nx <---> nx_twiddle transform
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static const complex _forward_multipliers[4] = {1, -i, -1, i};
  static const complex _backward_multipliers[4] = {1, i, -1, -i};
  complex* const __restrict__ source_data = reinterpret_cast<complex* const>(_data_in);
  complex* const __restrict__ dest_data = reinterpret_cast<complex* const>(_data_out);
  
  const complex* const __restrict__ _multipliers = _forward ? _forward_multipliers : _backward_multipliers;
  
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
      long multiplier_index = (_i1 & 3);
      
      const complex multiplier = _multipliers[multiplier_index];
      
      #pragma ivdep
      for (long _i2 = 0; _i2 < _postfix_lattice; _i2++) {
        ptrdiff_t _index = (_i0 * _lattice_nx + _i1) * _postfix_lattice + _i2;
        dest_data[_index] = multiplier * source_data[_index];
      }
    }
  }
}


// kx <---> nx_twiddle transform
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for kx <---> nx_twiddle transform...");
    
    long _even_kx = (_lattice_kx + 1)/2;
    long _odd_kx = _lattice_kx/2;
    long _even_nx_twiddle = (_lattice_nx_twiddle + 1)/2;
    long _odd_nx_twiddle = _lattice_nx_twiddle/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_kx * _even_nx_twiddle);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_kx * _odd_nx_twiddle);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx_twiddle * _even_kx);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx_twiddle * _odd_kx);
    
    for (long _i0 = 0; _i0 < _even_kx; _i0++) {
      long __i0 = _lattice_kx - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(1.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx_twiddle);
      const real expFactor2 = exp(-_root * _root / _lattice_nx_twiddle);
      const real normalisation = 1.0/sqrt((1.0 / (sqrt(1/(omega_bar)))));
      for (long _i1 = 0; _i1 < _lattice_nx_twiddle; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx_twiddle - _i1 - 1) / _lattice_nx_twiddle) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_kx) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_kx + (_odd_kx -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dkx_array[__i0];
            _mmt_matrix_backward_odd[(_odd_kx -1 - _i0) * _odd_nx_twiddle + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_kx + _i0] = \
            hermiteGauss * correctionFactor * _dkx_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx_twiddle + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_kx;
      for (long _i1 = 0; _i1 < _lattice_kx/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_kx - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx_twiddle+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_kx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_kx+1)/2,
                  /* B */ source_data + _i0 * _lattice_kx * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx_twiddle * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx_twiddle/2,
                  /* nelem */ innerLoopSize,
                  _lattice_kx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_kx/2,
                  /* B */ source_data + (_i0 * _lattice_kx + (_lattice_kx+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx_twiddle + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_kx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx_twiddle+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx_twiddle+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx_twiddle * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_kx * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_kx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx_twiddle/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx_twiddle/2,
                  /* B */ source_data + (_i0 * _lattice_nx_twiddle + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_kx + (_lattice_kx+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_kx;
      for (long _i1 = 0; _i1 < _lattice_kx/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_kx - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// nx <---> nx_twiddle transform
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static const complex _forward_multipliers[4] = {1, -i, -1, i};
  static const complex _backward_multipliers[4] = {1, i, -1, -i};
  complex* const __restrict__ source_data = reinterpret_cast<complex* const>(_data_in);
  
  const complex* const __restrict__ _multipliers = _forward ? _forward_multipliers : _backward_multipliers;
  
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
      long multiplier_index = (_i1 & 3);
      if (multiplier_index == 0) continue;
      
      const complex multiplier = _multipliers[multiplier_index];
      
      #pragma ivdep
      for (long _i2 = 0; _i2 < _postfix_lattice; _i2++) {
        ptrdiff_t _index = (_i0 * _lattice_nx + _i1) * _postfix_lattice + _i2;
        source_data[_index] *= multiplier;
      }
    }
  }
}


// Out-of-place copy
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  memcpy(_data_out, _data_in, _prefix_lattice * _postfix_lattice * sizeof(real));
}

// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: th_spgpe_gs --chi <real> --omega_bar <real> --k0 <real>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-c,  --chi\treal \t\t0.0786\n"
                         "-o,  --omega_bar\treal \t\t0.0057\n"
                         "-k,  --k0\treal \t\t7.0\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   Default Simulation Driver function implementations
void _segment0()
{
  
  
  uint32_t _gen_driving_noise_local_seeds[10] = {
  _gen_driving_noise_seeds[0]+(0)*1,
  _gen_driving_noise_seeds[1]+(0)*2,
  _gen_driving_noise_seeds[2]+(0)*3,
  _gen_driving_noise_seeds[3]+(0)*4,
  _gen_driving_noise_seeds[4]+(0)*5,
  _gen_driving_noise_seeds[5]+(0)*6,
  _gen_driving_noise_seeds[6]+(0)*7,
  _gen_driving_noise_seeds[7]+(0)*8,
  _gen_driving_noise_seeds[8]+(0)*9,
  _gen_driving_noise_seeds[9]+(0)*10
  };
  
  
  _gen_driving_noise = (dsfmt_t *)xmds_malloc(sizeof(dsfmt_t));
  dsfmt_init_by_array(_gen_driving_noise, _gen_driving_noise_local_seeds, 10);
  
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _mg1_output_raw_initialise();
  _mg2_output_raw_initialise();
  _active_x_wavefunction = _x_wavefunction;
  _x_wavefunction_initialise();
  _mg0_output_index_t = 0;
  _mg1_output_index_t = 0;
  _mg2_output_index_t = 0;
  _mg0_sample();
  _mg1_sample();
  _mg2_sample();
  _segment1();
  _segment2();
  
  _mg0_process();
  _mg1_process();
  _mg2_process();
}


// ********************************************************
//   field x function implementations
// initialisation for computed vector pos_space_terms
void _x_pos_space_terms_initialise()
{
  
  _x_pos_space_terms_basis = 3;
}


void _x_pos_space_terms_basis_transform(ptrdiff_t new_basis)
{
  if (_x_pos_space_terms_basis == new_basis)
    return;
  
  if (_x_pos_space_terms_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_pos_space_terms' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_pos_space_terms_basis_map.count(_basis_pair(_x_pos_space_terms_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_pos_space_terms' from basis %s to basis %s.\n",
      _basis_identifiers[_x_pos_space_terms_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_pos_space_terms_basis_map[_basis_pair(_x_pos_space_terms_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_pos_space_terms' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_pos_space_terms_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_pos_space_terms);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_pos_space_terms_basis = new_basis;
}


void _x_pos_space_terms_evaluate()
{
  // Transforming vectors to basis (x_4f)
  _x_wavefunction_basis_transform(3); // (x_4f)
  
  long _x_pos_space_terms_index_pointer = 0;
  #define U _active_x_pos_space_terms[_x_pos_space_terms_index_pointer + 0]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x_4f _x_4f[_index_x_4f + 0]
  #define dx_4f (_dx_4f_array[_index_x_4f + 0] * (1.0))
  
  for (long _index_x_4f = 0; _index_x_4f < _lattice_x_4f; _index_x_4f++) {
    // ************* Evaluation code ****************
    #line 68 "th_spgpe_gs.xmds"
    
    // Compute nonlinear term
    U = mod2(psi) * psi;
    
    #line 2904 "th_spgpe_gs.cc"
    // **********************************************
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_pos_space_terms_index_pointer += 1 * _x_pos_space_terms_ncomponents;
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x_4f
  #undef dx_4f
  #undef U
  #undef psi
  
  _x_pos_space_terms_basis = 3;
}

// initialisation for vector wavefunction
void _x_wavefunction_initialise()
{
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in the initialisation
    // block of a <vector> element. If they're trying to do this, what they really want is a 
    // <computed_vector> instead.
    #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
    
    // ********** Initialisation code ***************
    #line 50 "th_spgpe_gs.xmds"
    
            //psi = sqrt(rho0_tilde)* exp(-x*x/2.0/R_tilde/R_tilde);
    if (fabs(x) < R_tilde) {
                    psi = sqrt(rho0_tilde*(1-pow(x/R_tilde,2.0)));
            } else {
                    psi = 0.0;
            }
    
    #line 2945 "th_spgpe_gs.cc"
    // **********************************************
    #undef t
    
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
  
  _x_wavefunction_basis = 2;
}


void _x_wavefunction_basis_transform(ptrdiff_t new_basis)
{
  if (_x_wavefunction_basis == new_basis)
    return;
  
  if (_x_wavefunction_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_wavefunction' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_wavefunction_basis_map.count(_basis_pair(_x_wavefunction_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_wavefunction' from basis %s to basis %s.\n",
      _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_wavefunction_basis_map[_basis_pair(_x_wavefunction_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_wavefunction' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_wavefunction);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_wavefunction_basis = new_basis;
}

void _x_driving_noise_basis_transform(ptrdiff_t new_basis)
{
  if (_x_driving_noise_basis == new_basis)
    return;
  
  if (_x_driving_noise_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_driving_noise' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_driving_noise_basis_map.count(_basis_pair(_x_driving_noise_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_driving_noise' from basis %s to basis %s.\n",
      _basis_identifiers[_x_driving_noise_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_driving_noise_basis_map[_basis_pair(_x_driving_noise_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_driving_noise' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_driving_noise_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_driving_noise);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_driving_noise_basis = new_basis;
}


void _x_driving_noise_evaluate(real _step)
{
  const ptrdiff_t _vector_size = 2 * (_lattice_kx) * _x_driving_noise_ncomponents;
  const real _var = 0.5 / (1.0* _step);
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
      _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_x_driving_noise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_x_driving_noise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_x_driving_noise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
        _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_x_driving_noise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
  long _x_driving_noise_index_pointer = 0;
  #define dW _active_x_driving_noise[_x_driving_noise_index_pointer + 0]
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx_array[_index_kx + 0] * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    dW *= _dkx_array_invsqrt[_index_kx + 0];
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_driving_noise_index_pointer += 1 * _x_driving_noise_ncomponents;
    
  }
  #undef kx
  #undef dkx
  #undef dW
  _x_driving_noise_basis = 0;
}


void _x_driving_noise_split(real _new_step, real _old_step, complex* _old_array)
{
  const ptrdiff_t _vector_size = 2 * (_lattice_kx) * _x_driving_noise_ncomponents;
  // Split a gaussian noise
  _x_driving_noise_evaluate((_new_step * _old_step)/(_old_step - _new_step));
  
  // Now complete creation of the new noise.
  
  {
    _MAKE_AUTOVEC_VARIABLE(_old_array);
    _MAKE_AUTOVEC_VARIABLE(_active_x_driving_noise);
    #pragma ivdep
    for (long _i0 = 0; _i0 < 2 * (_lattice_kx) * _x_driving_noise_ncomponents; _i0++) {
      _AUTOVEC(_active_x_driving_noise)[_i0] += _AUTOVEC(_old_array)[_i0];
    }
  
  }
  
  _x_driving_noise_basis = 0;
}

// ********************************************************
//   segment 1 (SI fixed-step integrator) function implementations
void _segment1()
{
  real _step = t_lim/(real)5000;
  real _noiseStep = t_lim/(real)5000;
  
  
  _x_segment1_x_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_segment1_x_operators_operator0_field_alloc_size,1));
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field;
  _segment1_oldCopy_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment1_x_operators_calculate_operator0_field();
  complex* _oldCopy_x_wavefunction = _segment1_oldCopy_x_wavefunction;
  
  
  for (long _istep = 0; _istep < 5000; _istep++) {
    
    _active_x_driving_noise = _x_driving_noise;
    _x_driving_noise_evaluate(_noiseStep);
    
    _segment1_calculate_nonconstant_ip_fields(_step, 1);
    
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    _x_wavefunction_basis_transform(2); // (x)
    
    memcpy(_oldCopy_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
    
    _active_x_wavefunction = _x_wavefunction;
    
    
    for (int _iteration = 0; _iteration < 3; _iteration++) {
      if (_iteration < 3 - 1) {
        _segment1_calculate_delta_a(0.5*_step);  } else {
        _segment1_calculate_delta_a(_step);  }
      
      _x_wavefunction_basis_transform(2); // (x)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_oldCopy_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // a = oldCopy + a
          _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_oldCopy_x_wavefunction)[_i0];
        }
      
      }
    }
    
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    
    if ((_istep % 500) == 499.0)
      _mg0_sample();
    if ((_istep % 500) == 499.0)
      _mg1_sample();
    if ((_istep % 500) == 499.0)
      _mg2_sample();
  }
  
  _SEGMENT1_END:;
  
  xmds_free(_x_segment1_x_operators_operator0_field);
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field = NULL;
  xmds_free(_segment1_oldCopy_x_wavefunction);
  
}


inline void _segment1_calculate_delta_a(real _step)
{
  _x_pos_space_terms_evaluate();
  
  
  // Delta A propagation operator for field x
  _segment1_x_operators_evaluate_operator1(_step);
  
}


inline void _segment1_ip_evolve(int _exponent)
{
  
  _x_wavefunction_basis_transform(1); // (nx)
  
  if (_exponent > 0) {
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi *= /* L_st[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  } else {
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi /= /* L_st[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}

// ConstantIPOperator
void _segment1_x_operators_calculate_operator0_field()
{
  real _step = t_lim/(real)5000;
  real _noiseStep = t_lim/(real)5000;
  
  long _x_segment1_x_operators_operator0_field_index_pointer = 0;
  #define nx _nx[_index_nx + 0]
  #define dnx (_dnx * (1.0))
  
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++) {
    complex L_st;
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in a constant IP operator/
    // The user probably shouldn't be doing this, but if they must, they should use a non-constant EX
    // operator instead
    #define t Dont_use_propagation_dimension_t_in_constant_IP_operator___Use_non_constant_EX_operator_instead
    // ************** Operator code *****************
    #line 86 "th_spgpe_gs.xmds"
    
    L_st = - (nx + 0.5)*omega_bar*(i+kth);
    
    #line 3270 "th_spgpe_gs.cc"
    // **********************************************
    #undef t
        
    _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0] = exp(L_st * 0.5 * _step);
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_segment1_x_operators_operator0_field_index_pointer += 1 * _x_segment1_x_operators_operator0_field_ncomponents;
    
  }
  #undef nx
  #undef dnx
}

// Delta A propagation operator for field x
void _segment1_x_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (x)
  _x_driving_noise_basis_transform(2); // (x)
  _x_wavefunction_basis_transform(2); // (x)
  _x_pos_space_terms_basis_transform(2); // (x)
  
  long _x_driving_noise_index_pointer = 0;
  #define dW _active_x_driving_noise[_x_driving_noise_index_pointer + 0]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _x_pos_space_terms_index_pointer = 0;
  #define U _active_x_pos_space_terms[_x_pos_space_terms_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    complex dpsi_dt;
    
    #define dt _step
    
    // ************* Propagation code ***************
    #line 92 "th_spgpe_gs.xmds"
    
    dpsi_dt = 0.0-(i+kth)*U + kth*mu*psi +sgT *dW;
    
    #line 3310 "th_spgpe_gs.cc"
    // **********************************************
    
    #undef dt
    
    
    _active_x_wavefunction[_x_wavefunction_index_pointer + 0] = dpsi_dt * _step;
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_pos_space_terms_index_pointer += 1 * _x_pos_space_terms_ncomponents;
    _x_driving_noise_index_pointer += 1 * _x_driving_noise_ncomponents;
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef dW
  #undef psi
  #undef U
}

// ********************************************************
//   segment 2 (Breakpoint) function implementations
void _segment2()
{
  
  _x_wavefunction_basis_transform(2); // (x)
  
  
  char *_baseFilename = (char*)malloc(255);
  snprintf(_baseFilename, 255, "%s%s", "psi_gs", gsArgsAndValues.c_str());
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", _baseFilename);
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", _baseFilename);
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"breakpoint\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>3</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "x psiR psiI \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>3</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", _baseFilename);
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", _baseFilename);
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _lattice_x;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_x;
  if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
    dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_x = H5Dopen(hdf5_file, "/1/x");
  H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_x, "x");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_lattice_x};
  hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
  
  hid_t dataset_psiR;
  if (!H5Lexists(hdf5_file, "/1/psiR", H5P_DEFAULT))
    dataset_psiR = H5Dcreate(hdf5_file, "/1/psiR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_psiR = H5Dopen(hdf5_file, "/1/psiR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_psiR, dataset_x, 0);
  #endif
  hid_t dataset_psiI;
  if (!H5Lexists(hdf5_file, "/1/psiI", H5P_DEFAULT))
    dataset_psiI = H5Dcreate(hdf5_file, "/1/psiI", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_psiI = H5Dopen(hdf5_file, "/1/psiI");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_psiI, dataset_x, 0);
  #endif
  H5Dclose(dataset_x);
  
  
  if ((_lattice_x)) {
    /* Create the data space */
    hsize_t file_start[1] = {(unsigned long long int)0};
    hsize_t mem_dims[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
    hsize_t mem_start[2] = {0, 0};
    hsize_t mem_stride[2] = {1, 1};
    hsize_t mem_count[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[1] = 2;
    mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
    mem_stride[1] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[1] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_psiR)
      H5Dwrite(dataset_psiR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
    mem_start[1] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_psiI)
      H5Dwrite(dataset_psiI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_psiR);
  H5Dclose(dataset_psiI);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "        <name>th_spgpe_gs</name>\n");
  fprintf(fp, "        <author>Joe Hope, Stuart Szigeti and Karen Kheruntsyan</author>\n");
  fprintf(fp, "        <description>\n");
  fprintf(fp, "                Calculate the ground state of the Gross-Pitaevskii equation in a harmonic  trap, coupled to a thermal resivior.\n");
  fprintf(fp, "        </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <features>\n");
  fprintf(fp, "                <auto_vectorise/>\n");
  fprintf(fp, "                <benchmark/>\n");
  fprintf(fp, "                <bing/>\n");
  fprintf(fp, "                <fftw plan=\"exhaustive\"/>\n");
  fprintf(fp, "                <validation kind=\"run-time\"/>\n");
  fprintf(fp, "                <globals>\n");
  fprintf(fp, "                        <![CDATA[                       \n");
  fprintf(fp, "                        real R_tilde;\n");
  fprintf(fp, "                        real rho0_tilde;                                                        \n");
  fprintf(fp, "                        real t_lim;                     \n");
  fprintf(fp, "                        real kth;                       \n");
  fprintf(fp, "                        real sgT;               \n");
  fprintf(fp, "                        real mu;\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </globals>\n");
  fprintf(fp, "                <arguments>\n");
  fprintf(fp, "                        <argument default_value=\"0.0786\" name=\"chi\" type=\"real\"/>\n");
  fprintf(fp, "                        <argument default_value=\"0.0057\" name=\"omega_bar\" type=\"real\"/>\n");
  fprintf(fp, "                        <argument default_value=\"7.0\" name=\"k0\" type=\"real\"/>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        R_tilde = sqrt(2.0)*1/(pow(chi,1.0/3.0)*omega_bar);\n");
  fprintf(fp, "                        rho0_tilde = pow(chi,-2.0/3.0);                 \n");
  fprintf(fp, "                        kth = 0.12;     \n");
  fprintf(fp, "                        t_lim = log(4.0)/(omega_bar*1.1);\n");
  fprintf(fp, "                        sgT = sqrt(2.0*kth);                    \n");
  fprintf(fp, "                        mu=rho0_tilde;\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </arguments>\n");
  fprintf(fp, "        </features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <geometry>\n");
  fprintf(fp, "                <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "                <transverse_dimensions>\n");
  fprintf(fp, "                        <dimension lattice=\"1502\" length_scale=\"sqrt(1/(omega_bar))\" name=\"x\" spectral_lattice=\"1502\" transform=\"hermite-gauss\"/>\n");
  fprintf(fp, "                </transverse_dimensions>\n");
  fprintf(fp, "        </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <vector initial_basis=\"x\" name=\"wavefunction\" type=\"complex\">\n");
  fprintf(fp, "                <components> psi </components>\n");
  fprintf(fp, "                <initialisation>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        //psi = sqrt(rho0_tilde)* exp(-x*x/2.0/R_tilde/R_tilde);\n");
  fprintf(fp, "                if (fabs(x) < R_tilde) {\n");
  fprintf(fp, "                                psi = sqrt(rho0_tilde*(1-pow(x/R_tilde,2.0)));\n");
  fprintf(fp, "                        } else {\n");
  fprintf(fp, "                                psi = 0.0;\n");
  fprintf(fp, "                        }\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </initialisation>\n");
  fprintf(fp, "        </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <!-- Terms that are diagonal in the position basis (and *not* diagonal in momentum basis)-->\n");
  fprintf(fp, "        <computed_vector dimensions=\"x\" name=\"pos_space_terms\" type=\"complex\">\n");
  fprintf(fp, "      <components>\n");
  fprintf(fp, "                  U\n");
  fprintf(fp, "      </components>\n");
  fprintf(fp, "      <evaluation>\n");
  fprintf(fp, "        <dependencies basis=\"x_4f\">wavefunction</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "          // Compute nonlinear term\n");
  fprintf(fp, "          U = mod2(psi) * psi;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </evaluation>\n");
  fprintf(fp, "    </computed_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <noise_vector dimensions=\"x\" initial_basis=\"kx\" kind=\"wiener\" method=\"dsfmt\" name=\"driving_noise\" type=\"complex\">\n");
  fprintf(fp, "                <components> dW </components>\n");
  fprintf(fp, "        </noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "                <integrate algorithm=\"SI\" interval=\"t_lim\" steps=\"5000\" tolerance=\"1e-4\">\n");
  fprintf(fp, "                        <samples>10 10 10</samples>\n");
  fprintf(fp, "                        <operators>\n");
  fprintf(fp, "                                <operator kind=\"ip\" type=\"complex\">\n");
  fprintf(fp, "                                        <operator_names>L_st</operator_names>\n");
  fprintf(fp, "                                        <![CDATA[\n");
  fprintf(fp, "                                        L_st = - (nx + 0.5)*omega_bar*(i+kth);\n");
  fprintf(fp, "                                        ]]>\n");
  fprintf(fp, "                                </operator>\n");
  fprintf(fp, "                                <integration_vectors>wavefunction</integration_vectors>\n");
  fprintf(fp, "                                <dependencies>driving_noise pos_space_terms</dependencies>\n");
  fprintf(fp, "                                <![CDATA[\n");
  fprintf(fp, "                                dpsi_dt = L_st[psi]-(i+kth)*U + kth*mu*psi +sgT *dW;\n");
  fprintf(fp, "                                ]]>\n");
  fprintf(fp, "                        </operators>\n");
  fprintf(fp, "                </integrate>\n");
  fprintf(fp, "\n");
  fprintf(fp, "                <breakpoint filename=\"psi_gs.xsil\">\n");
  fprintf(fp, "                        <dependencies basis=\"x\"> wavefunction </dependencies>\n");
  fprintf(fp, "                </breakpoint>\n");
  fprintf(fp, "        </sequence>\n");
  fprintf(fp, "  \n");
  fprintf(fp, "        <output>\n");
  fprintf(fp, "                <sampling_group basis=\"x\" initial_sample=\"yes\">\n");
  fprintf(fp, "                        <moments> pos_dens pos_phase </moments>\n");
  fprintf(fp, "                        <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        pos_dens = mod2(psi);\n");
  fprintf(fp, "                        pos_phase = arg(psi);\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "                \n");
  fprintf(fp, "        <sampling_group basis=\"nx\" initial_sample=\"yes\">\n");
  fprintf(fp, "          <moments> herm_dens herm_phase </moments>\n");
  fprintf(fp, "          <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "          <![CDATA[\n");
  fprintf(fp, "            herm_dens = mod2(psi);\n");
  fprintf(fp, "                        herm_phase = arg(psi);\n");
  fprintf(fp, "          ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "        \n");
  fprintf(fp, "                <!-- Momentum-space output -->\n");
  fprintf(fp, "                <sampling_group basis=\"kx\" initial_sample=\"yes\">\n");
  fprintf(fp, "                        <moments> mom_dens mom_phase </moments>\n");
  fprintf(fp, "                        <dependencies> wavefunction </dependencies>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        mom_dens = mod2(psi);\n");
  fprintf(fp, "                        mom_phase = arg(psi);\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "        </output>\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 3.0.0 \"Release the Kraken\" (r3072)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument chi = %e\n", chi);
  
  fprintf(fp, "  Command line argument omega_bar = %e\n", omega_bar);
  
  fprintf(fp, "  Command line argument k0 = %e\n", k0);
  fprintf(fp, "\nNo seeds were provided for noise vector 'driving_noise'. The seeds generated were:\n");
  fprintf(fp, "    %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", _gen_driving_noise_seeds[0], _gen_driving_noise_seeds[1], _gen_driving_noise_seeds[2], _gen_driving_noise_seeds[3], _gen_driving_noise_seeds[4], _gen_driving_noise_seeds[5], _gen_driving_noise_seeds[6], _gen_driving_noise_seeds[7], _gen_driving_noise_seeds[8], _gen_driving_noise_seeds[9]);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for th_spgpe_gs\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("th_spgpe_gs" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("th_spgpe_gs" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  _mg1_write_out(_outfile);
  _mg2_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  // Transforming vectors to basis (t, x)
  _x_wavefunction_basis_transform(2); // (x)
  
  long _mg0_output_raw_index_pointer = 0;
  #define pos_dens _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define pos_phase _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // Set index pointers explicitly for (some) vectors
    _mg0_output_raw_index_pointer = ( 0
       + _mg0_output_index_t  * _lattice_x
       + _index_x * 1 ) * _mg0_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 107 "th_spgpe_gs.xmds"
    
    pos_dens = mod2(psi);
    pos_phase = arg(psi);
    
    #line 3732 "th_spgpe_gs.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef pos_dens
  #undef pos_phase
  #undef psi
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t x pos_dens pos_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_gs" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_gs" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_x;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_x;
  if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
    dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_x = H5Dopen(hdf5_file, "/1/x");
  H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_x, "x");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_x};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_pos_dens;
  if (!H5Lexists(hdf5_file, "/1/pos_dens", H5P_DEFAULT))
    dataset_pos_dens = H5Dcreate(hdf5_file, "/1/pos_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_pos_dens = H5Dopen(hdf5_file, "/1/pos_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_pos_dens, dataset_t, 0);
    H5DSattach_scale(dataset_pos_dens, dataset_x, 1);
  #endif
  hid_t dataset_pos_phase;
  if (!H5Lexists(hdf5_file, "/1/pos_phase", H5P_DEFAULT))
    dataset_pos_phase = H5Dcreate(hdf5_file, "/1/pos_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_pos_phase = H5Dopen(hdf5_file, "/1/pos_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_pos_phase, dataset_t, 0);
    H5DSattach_scale(dataset_pos_phase, dataset_x, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_x);
  
  
  if ((_mg0_output_lattice_t * _lattice_x)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_x, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_x, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_pos_dens)
      H5Dwrite(dataset_pos_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_pos_phase)
      H5Dwrite(dataset_pos_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_pos_dens);
  H5Dclose(dataset_pos_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

// ********************************************************
//   moment group 1 function implementations
void _mg1_sample()
{
  
  // Transforming vectors to basis (t, nx)
  _x_wavefunction_basis_transform(1); // (nx)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _mg1_output_raw_index_pointer = 0;
  #define herm_dens _active_mg1_output_raw[_mg1_output_raw_index_pointer + 0]
  #define herm_phase _active_mg1_output_raw[_mg1_output_raw_index_pointer + 1]
  #define nx _nx[_index_nx + 0]
  #define dnx (_dnx * (1.0))
  
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++) {
    // Set index pointers explicitly for (some) vectors
    _mg1_output_raw_index_pointer = ( 0
       + _mg1_output_index_t  * _lattice_nx
       + _index_nx * 1 ) * _mg1_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 116 "th_spgpe_gs.xmds"
    
    herm_dens = mod2(psi);
                herm_phase = arg(psi);
    
    #line 3945 "th_spgpe_gs.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg1_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef nx
  #undef dnx
  #undef psi
  #undef herm_dens
  #undef herm_phase
  
  _mg1_output_t[0 + _mg1_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #2) at t = %e\n", t);
  
}


void _mg1_process()
{
  // No post processing needs to be done
}


void _mg1_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_2\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t nx herm_dens herm_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg1_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_nx);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_gs" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/2", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/2", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/2");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/2\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_gs" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg1_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/2/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/2/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/2/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg1_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_nx;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_nx;
  if (!H5Lexists(hdf5_file, "/2/nx", H5P_DEFAULT))
    dataset_nx = H5Dcreate(hdf5_file, "/2/nx", H5T_NATIVE_LONG, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_nx = H5Dopen(hdf5_file, "/2/nx");
  H5Dwrite(dataset_nx, H5T_NATIVE_LONG, H5S_ALL, H5S_ALL, H5P_DEFAULT, _nx);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_nx, "nx");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg1_output_lattice_t, _lattice_nx};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_herm_dens;
  if (!H5Lexists(hdf5_file, "/2/herm_dens", H5P_DEFAULT))
    dataset_herm_dens = H5Dcreate(hdf5_file, "/2/herm_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_herm_dens = H5Dopen(hdf5_file, "/2/herm_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_herm_dens, dataset_t, 0);
    H5DSattach_scale(dataset_herm_dens, dataset_nx, 1);
  #endif
  hid_t dataset_herm_phase;
  if (!H5Lexists(hdf5_file, "/2/herm_phase", H5P_DEFAULT))
    dataset_herm_phase = H5Dcreate(hdf5_file, "/2/herm_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_herm_phase = H5Dopen(hdf5_file, "/2/herm_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_herm_phase, dataset_t, 0);
    H5DSattach_scale(dataset_herm_phase, dataset_nx, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_nx);
  
  
  if ((_mg1_output_lattice_t * _lattice_nx)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg1_output_lattice_t, (unsigned long long int)_lattice_nx, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg1_output_lattice_t, (unsigned long long int)_lattice_nx, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_herm_dens)
      H5Dwrite(dataset_herm_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg1_output_raw);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_herm_phase)
      H5Dwrite(dataset_herm_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg1_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_herm_dens);
  H5Dclose(dataset_herm_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg1_output function implementations
// initialisation for vector raw
void _mg1_output_raw_initialise()
{
  
  bzero(_active_mg1_output_raw, sizeof(real) * _mg1_output_raw_alloc_size);
}

// ********************************************************
//   moment group 2 function implementations
void _mg2_sample()
{
  
  // Transforming vectors to basis (t, kx)
  _x_wavefunction_basis_transform(0); // (kx)
  
  long _mg2_output_raw_index_pointer = 0;
  #define mom_dens _active_mg2_output_raw[_mg2_output_raw_index_pointer + 0]
  #define mom_phase _active_mg2_output_raw[_mg2_output_raw_index_pointer + 1]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx_array[_index_kx + 0] * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    // Set index pointers explicitly for (some) vectors
    _mg2_output_raw_index_pointer = ( 0
       + _mg2_output_index_t  * _lattice_kx
       + _index_kx * 1 ) * _mg2_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 126 "th_spgpe_gs.xmds"
    
    mom_dens = mod2(psi);
    mom_phase = arg(psi);
    
    #line 4158 "th_spgpe_gs.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg2_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef kx
  #undef dkx
  #undef mom_dens
  #undef mom_phase
  #undef psi
  
  _mg2_output_t[0 + _mg2_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #3) at t = %e\n", t);
  
}


void _mg2_process()
{
  // No post processing needs to be done
}


void _mg2_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_3\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t kx mom_dens mom_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg2_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_kx);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_gs" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/3", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/3", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/3");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/3\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_gs" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg2_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/3/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/3/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/3/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg2_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_kx;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_kx;
  if (!H5Lexists(hdf5_file, "/3/kx", H5P_DEFAULT))
    dataset_kx = H5Dcreate(hdf5_file, "/3/kx", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_kx = H5Dopen(hdf5_file, "/3/kx");
  H5Dwrite(dataset_kx, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _kx);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_kx, "kx");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg2_output_lattice_t, _lattice_kx};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_mom_dens;
  if (!H5Lexists(hdf5_file, "/3/mom_dens", H5P_DEFAULT))
    dataset_mom_dens = H5Dcreate(hdf5_file, "/3/mom_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mom_dens = H5Dopen(hdf5_file, "/3/mom_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mom_dens, dataset_t, 0);
    H5DSattach_scale(dataset_mom_dens, dataset_kx, 1);
  #endif
  hid_t dataset_mom_phase;
  if (!H5Lexists(hdf5_file, "/3/mom_phase", H5P_DEFAULT))
    dataset_mom_phase = H5Dcreate(hdf5_file, "/3/mom_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mom_phase = H5Dopen(hdf5_file, "/3/mom_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mom_phase, dataset_t, 0);
    H5DSattach_scale(dataset_mom_phase, dataset_kx, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_kx);
  
  
  if ((_mg2_output_lattice_t * _lattice_kx)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg2_output_lattice_t, (unsigned long long int)_lattice_kx, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg2_output_lattice_t, (unsigned long long int)_lattice_kx, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mom_dens)
      H5Dwrite(dataset_mom_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg2_output_raw);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mom_phase)
      H5Dwrite(dataset_mom_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg2_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_mom_dens);
  H5Dclose(dataset_mom_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg2_output function implementations
// initialisation for vector raw
void _mg2_output_raw_initialise()
{
  
  bzero(_active_mg2_output_raw, sizeof(real) * _mg2_output_raw_alloc_size);
}

