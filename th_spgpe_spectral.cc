
// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if ((_rank == 0) || (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL))) { \
        if (logLevel & ~(_SIMULATION_LOG_LEVEL | _SEGMENT_LOG_LEVEL | _SAMPLE_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
          printf("Rank[%i]: ", _rank); \
        if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
            printf("%s:%i: ", __FILE__, __LINE__); \
        printf(__VA_ARGS__); \
        fflush(stdout); \
      } \
      if (logLevel & _ERROR_LOG_LEVEL) \
        MPI_Abort(MPI_COMM_WORLD, 1); \
      else if (logLevel & _NO_ERROR_TERMINATE_LOG_LEVEL) \
        MPI_Finalize(); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#include <getopt.h>

#include <mpi.h>

#if   defined(CBLAS_MKL)
  #include <mkl.h>
#elif defined(CBLAS_VECLIB)
  #include <Accelerate/Accelerate.h>
#elif defined(CBLAS_ATLAS)
  extern "C" {
    #include <cblas.h>
  }
#elif defined(CBLAS_GSL)
  #include <gsl/gsl_cblas.h>
#endif

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE

#define DSFMT_DO_NOT_USE_OLD_NAMES
#if CFG_HAVE_SSE2
  #define HAVE_SSE2
#elif CFG_HAVE_ALTIVEC
  #define HAVE_ALTIVEC
#endif

#define DSFMT_MEXP 19937

#include <dSFMT/dSFMT.h>
#include <dSFMT/dSFMT.c>

#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Auto-vectorisation defines

#define _MAKE_AUTOVEC_VARIABLE(x) real* const __restrict__ x ## _autovec = (real*) x
#define _AUTOVEC(x) (x ## _autovec)

// ********************************************************
//   MPI Multipath Simulation Driver defines
#undef MPI_REAL
#define MPI_REAL MPI_DOUBLE
#define _n_paths 6

// ********************************************************
//   Geometry defines
#define _lattice_x ((int)1502)
#define _min_x     (_x[0])
#define _max_x     (_x[_lattice_x-1])

#define _lattice_nx ((int)1502)
#define _min_nx     ((long)0)
#define _max_nx     ((long)1502)
#define _dnx        ((long)1)

#define _lattice_kx ((int)1502)
#define _min_kx     (_kx[0])
#define _max_kx     (_kx[_lattice_kx-1])

#define _lattice_nx_twiddle ((int)1502)
#define _min_nx_twiddle     ((long)0)
#define _max_nx_twiddle     ((long)1502)
#define _dnx_twiddle        ((long)1)

#define _lattice_x_4f ((int)1502)
#define _min_x_4f     (_x_4f[0])
#define _max_x_4f     (_x_4f[_lattice_x_4f-1])

// ********************************************************
//   field x defines
#define _x_ndims 1


// vector wavefunction defines
#define _x_wavefunction_ncomponents 1

// vector driving_noise defines
#define _x_driving_noise_ncomponents 1

// vector pos_space_terms defines
#define _x_pos_space_terms_ncomponents 1

// ********************************************************
//   segment 1 (SI fixed-step integrator) defines
// vector segment1_x_operators_operator0_field defines
#define _x_segment1_x_operators_operator0_field_ncomponents 1

// ********************************************************
//   segment 4 (RK89 adaptive-step integrator) defines
// vector segment4_x_operators_operator0_field defines
#define _x_segment4_x_operators_operator0_field_ncomponents 14

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 1


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 2


#define _mg0_output_lattice_t ((int)2511)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 2

// vector processed defines
#define _mg0_output_processed_ncomponents 2

// ********************************************************
//   field mg1_sampling defines
#define _mg1_sampling_ndims 1


// ********************************************************
//   field mg1_output defines
#define _mg1_output_ndims 2


#define _mg1_output_lattice_t ((int)2511)
#define _mg1_output_min_t     (_mg1_output_t[0])
#define _mg1_output_max_t     (_mg1_output_t[_mg1_output_lattice_t-1])
#define _mg1_output_dt        (_mg1_output_t[_index_t+1]-_mg1_output_t[_index_t])

// vector processed defines
#define _mg1_output_processed_ncomponents 2

// vector raw defines
#define _mg1_output_raw_ncomponents 2

// ********************************************************
//   field mg2_sampling defines
#define _mg2_sampling_ndims 1


// ********************************************************
//   field mg2_output defines
#define _mg2_output_ndims 2


#define _mg2_output_lattice_t ((int)2511)
#define _mg2_output_min_t     (_mg2_output_t[0])
#define _mg2_output_max_t     (_mg2_output_t[_mg2_output_lattice_t-1])
#define _mg2_output_dt        (_mg2_output_t[_index_t+1]-_mg2_output_t[_index_t])

// vector processed defines
#define _mg2_output_processed_ncomponents 2

// vector raw defines
#define _mg2_output_raw_ncomponents 2


// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";
  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;

_basis_map _x_wavefunction_basis_map;
_basis_map _x_driving_noise_basis_map;
_basis_map _x_pos_space_terms_basis_map;

real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
  /* 0 */ "(kx)",
  /* 1 */ "(nx)",
  /* 2 */ "(x)",
  /* 3 */ "(x_4f)",
};

// ********************************************************
//   'Globals' element globals

#line 16 "th_spgpe_spectral.xmds"

real R_tilde;
real rho0_tilde;
real t_lim;
real t_lim_gs;
real kth; 
real sgT;
real mu;

#line 384 "th_spgpe_spectral.cc"

// ********************************************************
//   Command line argument processing globals
real chi = 0.0786; 
real omega_bar = 0.0057; 
real k0 = 7.0; 
real tl = 1.0; 

// ********************************************************
//   MPI Multipath Simulation Driver globals
int _rank, _size;

// ********************************************************
//   Geometry globals
real* _x = NULL;
real* _dx_array = (real*) xmds_malloc(sizeof(real) * (_lattice_x));

long* _nx = NULL;

real* _kx = NULL;
real* _dkx_array = (real*) xmds_malloc(sizeof(real) * (_lattice_kx));

long* _nx_twiddle = NULL;

real* _x_4f = NULL;
real* _dx_4f_array = (real*) xmds_malloc(sizeof(real) * (_lattice_x_4f));

// ********************************************************
//   MMT globals
const real _hermite_zeros_x[] = {
  -54.328926130872055, -53.96241809944158, -53.661986551031596,
  -53.39618607966144, -53.15298067808064, -52.92615831397634,
  -52.71198801563665, -52.50800901629689, -52.31249097464213,
  -52.12415896387552, -51.94203950889288, -51.765368098571166,
  -51.5935304947436, -51.42602381313066, -51.262429766574236,
  -51.102395705936516, -50.94562083733587, -50.79184597903793,
  -50.64084580159866, -50.492422849471424, -50.346402866001846,
  -50.20263108880324, -50.060969278934266, -49.92129331280579,
  -49.783491211118616, -49.64746151114597, -49.51311191159503,
  -49.38035813596413, -49.24912297259201, -49.11933545877167,
  -48.99093018320942, -48.863846686389174, -48.73802894246357,
  -48.61342490944391, -48.4899861369396, -48.36766742264341,
  -48.246426510318464, -48.12622382328404, -48.00702222840013,
  -47.88878682636782, -47.77148476482559, -47.655085071265304,
  -47.53955850324634, -47.42487741375286, -47.31101562985484,
  -47.197948343091475, -47.085652010214, -46.974104263107506,
  -46.86328382687221, -46.75317044516938, -46.6437448120594,
  -46.53498850964739, -46.42688395094156, -46.31941432739748,
  -46.21256356068394, -46.106316258260875, -46.00065767240461,
  -45.89557366235727, -45.79105065931231, -45.687075633979504,
  -45.58363606649914, -45.48071991849915, -45.37831560711164,
  -45.27641198078117, -45.17499829671607, -45.07406419984687,
  -44.97359970317066, -44.87359516936987, -44.774041293605926,
  -44.674929087396606, -44.57624986349425, -44.4779952216892,
  -44.380157035470624, -44.28272743948078, -44.18569881770632,
  -44.0890637923539, -43.99281521336156, -43.896946148502096,
  -43.801449874038084, -43.70631986589031, -43.61154979128667,
  -43.51713350085829, -43.42306502115531, -43.3293385475538,
  -43.235948437529935, -43.14288920427823, -43.05015551065153,
  -42.957742163404696, -42.865644107721366, -42.77385642200913,
  -42.68237431294506, -42.59119311075828, -42.50030826473558,
  -42.40971533893615, -42.31941000810563, -42.22938805377599,
  -42.13964536054276, -42.05017791250818, -41.960981789883036,
  -41.8720531657371, -41.783388302890664, -41.69498355094012,
  -41.60683534341025, -41.51894019502645, -41.43129469910121,
  -41.343895525028486, -41.25673941588099, -41.169823186104885,
  -41.0831437193075, -40.996697966133105, -40.910482942222444,
  -40.82449572625254, -40.73873345805194, -40.65319333678937,
  -40.567872619230535, -40.48276861806123, -40.397878700273374,
  -40.31320028561063, -40.22873084507155, -40.144467899467394,
  -40.060409018031976, -39.976551817081706, -39.89289395872311,
  -39.809433149606086, -39.726167139721, -39.643093721237626,
  -39.56021072738376, -39.477516031362605, -39.395007545306726,
  -39.31268321926739, -39.230541040237604, -39.14857903120731,
  -39.066795250250316, -38.9851877896405, -38.90375477499684,
  -38.822494364456084, -38.741404747871776, -38.660484146038684,
  -38.579730809941644, -38.49914302002783, -38.41871908550205,
  -38.33845734364298, -38.258356159141066, -38.178413923456056,
  -38.09862905419436, -38.018999994504554, -37.93952521249137,
  -37.86020320064674, -37.78103247529752, -37.70201157606961,
  -37.6231390653673, -37.544413527867675, -37.465833570029574,
  -37.38739781961649, -37.309104925232745, -37.23095355587307,
  -37.15294240048423, -37.0750701675391, -36.9973355846226,
  -36.919737398028474, -36.842274372367385, -36.76494529018563,
  -36.68774895159384, -36.610684173905724, -36.53374979128642,
  -36.456944654409995, -36.380267630125935, -36.30371760113451,
  -36.22729346567035, -36.150994137194004, -36.074818544091826,
  -35.99876562938319, -35.92283435043498, -35.84702367868369,
  -35.77133259936403, -35.69576011124455, -35.62030522636969,
  -35.54496696980808, -35.46974437940719, -35.39463650555383,
  -35.31964241094027, -35.24476117033643, -35.169991870366914,
  -35.095333609293945, -35.02078549680492, -34.94634665380506,
  -34.87201621221548, -34.79779331477503, -34.7236771148474,
  -34.64966677623233, -34.575761472981405, -34.50196038921772,
  -34.42826271895986, -34.35466766594988, -34.28117444348483,
  -34.20778227425243, -34.13449039017018, -34.061298032227896,
  -33.98820445033401, -33.9152089031651, -33.84231065801852,
  -33.76950899066842, -33.69680318522489, -33.62419253399585,
  -33.55167633735231, -33.47925390359602, -33.406924548830204,
  -33.33468759683311, -33.26254237893377, -33.19048823389081,
  -33.1185245077735, -33.04665055384524, -32.97486573244971,
  -32.903169410899004, -32.83156096336426, -32.76003977076836,
  -32.68860522068086, -32.617256707215184, -32.54599363092742,
  -32.47481539871768, -32.40372142373303, -32.332711125272304,
  -32.2617839286933, -32.19093926532087, -32.12017657235782,
  -32.04949529279676, -31.978894875333943, -31.908374774284873,
  -31.83793444950126, -31.767573366289746, -31.697290995332054,
  -31.6270868126067, -31.556960299312216, -31.486910941791628,
  -31.41693823145858, -31.3470416647246, -31.277220742927895,
  -31.207474972263256, -31.13780386371346, -31.06820693298174,
  -30.998683700425552, -30.929233690991577, -30.85985643415174,
  -30.79055146384066, -30.721318318393852, -30.652156540487294,
  -30.583065677077965, -30.514045279345407, -30.445094902634416,
  -30.37621410639858, -30.307402454144892, -30.238659513379336,
  -30.169984855553388, -30.101378056011402, -30.032838693938945,
  -29.96436635231198, -29.89596061784695, -29.82762108095162,
  -29.75934733567692, -29.69113897966931, -29.622995614124328,
  -29.554916843740536, -29.486902276674428, -29.418951524496112,
  -29.351064202145594, -29.283239927889813, -29.215478323280472,
  -29.147779013112523, -29.08014162538315, -29.01256579125168,
  -28.94505114499996, -28.877597323993474, -28.81020396864294,
  -28.742870722366725, -28.675597231553578, -28.608383145526332,
  -28.541228116505774, -28.47413179957535, -28.40709385264633,
  -28.340113936423467, -28.27319171437134, -28.20632685268108,
  -28.139519020237596, -28.072767888587467, -28.006073131907062,
  -27.939434426971506, -27.87285145312371, -27.806323892244244,
  -27.739851428721288, -27.67343374942146, -27.607070543660736,
  -27.54076150317591, -27.47450632209655, -27.408304696917284,
  -27.34215632647052, -27.27606091189966, -27.21001815663244,
  -27.144027766355045, -27.078089448986194, -27.01220291465199,
  -26.946367875660826, -26.88058404647881, -26.814851143705486,
  -26.749168886049947, -26.68353699430729, -26.61795519133531,
  -26.552423202031655, -26.486940753311192, -26.421507574083794,
  -26.35612339523236, -26.29078794959121, -26.225500971924685,
  -26.160262198906103, -26.095071369097077, -26.02992822292702,
  -25.964832502672852, -25.89978395243924, -25.83478231813894,
  -25.76982734747332, -25.704918789913357, -25.640056396680777,
  -25.575239920729402, -25.510469116726945, -25.44574374103669,
  -25.3810635516999, -25.316428308417954, -25.251837772535183,
  -25.187291707021604, -25.122789876455972, -25.058332047009127,
  -24.993917986427544, -24.929547464017045, -24.865220250626596,
  -24.800936118632766, -24.73669484192378, -24.672496195884285,
  -24.608339957380053, -24.544225904742863, -24.480153817755774,
  -24.416123477638333, -24.352134667032274, -24.288187169987076,
  -24.224280771945836, -24.160415259731504, -24.096590421532984,
  -24.032806046891622, -23.969061926687708, -23.905357853127303,
  -23.84169361972924, -23.778069021311882, -23.714483853980838,
  -23.650937915115904, -23.58743100335891, -23.523962918601303,
  -23.460533461972037, -23.397142435825547, -23.33378964372992,
  -23.27047489045518, -23.207197981961745, -23.143958725388924,
  -23.080756929043694, -23.017592402389525, -22.954464956035373,
  -22.891374401724743, -22.828320552324957, -22.765303221816538,
  -22.70232222528264, -22.639377378898736, -22.57646849992229,
  -22.513595406682608, -22.45075791857089, -22.387955856030235,
  -22.325189040545883, -22.262457294635563, -22.199760441839835,
  -22.137098306712698, -22.07447071481224, -22.011877492691372,
  -21.949318467888652, -21.88679346891933, -21.82430232526636,
  -21.761844867371565, -21.69942092662691, -21.637030335365903,
  -21.574672926855015, -21.51234853528521, -21.45005699576369,
  -21.387798144305567, -21.32557181782568, -21.26337785413059,
  -21.201216091910542, -21.139086370731597, -21.076988531027805,
  -21.014922414093448, -20.95288786207549, -20.890884717965925,
  -20.828912825594305, -20.766972029620433, -20.705062175526955,
  -20.643183109612163, -20.581334678982806, -20.519516731547064,
  -20.45772911600746, -20.395971681854032, -20.334244279357325,
  -20.27254675956176, -20.210878974278813, -20.149240776080415,
  -20.087632018292346, -20.02605255498779, -19.964502240980803,
  -19.902980931820007, -19.841488483782303, -19.78002475386653,
  -19.718589599787418, -19.65718287996938, -19.595804453540488,
  -19.534454180326506, -19.473131920844946, -19.411837536299196,
  -19.350570888572722, -19.28933184022331, -19.22812025447742,
  -19.166935995224467, -19.105778927011333, -19.044648915036767,
  -18.98354582514601, -18.922469523825296, -18.86141987819655,
  -18.800396756012063, -18.73940002564926, -18.678429556105467,
  -18.61748521699277, -18.556566878532976, -18.495674411552436,
  -18.434807687477207, -18.373966578327988, -18.31315095671521,
  -18.252360695834284, -18.19159566946068, -18.130855751945244,
  -18.07014081820945, -18.009450743740715, -17.94878540458775,
  -17.888144677356117, -17.827528439203473, -17.76693656783528,
  -17.70636894150018, -17.645825438985717, -17.585305939613914,
  -17.52481032323688, -17.46433847023266, -17.403890261500866,
  -17.34346557845848, -17.283064303035772, -17.22268631767206,
  -17.162331505311702, -17.10199974939999, -17.041690933879106,
  -16.981404943184213, -16.921141662239457, -16.86090097645409,
  -16.800682771718552, -16.740486934400636, -16.68031335134175,
  -16.620161909853064, -16.5600324977118, -16.499925003157543,
  -16.439839314888562, -16.379775322058173, -16.319732914271096,
  -16.259711981579983, -16.199712414481716, -16.139734103914044,
  -16.079776941252042, -16.01984081830463, -15.959925627311215,
  -15.900031260938242, -15.840157612275895, -15.780304574834702,
  -15.720472042542266, -15.660659909739985, -15.600868071179812,
  -15.541096422021017, -15.481344857826995, -15.421613274562151,
  -15.361901568588669, -15.302209636663502, -15.242537375935212,
  -15.182884683940959, -15.123251458603418, -15.063637598227833,
  -15.004043001498966, -14.944467567478199, -14.884911195600559,
  -14.825373785671848, -14.765855237865694, -14.706355452720768,
  -14.646874331137866, -14.587411774377152, -14.527967684055358,
  -14.468541962142986, -14.409134510961579, -14.349745233181002,
  -14.2903740318167, -14.231020810227097, -14.171685472110841,
  -14.112367921504232, -14.05306806277857, -13.99378580063757,
  -13.934521040114795, -13.875273686571074, -13.81604364569198,
  -13.756830823485322, -13.697635126278639, -13.63845646071671,
  -13.579294733759115, -13.52014985267778, -13.461021725054593,
  -13.401910258778937, -13.342815362045366, -13.283736943351201,
  -13.224674911494214, -13.165629175570276, -13.106599644971041,
  -13.047586229381674, -12.988588838778565, -12.929607383427042,
  -12.870641773879184, -12.811691920971528, -12.752757735822913,
  -12.693839129832256, -12.634936014676368, -12.576048302307832,
  -12.517175904952833, -12.458318735109, -12.399476705543314,
  -12.340649729290057, -12.281837719648633, -12.223040590181581,
  -12.164258254712456, -12.105490627323837, -12.0467376223553,
  -11.987999154401372, -11.929275138309531, -11.870565489178286,
  -11.811870122355167, -11.753188953434725, -11.694521898256697,
  -11.635868872903956, -11.577229793700704, -11.518604577210501,
  -11.459993140234404, -11.401395399809083, -11.34281127320496,
  -11.284240677924373, -11.225683531699712, -11.167139752491611,
  -11.108609258487139, -11.050091968097973, -10.991587799958657,
  -10.933096672924755, -10.874618506071172, -10.816153218690316,
  -10.757700730290416, -10.699260960593763, -10.640833829534998,
  -10.5824192572594, -10.524017164121195, -10.46562747068186,
  -10.407250097708465, -10.348884966171973, -10.290531997245646,
  -10.232191112303319, -10.173862232917848, -10.115545280859424,
  -10.057240178094006, -9.998946846781678, -9.940665209275085,
  -9.882395188117844, -9.82413670604295, -9.765889685971246,
  -9.707654051009829, -9.649429724450544, -9.591216629768413,
  -9.533014690620133, -9.474823830842558, -9.416643974451162,
  -9.35847504563857, -9.300316968773062, -9.242169668397075,
  -9.18403306922575, -9.125907096145443, -9.067791674212287,
  -9.009686728650752, -8.95159218485218, -8.893507968373351,
  -8.835434004935106, -8.777370220420876, -8.719316540875303,
  -8.661272892502836, -8.603239201666335, -8.54521539488569,
  -8.487201398836447, -8.429197140348434, -8.371202546404396,
  -8.31321754413864, -8.255242060835704, -8.197276023928998,
  -8.139319360999488, -8.08137199977435, -8.023433868125661,
  -7.965504894069098, -7.907585005762617, -7.849674131505154,
  -7.7917721997353455, -7.733879139030237, -7.675994878104,
  -7.618119345806677, -7.560252471122877, -7.502394183170566,
  -7.444544411199777, -7.386703084591376, -7.328870132855819,
  -7.271045485631924, -7.21322907268563, -7.155420823908775,
  -7.097620669317891, -7.039828539052975, -6.982044363376299,
  -6.924268072671206, -6.866499597440894, -6.808738868307268,
  -6.750985816009716, -6.693240371403953, -6.635502465460837,
  -6.577772029265211, -6.520048994014739, -6.462333291018735,
  -6.404624851697027, -6.346923607578796, -6.28922949030144,
  -6.231542431609444, -6.173862363353233, -6.11618921748805,
  -6.058522926072834, -6.000863421269096, -5.943210635339807,
  -5.8855645006483, -5.82792494965714, -5.770291914927053,
  -5.712665329115801, -5.655045124977107, -5.597431235359573,
  -5.5398235932055755, -5.482222131550199, -5.424626783520158,
  -5.367037482332735, -5.309454161294699, -5.251876753801243,
  -5.1943051933349365, -5.136739413464667, -5.079179347844574,
  -5.021624930213017, -4.964076094391522, -4.9065327742837415,
  -4.8489949038744316, -4.791462417228399, -4.733935248489471,
  -4.676413331879486, -4.618896601697259, -4.561384992317562,
  -4.503878438190103, -4.446376873838523, -4.388880233859384,
  -4.33138845292115, -4.273901465763194, -4.216419207194799,
  -4.158941612094155, -4.101468615407355, -4.044000152147421,
  -3.9865361573933136, -3.929076566288929, -3.871621314042117,
  -3.8141703359237256, -3.7567235672665973, -3.6992809434646023,
  -3.6418423999716665, -3.5844078723007975, -3.526977296023122,
  -3.4695506067669224, -3.4121277402166625, -3.354708632112034,
  -3.297293218247004, -3.2398814344688454, -3.182473216677204,
  -3.1250685008231285, -3.0676672229081228, -3.010269318983207,
  -2.952874725147976, -2.895483377549651, -2.8380952123821213,
  -2.7807101658850364, -2.723328174342844, -2.6659491740838916,
  -2.6085731014794384, -2.551199892942758, -2.493829484928218,
  -2.436461813930321, -2.379096816482811, -2.3217344291577184,
  -2.2643745885644577, -2.2070172313489014, -2.1496622941924604,
  -2.092309713811154, -2.034959426954715, -1.977611370405662,
  -1.920265480978378, -1.8629216955182064, -1.8055799509005352,
  -1.7482401840299027, -1.690902331839065, -1.6335663312880973,
  -1.5762321193635016, -1.5188996330772628, -1.4615688094660038,
  -1.404239585590017, -1.3469118985324098, -1.2895856853981644,
  -1.2322608833132909, -1.1749374294238804, -1.1176152608952008,
  -1.0602943149108364, -1.0029745286717888, -0.945655839395532,
  -0.8883381843151706, -0.8310215006785162, -0.7737057257471671,
  -0.7163907967957006, -0.6590766511106907, -0.6017632259898676,
  -0.5444504587411902, -0.48713828668196585, -0.4298266471379511,
  -0.3725154774425194, -0.31520471493569163, -0.2578942969632464,
  -0.20058416087591344, -0.1432742440284399, -0.08596448377855989,
  -0.028654817486422266, 0.028654817486422266, 0.08596448377855989,
  0.1432742440284399, 0.20058416087591344, 0.2578942969632464,
  0.31520471493569163, 0.3725154774425194, 0.4298266471379511,
  0.48713828668196585, 0.5444504587411902, 0.6017632259898676,
  0.6590766511106907, 0.7163907967957006, 0.7737057257471671,
  0.8310215006785162, 0.8883381843151706, 0.945655839395532,
  1.0029745286717888, 1.0602943149108364, 1.1176152608952008,
  1.1749374294238804, 1.2322608833132909, 1.2895856853981644,
  1.3469118985324098, 1.404239585590017, 1.4615688094660038,
  1.5188996330772628, 1.5762321193635016, 1.6335663312880973,
  1.690902331839065, 1.7482401840299027, 1.8055799509005352,
  1.8629216955182064, 1.920265480978378, 1.977611370405662,
  2.034959426954715, 2.092309713811154, 2.1496622941924604,
  2.2070172313489014, 2.2643745885644577, 2.3217344291577184,
  2.379096816482811, 2.436461813930321, 2.493829484928218,
  2.551199892942758, 2.6085731014794384, 2.6659491740838916,
  2.723328174342844, 2.7807101658850364, 2.8380952123821213,
  2.895483377549651, 2.952874725147976, 3.010269318983207,
  3.0676672229081228, 3.1250685008231285, 3.182473216677204,
  3.2398814344688454, 3.297293218247004, 3.354708632112034,
  3.4121277402166625, 3.4695506067669224, 3.526977296023122,
  3.5844078723007975, 3.6418423999716665, 3.6992809434646023,
  3.7567235672665973, 3.8141703359237256, 3.871621314042117,
  3.929076566288929, 3.9865361573933136, 4.044000152147421,
  4.101468615407355, 4.158941612094155, 4.216419207194799,
  4.273901465763194, 4.33138845292115, 4.388880233859384,
  4.446376873838523, 4.503878438190103, 4.561384992317562,
  4.618896601697259, 4.676413331879486, 4.733935248489471,
  4.791462417228399, 4.8489949038744316, 4.9065327742837415,
  4.964076094391522, 5.021624930213017, 5.079179347844574,
  5.136739413464667, 5.1943051933349365, 5.251876753801243,
  5.309454161294699, 5.367037482332735, 5.424626783520158,
  5.482222131550199, 5.5398235932055755, 5.597431235359573,
  5.655045124977107, 5.712665329115801, 5.770291914927053,
  5.82792494965714, 5.8855645006483, 5.943210635339807,
  6.000863421269096, 6.058522926072834, 6.11618921748805,
  6.173862363353233, 6.231542431609444, 6.28922949030144,
  6.346923607578796, 6.404624851697027, 6.462333291018735,
  6.520048994014739, 6.577772029265211, 6.635502465460837,
  6.693240371403953, 6.750985816009716, 6.808738868307268,
  6.866499597440894, 6.924268072671206, 6.982044363376299,
  7.039828539052975, 7.097620669317891, 7.155420823908775,
  7.21322907268563, 7.271045485631924, 7.328870132855819,
  7.386703084591376, 7.444544411199777, 7.502394183170566,
  7.560252471122877, 7.618119345806677, 7.675994878104,
  7.733879139030237, 7.7917721997353455, 7.849674131505154,
  7.907585005762617, 7.965504894069098, 8.023433868125661,
  8.08137199977435, 8.139319360999488, 8.197276023928998,
  8.255242060835704, 8.31321754413864, 8.371202546404396,
  8.429197140348434, 8.487201398836447, 8.54521539488569,
  8.603239201666335, 8.661272892502836, 8.719316540875303,
  8.777370220420876, 8.835434004935106, 8.893507968373351,
  8.95159218485218, 9.009686728650752, 9.067791674212287,
  9.125907096145443, 9.18403306922575, 9.242169668397075,
  9.300316968773062, 9.35847504563857, 9.416643974451162,
  9.474823830842558, 9.533014690620133, 9.591216629768413,
  9.649429724450544, 9.707654051009829, 9.765889685971246,
  9.82413670604295, 9.882395188117844, 9.940665209275085,
  9.998946846781678, 10.057240178094006, 10.115545280859424,
  10.173862232917848, 10.232191112303319, 10.290531997245646,
  10.348884966171973, 10.407250097708465, 10.46562747068186,
  10.524017164121195, 10.5824192572594, 10.640833829534998,
  10.699260960593763, 10.757700730290416, 10.816153218690316,
  10.874618506071172, 10.933096672924755, 10.991587799958657,
  11.050091968097973, 11.108609258487139, 11.167139752491611,
  11.225683531699712, 11.284240677924373, 11.34281127320496,
  11.401395399809083, 11.459993140234404, 11.518604577210501,
  11.577229793700704, 11.635868872903956, 11.694521898256697,
  11.753188953434725, 11.811870122355167, 11.870565489178286,
  11.929275138309531, 11.987999154401372, 12.0467376223553,
  12.105490627323837, 12.164258254712456, 12.223040590181581,
  12.281837719648633, 12.340649729290057, 12.399476705543314,
  12.458318735109, 12.517175904952833, 12.576048302307832,
  12.634936014676368, 12.693839129832256, 12.752757735822913,
  12.811691920971528, 12.870641773879184, 12.929607383427042,
  12.988588838778565, 13.047586229381674, 13.106599644971041,
  13.165629175570276, 13.224674911494214, 13.283736943351201,
  13.342815362045366, 13.401910258778937, 13.461021725054593,
  13.52014985267778, 13.579294733759115, 13.63845646071671,
  13.697635126278639, 13.756830823485322, 13.81604364569198,
  13.875273686571074, 13.934521040114795, 13.99378580063757,
  14.05306806277857, 14.112367921504232, 14.171685472110841,
  14.231020810227097, 14.2903740318167, 14.349745233181002,
  14.409134510961579, 14.468541962142986, 14.527967684055358,
  14.587411774377152, 14.646874331137866, 14.706355452720768,
  14.765855237865694, 14.825373785671848, 14.884911195600559,
  14.944467567478199, 15.004043001498966, 15.063637598227833,
  15.123251458603418, 15.182884683940959, 15.242537375935212,
  15.302209636663502, 15.361901568588669, 15.421613274562151,
  15.481344857826995, 15.541096422021017, 15.600868071179812,
  15.660659909739985, 15.720472042542266, 15.780304574834702,
  15.840157612275895, 15.900031260938242, 15.959925627311215,
  16.01984081830463, 16.079776941252042, 16.139734103914044,
  16.199712414481716, 16.259711981579983, 16.319732914271096,
  16.379775322058173, 16.439839314888562, 16.499925003157543,
  16.5600324977118, 16.620161909853064, 16.68031335134175,
  16.740486934400636, 16.800682771718552, 16.86090097645409,
  16.921141662239457, 16.981404943184213, 17.041690933879106,
  17.10199974939999, 17.162331505311702, 17.22268631767206,
  17.283064303035772, 17.34346557845848, 17.403890261500866,
  17.46433847023266, 17.52481032323688, 17.585305939613914,
  17.645825438985717, 17.70636894150018, 17.76693656783528,
  17.827528439203473, 17.888144677356117, 17.94878540458775,
  18.009450743740715, 18.07014081820945, 18.130855751945244,
  18.19159566946068, 18.252360695834284, 18.31315095671521,
  18.373966578327988, 18.434807687477207, 18.495674411552436,
  18.556566878532976, 18.61748521699277, 18.678429556105467,
  18.73940002564926, 18.800396756012063, 18.86141987819655,
  18.922469523825296, 18.98354582514601, 19.044648915036767,
  19.105778927011333, 19.166935995224467, 19.22812025447742,
  19.28933184022331, 19.350570888572722, 19.411837536299196,
  19.473131920844946, 19.534454180326506, 19.595804453540488,
  19.65718287996938, 19.718589599787418, 19.78002475386653,
  19.841488483782303, 19.902980931820007, 19.964502240980803,
  20.02605255498779, 20.087632018292346, 20.149240776080415,
  20.210878974278813, 20.27254675956176, 20.334244279357325,
  20.395971681854032, 20.45772911600746, 20.519516731547064,
  20.581334678982806, 20.643183109612163, 20.705062175526955,
  20.766972029620433, 20.828912825594305, 20.890884717965925,
  20.95288786207549, 21.014922414093448, 21.076988531027805,
  21.139086370731597, 21.201216091910542, 21.26337785413059,
  21.32557181782568, 21.387798144305567, 21.45005699576369,
  21.51234853528521, 21.574672926855015, 21.637030335365903,
  21.69942092662691, 21.761844867371565, 21.82430232526636,
  21.88679346891933, 21.949318467888652, 22.011877492691372,
  22.07447071481224, 22.137098306712698, 22.199760441839835,
  22.262457294635563, 22.325189040545883, 22.387955856030235,
  22.45075791857089, 22.513595406682608, 22.57646849992229,
  22.639377378898736, 22.70232222528264, 22.765303221816538,
  22.828320552324957, 22.891374401724743, 22.954464956035373,
  23.017592402389525, 23.080756929043694, 23.143958725388924,
  23.207197981961745, 23.27047489045518, 23.33378964372992,
  23.397142435825547, 23.460533461972037, 23.523962918601303,
  23.58743100335891, 23.650937915115904, 23.714483853980838,
  23.778069021311882, 23.84169361972924, 23.905357853127303,
  23.969061926687708, 24.032806046891622, 24.096590421532984,
  24.160415259731504, 24.224280771945836, 24.288187169987076,
  24.352134667032274, 24.416123477638333, 24.480153817755774,
  24.544225904742863, 24.608339957380053, 24.672496195884285,
  24.73669484192378, 24.800936118632766, 24.865220250626596,
  24.929547464017045, 24.993917986427544, 25.058332047009127,
  25.122789876455972, 25.187291707021604, 25.251837772535183,
  25.316428308417954, 25.3810635516999, 25.44574374103669,
  25.510469116726945, 25.575239920729402, 25.640056396680777,
  25.704918789913357, 25.76982734747332, 25.83478231813894,
  25.89978395243924, 25.964832502672852, 26.02992822292702,
  26.095071369097077, 26.160262198906103, 26.225500971924685,
  26.29078794959121, 26.35612339523236, 26.421507574083794,
  26.486940753311192, 26.552423202031655, 26.61795519133531,
  26.68353699430729, 26.749168886049947, 26.814851143705486,
  26.88058404647881, 26.946367875660826, 27.01220291465199,
  27.078089448986194, 27.144027766355045, 27.21001815663244,
  27.27606091189966, 27.34215632647052, 27.408304696917284,
  27.47450632209655, 27.54076150317591, 27.607070543660736,
  27.67343374942146, 27.739851428721288, 27.806323892244244,
  27.87285145312371, 27.939434426971506, 28.006073131907062,
  28.072767888587467, 28.139519020237596, 28.20632685268108,
  28.27319171437134, 28.340113936423467, 28.40709385264633,
  28.47413179957535, 28.541228116505774, 28.608383145526332,
  28.675597231553578, 28.742870722366725, 28.81020396864294,
  28.877597323993474, 28.94505114499996, 29.01256579125168,
  29.08014162538315, 29.147779013112523, 29.215478323280472,
  29.283239927889813, 29.351064202145594, 29.418951524496112,
  29.486902276674428, 29.554916843740536, 29.622995614124328,
  29.69113897966931, 29.75934733567692, 29.82762108095162,
  29.89596061784695, 29.96436635231198, 30.032838693938945,
  30.101378056011402, 30.169984855553388, 30.238659513379336,
  30.307402454144892, 30.37621410639858, 30.445094902634416,
  30.514045279345407, 30.583065677077965, 30.652156540487294,
  30.721318318393852, 30.79055146384066, 30.85985643415174,
  30.929233690991577, 30.998683700425552, 31.06820693298174,
  31.13780386371346, 31.207474972263256, 31.277220742927895,
  31.3470416647246, 31.41693823145858, 31.486910941791628,
  31.556960299312216, 31.6270868126067, 31.697290995332054,
  31.767573366289746, 31.83793444950126, 31.908374774284873,
  31.978894875333943, 32.04949529279676, 32.12017657235782,
  32.19093926532087, 32.2617839286933, 32.332711125272304,
  32.40372142373303, 32.47481539871768, 32.54599363092742,
  32.617256707215184, 32.68860522068086, 32.76003977076836,
  32.83156096336426, 32.903169410899004, 32.97486573244971,
  33.04665055384524, 33.1185245077735, 33.19048823389081,
  33.26254237893377, 33.33468759683311, 33.406924548830204,
  33.47925390359602, 33.55167633735231, 33.62419253399585,
  33.69680318522489, 33.76950899066842, 33.84231065801852,
  33.9152089031651, 33.98820445033401, 34.061298032227896,
  34.13449039017018, 34.20778227425243, 34.28117444348483,
  34.35466766594988, 34.42826271895986, 34.50196038921772,
  34.575761472981405, 34.64966677623233, 34.7236771148474,
  34.79779331477503, 34.87201621221548, 34.94634665380506,
  35.02078549680492, 35.095333609293945, 35.169991870366914,
  35.24476117033643, 35.31964241094027, 35.39463650555383,
  35.46974437940719, 35.54496696980808, 35.62030522636969,
  35.69576011124455, 35.77133259936403, 35.84702367868369,
  35.92283435043498, 35.99876562938319, 36.074818544091826,
  36.150994137194004, 36.22729346567035, 36.30371760113451,
  36.380267630125935, 36.456944654409995, 36.53374979128642,
  36.610684173905724, 36.68774895159384, 36.76494529018563,
  36.842274372367385, 36.919737398028474, 36.9973355846226,
  37.0750701675391, 37.15294240048423, 37.23095355587307,
  37.309104925232745, 37.38739781961649, 37.465833570029574,
  37.544413527867675, 37.6231390653673, 37.70201157606961,
  37.78103247529752, 37.86020320064674, 37.93952521249137,
  38.018999994504554, 38.09862905419436, 38.178413923456056,
  38.258356159141066, 38.33845734364298, 38.41871908550205,
  38.49914302002783, 38.579730809941644, 38.660484146038684,
  38.741404747871776, 38.822494364456084, 38.90375477499684,
  38.9851877896405, 39.066795250250316, 39.14857903120731,
  39.230541040237604, 39.31268321926739, 39.395007545306726,
  39.477516031362605, 39.56021072738376, 39.643093721237626,
  39.726167139721, 39.809433149606086, 39.89289395872311,
  39.976551817081706, 40.060409018031976, 40.144467899467394,
  40.22873084507155, 40.31320028561063, 40.397878700273374,
  40.48276861806123, 40.567872619230535, 40.65319333678937,
  40.73873345805194, 40.82449572625254, 40.910482942222444,
  40.996697966133105, 41.0831437193075, 41.169823186104885,
  41.25673941588099, 41.343895525028486, 41.43129469910121,
  41.51894019502645, 41.60683534341025, 41.69498355094012,
  41.783388302890664, 41.8720531657371, 41.960981789883036,
  42.05017791250818, 42.13964536054276, 42.22938805377599,
  42.31941000810563, 42.40971533893615, 42.50030826473558,
  42.59119311075828, 42.68237431294506, 42.77385642200913,
  42.865644107721366, 42.957742163404696, 43.05015551065153,
  43.14288920427823, 43.235948437529935, 43.3293385475538,
  43.42306502115531, 43.51713350085829, 43.61154979128667,
  43.70631986589031, 43.801449874038084, 43.896946148502096,
  43.99281521336156, 44.0890637923539, 44.18569881770632,
  44.28272743948078, 44.380157035470624, 44.4779952216892,
  44.57624986349425, 44.674929087396606, 44.774041293605926,
  44.87359516936987, 44.97359970317066, 45.07406419984687,
  45.17499829671607, 45.27641198078117, 45.37831560711164,
  45.48071991849915, 45.58363606649914, 45.687075633979504,
  45.79105065931231, 45.89557366235727, 46.00065767240461,
  46.106316258260875, 46.21256356068394, 46.31941432739748,
  46.42688395094156, 46.53498850964739, 46.6437448120594,
  46.75317044516938, 46.86328382687221, 46.974104263107506,
  47.085652010214, 47.197948343091475, 47.31101562985484,
  47.42487741375286, 47.53955850324634, 47.655085071265304,
  47.77148476482559, 47.88878682636782, 48.00702222840013,
  48.12622382328404, 48.246426510318464, 48.36766742264341,
  48.4899861369396, 48.61342490944391, 48.73802894246357,
  48.863846686389174, 48.99093018320942, 49.11933545877167,
  49.24912297259201, 49.38035813596413, 49.51311191159503,
  49.64746151114597, 49.783491211118616, 49.92129331280579,
  50.060969278934266, 50.20263108880324, 50.346402866001846,
  50.492422849471424, 50.64084580159866, 50.79184597903793,
  50.94562083733587, 51.102395705936516, 51.262429766574236,
  51.42602381313066, 51.5935304947436, 51.765368098571166,
  51.94203950889288, 52.12415896387552, 52.31249097464213,
  52.50800901629689, 52.71198801563665, 52.92615831397634,
  53.15298067808064, 53.39618607966144, 53.661986551031596,
  53.96241809944158, 54.328926130872055
  };
const real _hermite_gauss_weights_x[] = {
  0.42569184393634385, 0.3249567967276586, 0.2802986015980284,
  0.25315713324910166, 0.23424380680372367, 0.22000503548177544,
  0.2087374637630829, 0.19950463254617876, 0.1917414980133161,
  0.18508328778673924, 0.17928209342441523, 0.17416246859778775,
  0.16959611701205476, 0.16548665072122593, 0.16175999128288557,
  0.1583580940186295, 0.15523471242947257, 0.1523524605408998,
  0.14968072645243646, 0.14719415938604596, 0.14487155217180486,
  0.14269500220754397, 0.1406492721626895, 0.13872129634891353,
  0.13689979502138885, 0.1351749696262274, 0.13353825963655888,
  0.13198214669807298, 0.13049999558554157, 0.12908592398252508,
  0.12773469512487529, 0.12644162868537906, 0.12520252631296663,
  0.12401360908268529, 0.12287146462499367, 0.12177300224310428,
  0.12071541459598996, 0.11969614484349853, 0.11871285836709539,
  0.11776341831361917, 0.11684586436446308, 0.1159583942551442,
  0.11509934759939439, 0.11426719171846339, 0.1134605091688146,
  0.11267798673375132, 0.11191840567768785, 0.11118063311032408,
  0.11046361428324351, 0.10976636574119807, 0.10908796917674628,
  0.10842756593906401, 0.10778435209350773, 0.10715757397680346,
  0.10654652419097209, 0.10595053797854054, 0.10536898994389694,
  0.10480129107816961, 0.10424688605833059, 0.10370525078497772,
  0.10317589013836426, 0.10265833593625949, 0.10215214505534585,
  0.10165689772007491, 0.10117219592764994, 0.10069766200541516,
  0.10023293728066235, 0.09977768085909958, 0.09933156849706454,
  0.09889429155943263, 0.09846555605786883, 0.09804508176173332,
  0.09763260137195404, 0.09722785975803222, 0.09683061324818976,
  0.09644062896864734, 0.09605768423134357, 0.09568156596319645,
  0.09531207017224008, 0.09494900145370064, 0.09459217252378982,
  0.09424140378977827, 0.09389652294166041, 0.09355736457561047,
  0.09322376983864708, 0.09289558609346668, 0.09257266660975222,
  0.09225487026677055, 0.09194206128273988, 0.0916341089505213,
  0.09133088739787532, 0.09103227535664357, 0.09073815594429689,
  0.09044841646512801, 0.09016294821199165, 0.08988164628908217,
  0.08960440943728767, 0.08933113987558143, 0.0890617431445232,
  0.08879612796147152, 0.08853420608482916, 0.08827589218342669,
  0.0880211037119185, 0.08776976079520621, 0.08752178611655628,
  0.08727710481219045, 0.08703564437176525, 0.08679733454365546,
  0.0865621072430484, 0.0863298964665416, 0.08610063821088505,
  0.0858742703939818, 0.08565073278304056, 0.08542996691980542,
  0.08521191605655698, 0.08499652509076279, 0.08478374050284093,
  0.08457351029882272, 0.08436578395404308, 0.08416051235934185,
  0.08395764777044173, 0.08375714375842327, 0.0835589551638577,
  0.0833630380522295, 0.08316934967084066, 0.08297784840687716,
  0.08278849374988154, 0.08260124625359619, 0.08241606750003366,
  0.08223292006432227, 0.08205176748191588, 0.08187257421821456,
  0.08169530563589425, 0.08151992796687017, 0.08134640828427941,
  0.08117471447535055, 0.08100481521504703, 0.08083667994158816,
  0.08067027883263767, 0.08050558278248804, 0.0803425633782808,
  0.08018119288080275, 0.08002144420274408, 0.07986329088955597,
  0.07970670709946451, 0.07955166758663282, 0.0793981476820025,
  0.07924612327722888, 0.07909557080823244, 0.07894646723863978,
  0.0787987900452287, 0.07865251720308553, 0.07850762717143787,
  0.07836409887963512, 0.07822191171459207, 0.07808104550660151,
  0.07794148051872928, 0.07780319743408812, 0.07766617734369033,
  0.07753040173650198, 0.07739585248829535, 0.07726251185059116,
  0.07713036244135019, 0.07699938723490778, 0.07686956955249888,
  0.07674089305329578, 0.07661334172595152, 0.07648689987927863,
  0.07636155213404133, 0.07623728341598315, 0.07611407894706386,
  0.07599192423777111, 0.0758708050812111, 0.07575070754432163,
  0.07563161796244051, 0.07551352293159026, 0.07539640930265773,
  0.0752802641753062, 0.07516507489144102, 0.07505082902932042,
  0.07493751439885658, 0.0748251190343337, 0.0747136311907832,
  0.07460303933733504, 0.07449333215311961, 0.07438449852287148,
  0.07427652752991684, 0.07416940845387826, 0.07406313076494245,
  0.07395768412014925, 0.07385305835826679, 0.07374924349648006,
  0.07364622972617024, 0.0735440074083847, 0.07344256707123759,
  0.07334189940496766, 0.07324199525886514, 0.07314284563834851,
  0.07304444170072161, 0.07294677475176947, 0.07284983624329901,
  0.0727536177695563, 0.07265811106393154, 0.07256330799676602,
  0.07246920057129719, 0.07237578092193502, 0.07228304131117161,
  0.07219097412615842, 0.07209957187739956, 0.07200882719507291,
  0.07191873282704178, 0.07182928163681052, 0.07174046660033274,
  0.0716522808041679, 0.07156471744317455, 0.07147776981861285,
  0.07139143133571327, 0.07130569550124372, 0.07122055592248036,
  0.07113600630414924, 0.071052040446984, 0.07096865224648805,
  0.07088583568922371, 0.07080358485355366, 0.07072189390564018,
  0.07064075709893715, 0.07056016877256552, 0.07048012334889295,
  0.07040061533257472, 0.07032163930887161, 0.07024318994209426,
  0.07016526197422795, 0.07008785022303576, 0.0700109495812948,
  0.06993455501502713, 0.06985866156210267, 0.06978326433110003,
  0.0697083584999752, 0.06963393931470767, 0.06956000208814096,
  0.06948654219874285, 0.06941355508944382, 0.06934103626664846,
  0.06926898129859904, 0.0691973858147497, 0.06912624550459714,
  0.06905555611651193, 0.0689853134568723, 0.06891551338868247,
  0.06884615183096442, 0.06877722475781645, 0.06870872819713343,
  0.0686406582298179, 0.06857301098905963, 0.06850578265908301,
  0.06843896947470625, 0.06837256772003739, 0.06830657372808256,
  0.06824098387949852, 0.06817579460230284, 0.06811100237047892,
  0.06804660370361709, 0.06798259516618448, 0.06791897336644911,
  0.06785573495608845, 0.06779287662944396, 0.06773039512267766,
  0.06766828721303215, 0.06760654971846894, 0.06754517949678,
  0.06748417344507901, 0.06742352849884065, 0.06736324163188813,
  0.06730330985510528, 0.06724373021664243, 0.06718449980039679,
  0.06712561572621205, 0.06706707514890095, 0.067008875257812,
  0.06695101327653648, 0.06689348646195661, 0.06683629210388979,
  0.0667794275247941, 0.06672289007889486, 0.06666667715215968,
  0.06661078616129519, 0.06655521455372093, 0.0664999598066947,
  0.06644501942752543, 0.06639039095232262, 0.06633607194590566,
  0.06628206000170263, 0.0662283527407914, 0.066174947811829,
  0.06612184289064758, 0.0660690356793822, 0.06601652390691544,
  0.06596430532766084, 0.06591237772187342, 0.06586073889472537,
  0.0658093866762073, 0.06575831892084968, 0.0657075335072066,
  0.0656570283376292, 0.06560680133774037, 0.06555685045631414,
  0.06550717366485953, 0.06545776895735106, 0.06540863434984921,
  0.06535976788023039, 0.06531116760768764, 0.065262831612795,
  0.06521475799705113, 0.06516694488245034, 0.06511939041120679,
  0.0650720927459428, 0.0650250500687671, 0.0649782605812646,
  0.06493172250445141, 0.06488543407816452, 0.06483939356103942,
  0.06479359923014433, 0.0647480493806605, 0.06470274232601218,
  0.06465767639704502, 0.06461284994243066, 0.06456826132782363,
  0.06452390893596882, 0.06447979116651908, 0.06443590643577007,
  0.06439225317621233, 0.06434882983641668, 0.0643056348813906,
  0.06426266679131559, 0.06421992406227739, 0.06417740520554428,
  0.06413510874744996, 0.06409303322953425, 0.06405117720782735,
  0.06400953925318555, 0.06396811795053678, 0.06392691189916926,
  0.06388591971253849, 0.06384514001772763, 0.063804571455556,
  0.06376421268027828, 0.06372406235963904, 0.06368411917450884,
  0.06364438181842332, 0.06360484899844752, 0.0635655194335576,
  0.0635263918558061, 0.06348746500939827, 0.06344873765079441,
  0.06341020854847419, 0.06337187648294007, 0.06333374024642151,
  0.06329579864279233, 0.06325805048735982, 0.06322049460689437,
  0.0631831298393861, 0.06314595503387173, 0.06310896905029359,
  0.06307217075951699, 0.06303555904310122, 0.06299913279305581,
  0.06296289091201332, 0.06292683231277582, 0.06289095591843186,
  0.06285526066221242, 0.06281974548718666, 0.06278440934638573,
  0.0627492512025244, 0.06271427002789504, 0.06267946480439648,
  0.06264483452334677, 0.06261037818526756, 0.0625760947999001,
  0.06254198338615564, 0.0625080429718414, 0.06247427259366576,
  0.062440671297112914, 0.062407238136437254, 0.06237397217435717,
  0.0623408724821251, 0.062307938139461325, 0.062275168234285576,
  0.062242561862726316, 0.062210118129148465, 0.062177836145863606,
  0.06214571503310633, 0.062113753919011416, 0.062081951939437455,
  0.06205030823801389, 0.06201882196584685, 0.06198749228161023,
  0.061956318351521086, 0.061925299349000644, 0.06189443445479502,
  0.06186372285686447, 0.06183316375033715, 0.061802756337256515,
  0.06177249982680757, 0.061742393434853, 0.0617124363843372,
  0.06168262790475504, 0.061652967232370404, 0.061623453610028245,
  0.061594086287133656, 0.061564864519548124, 0.061535787569546946,
  0.06150685470577585, 0.061478065203055834, 0.061449418342561964,
  0.061420913411493576, 0.0613925497031459, 0.06136432651690598,
  0.06133624315803866, 0.06130829893775519, 0.06128049317306485,
  0.06125282518680334, 0.06122529430750863, 0.06119789986929575,
  0.06117064121204501, 0.06114351768101233, 0.061116528627114274,
  0.061089673406569886, 0.06106295138106659, 0.06103636191758544,
  0.06100990438838752, 0.060983578170928636, 0.06095738264790088,
  0.060931317207107705, 0.06090538124134826, 0.06087957414861288,
  0.06085389533166625, 0.060828344198294776, 0.06080292016125309,
  0.06077762263793505, 0.06075245105070058, 0.060727404826522474,
  0.06070248339711069, 0.060677686198821384, 0.06065301267272871,
  0.06062846226420453, 0.06060403442340973, 0.060579728604798294,
  0.06055554426738554, 0.06053148087447934, 0.06050753789374648,
  0.060483714797252994, 0.06046001106122737, 0.06043642616616172,
  0.060412959596814, 0.06038961084197704, 0.0603663793946507,
  0.060343264751814084, 0.06032026641454295, 0.06029738388794945,
  0.060274616681068455, 0.060251964306848836, 0.06022942628211834,
  0.060207002127615934, 0.060184691367916175, 0.0601624935312951,
  0.060140408149829475, 0.06011843475936624, 0.06009657289936387,
  0.06007482211298177, 0.06005318194695415, 0.06003165195168785,
  0.060010231681018725, 0.0599889206924714, 0.05996771854695204,
  0.05994662480883775, 0.05992563904601103, 0.05990476082968243,
  0.0598839897345006, 0.059863325338397735, 0.059842767222676646,
  0.05982231497191839, 0.05980196817394342, 0.05978172641982191,
  0.059761589303823845, 0.059741556423428564, 0.05972162737918552,
  0.05970180177488656, 0.05968207921731038, 0.059662459316367066,
  0.059642941684987835, 0.059623525939172084, 0.05960421169782944,
  0.05958499858294826, 0.0595658862193565, 0.059546874234895554,
  0.05952796226022092, 0.05950914992893329, 0.05949043687741756,
  0.05947182274496036, 0.05945330717362189, 0.05943488980818063,
  0.059416570296266596, 0.05939834828820251, 0.059380223437001306,
  0.0593621953984663, 0.0593442638309293, 0.05932642839548702,
  0.05930868875580193, 0.05929104457818197, 0.059273495531503656,
  0.05925604128720099, 0.05923868151926951, 0.0592214159042339,
  0.05920424412112098, 0.05918716585142636, 0.05917018077913672,
  0.05915328859068364, 0.0591364889749574, 0.059119781623168756,
  0.05910316622901802, 0.05908664248853217, 0.059070210100125045,
  0.0590538687645044, 0.059037618184726935, 0.05902145806616549,
  0.05900538811646233, 0.0589894080455006, 0.058973517565486015,
  0.0589577163907825, 0.05894200423802856, 0.058926380826019975,
  0.05891084587578609, 0.058895399110509575, 0.05888004025549695,
  0.05886476903821807, 0.05884958518825984, 0.058834488437348315,
  0.05881947851924289, 0.058804555169825135, 0.05878971812700056,
  0.05877496713077991, 0.05876030192315397, 0.05874572224813889,
  0.05873122785177038, 0.05871681848210175, 0.058702493889099115,
  0.058688253824700734, 0.05867409804286028, 0.058660026299371254,
  0.058646038352039055, 0.058632133960510535, 0.0586183128863552,
  0.05860457489303026, 0.05859091974583922, 0.05857734721197465,
  0.05856385706043636, 0.05855044906208519, 0.05853712298957769,
  0.05852387861739542, 0.05851071572181251, 0.058497634080868874,
  0.05848463347441115, 0.058471713683999775, 0.05845887449297595,
  0.058446115686408104, 0.058433437051096826, 0.058420838375530006,
  0.058408319449929996, 0.05839588006619961, 0.05838352001792117,
  0.05837123910034641, 0.05835903711039093, 0.05834691384660541,
  0.05833486910921197, 0.05832290270001416, 0.05831101442247716,
  0.05829920408165224, 0.05828747148420208, 0.058275816438354305,
  0.05826423875393805, 0.058252738242348924, 0.0582413147165212,
  0.05822996799097092, 0.058218697881733485, 0.05820750420638072,
  0.058196386784009596, 0.05818534543521123, 0.058174379982110405,
  0.058163490248324505, 0.05815267605892444, 0.05814193724049759,
  0.058131273621070643, 0.05812068503016272, 0.05811017129871258,
  0.05809973225911564, 0.05808936774520863, 0.05807907759227168,
  0.05806886163695695, 0.05805871971737513, 0.05804865167301118,
  0.05803865734475844, 0.05802873657490468, 0.05801888920710664,
  0.058009115086391054, 0.05799941405916628, 0.05798978597317926,
  0.05798023067754778, 0.057970748022725234, 0.05796133786050152,
  0.057952000043972884, 0.057942734427604455, 0.05793354086714075,
  0.05792441921963837, 0.057915369343480454, 0.057906391098315003,
  0.057897484345102626, 0.05788864894606571, 0.057879884764713986,
  0.05787119166581856, 0.057862569515430846, 0.05785401818082923,
  0.0578455375305773, 0.0578371274344541, 0.05782878776349973,
  0.057820518389950656, 0.057812319187314505, 0.057804190030282906,
  0.057796130794795564, 0.057788141357969676, 0.05778022159814321,
  0.05777237139483286, 0.05776459062878086, 0.05775687918188575,
  0.057749236937249045, 0.05774166377911576, 0.05773415959294657,
  0.05772672426533649, 0.057719357684036174, 0.05771205973797862,
  0.057704830317228444, 0.057697669312984146, 0.05769057661761901,
  0.05768355212461218, 0.05767659572858732, 0.057669707325277514,
  0.05766288681155726, 0.057656134085410024, 0.0576494490459217,
  0.057642831593312426, 0.05763628162886292, 0.057629799054997356,
  0.05762338377519677, 0.05761703569406125, 0.05761075471726456,
  0.05760454075154702, 0.057598393704747675, 0.05759231348576999,
  0.057586300004595255, 0.057580353172265716, 0.05757447290086584,
  0.05756865910357475, 0.05756291169459325, 0.057557230589182905,
  0.05755161570365774, 0.05754606695537101, 0.05754058426271115,
  0.057535167545096993, 0.05752981672298315, 0.05752453171787429,
  0.05751931245227132, 0.057514158849710194, 0.057509070834723945,
  0.05750404833289998, 0.05749909127081819, 0.05749419957604303,
  0.05748937317718181, 0.057484612003831134, 0.05747991598658103,
  0.057475285057013645, 0.0574707191477269, 0.05746621819228876,
  0.05746178212526547, 0.057457410882193784, 0.057453104399603966,
  0.05744886261501845, 0.057444685466912074, 0.057440572894739944,
  0.05743652483894419, 0.05743254124091958, 0.05742862204303405,
  0.05742476718861361, 0.057420976621944814, 0.05741725028830257,
  0.057413588133869986, 0.057409990105818716, 0.057406456152274986,
  0.05740298622228627, 0.05739958026587573, 0.05739623823400693,
  0.05739296007857586, 0.0573897457524254, 0.05738659520934968,
  0.057383508404065316, 0.05738048529223422, 0.05737752583045264,
  0.057374629976234645, 0.05737179768805104, 0.057369028925271764,
  0.05736632364821695, 0.057363681818125234, 0.0573611033971483,
  0.05735858834837923, 0.05735613663581293, 0.05735374822438376,
  0.05735142307992416, 0.0573491611691829, 0.05734696245984434,
  0.057344826920488104, 0.05734275452061046, 0.057340745230616906,
  0.05733879902183305, 0.05733691586648032, 0.05733509573768993,
  0.05733333860949804, 0.05733164445685391, 0.05733001325560759,
  0.05732844498250665, 0.05732693961520193, 0.05732549713226403,
  0.05732411751312537, 0.05732280073815264, 0.05732154678859092,
  0.0573203556466105, 0.05731922729523333, 0.057318161718416645,
  0.05731715890099447, 0.0573162188287108, 0.057315341488187926,
  0.05731452686695306, 0.0573137749534129, 0.057313085736891346,
  0.057312459207581254, 0.05731189535657482, 0.057311394175850544,
  0.0573109556583079, 0.05731057979769629, 0.0573102665886815,
  0.05731001602680152, 0.057309828108517175, 0.05730970283113539,
  0.05730964019289649, 0.05730964019289649, 0.05730970283113539,
  0.057309828108517175, 0.05731001602680152, 0.0573102665886815,
  0.05731057979769629, 0.0573109556583079, 0.057311394175850544,
  0.05731189535657482, 0.057312459207581254, 0.057313085736891346,
  0.0573137749534129, 0.05731452686695306, 0.057315341488187926,
  0.0573162188287108, 0.05731715890099447, 0.057318161718416645,
  0.05731922729523333, 0.0573203556466105, 0.05732154678859092,
  0.05732280073815264, 0.05732411751312537, 0.05732549713226403,
  0.05732693961520193, 0.05732844498250665, 0.05733001325560759,
  0.05733164445685391, 0.05733333860949804, 0.05733509573768993,
  0.05733691586648032, 0.05733879902183305, 0.057340745230616906,
  0.05734275452061046, 0.057344826920488104, 0.05734696245984434,
  0.0573491611691829, 0.05735142307992416, 0.05735374822438376,
  0.05735613663581293, 0.05735858834837923, 0.0573611033971483,
  0.057363681818125234, 0.05736632364821695, 0.057369028925271764,
  0.05737179768805104, 0.057374629976234645, 0.05737752583045264,
  0.05738048529223422, 0.057383508404065316, 0.05738659520934968,
  0.0573897457524254, 0.05739296007857586, 0.05739623823400693,
  0.05739958026587573, 0.05740298622228627, 0.057406456152274986,
  0.057409990105818716, 0.057413588133869986, 0.05741725028830257,
  0.057420976621944814, 0.05742476718861361, 0.05742862204303405,
  0.05743254124091958, 0.05743652483894419, 0.057440572894739944,
  0.057444685466912074, 0.05744886261501845, 0.057453104399603966,
  0.057457410882193784, 0.05746178212526547, 0.05746621819228876,
  0.0574707191477269, 0.057475285057013645, 0.05747991598658103,
  0.057484612003831134, 0.05748937317718181, 0.05749419957604303,
  0.05749909127081819, 0.05750404833289998, 0.057509070834723945,
  0.057514158849710194, 0.05751931245227132, 0.05752453171787429,
  0.05752981672298315, 0.057535167545096993, 0.05754058426271115,
  0.05754606695537101, 0.05755161570365774, 0.057557230589182905,
  0.05756291169459325, 0.05756865910357475, 0.05757447290086584,
  0.057580353172265716, 0.057586300004595255, 0.05759231348576999,
  0.057598393704747675, 0.05760454075154702, 0.05761075471726456,
  0.05761703569406125, 0.05762338377519677, 0.057629799054997356,
  0.05763628162886292, 0.057642831593312426, 0.0576494490459217,
  0.057656134085410024, 0.05766288681155726, 0.057669707325277514,
  0.05767659572858732, 0.05768355212461218, 0.05769057661761901,
  0.057697669312984146, 0.057704830317228444, 0.05771205973797862,
  0.057719357684036174, 0.05772672426533649, 0.05773415959294657,
  0.05774166377911576, 0.057749236937249045, 0.05775687918188575,
  0.05776459062878086, 0.05777237139483286, 0.05778022159814321,
  0.057788141357969676, 0.057796130794795564, 0.057804190030282906,
  0.057812319187314505, 0.057820518389950656, 0.05782878776349973,
  0.0578371274344541, 0.0578455375305773, 0.05785401818082923,
  0.057862569515430846, 0.05787119166581856, 0.057879884764713986,
  0.05788864894606571, 0.057897484345102626, 0.057906391098315003,
  0.057915369343480454, 0.05792441921963837, 0.05793354086714075,
  0.057942734427604455, 0.057952000043972884, 0.05796133786050152,
  0.057970748022725234, 0.05798023067754778, 0.05798978597317926,
  0.05799941405916628, 0.058009115086391054, 0.05801888920710664,
  0.05802873657490468, 0.05803865734475844, 0.05804865167301118,
  0.05805871971737513, 0.05806886163695695, 0.05807907759227168,
  0.05808936774520863, 0.05809973225911564, 0.05811017129871258,
  0.05812068503016272, 0.058131273621070643, 0.05814193724049759,
  0.05815267605892444, 0.058163490248324505, 0.058174379982110405,
  0.05818534543521123, 0.058196386784009596, 0.05820750420638072,
  0.058218697881733485, 0.05822996799097092, 0.0582413147165212,
  0.058252738242348924, 0.05826423875393805, 0.058275816438354305,
  0.05828747148420208, 0.05829920408165224, 0.05831101442247716,
  0.05832290270001416, 0.05833486910921197, 0.05834691384660541,
  0.05835903711039093, 0.05837123910034641, 0.05838352001792117,
  0.05839588006619961, 0.058408319449929996, 0.058420838375530006,
  0.058433437051096826, 0.058446115686408104, 0.05845887449297595,
  0.058471713683999775, 0.05848463347441115, 0.058497634080868874,
  0.05851071572181251, 0.05852387861739542, 0.05853712298957769,
  0.05855044906208519, 0.05856385706043636, 0.05857734721197465,
  0.05859091974583922, 0.05860457489303026, 0.0586183128863552,
  0.058632133960510535, 0.058646038352039055, 0.058660026299371254,
  0.05867409804286028, 0.058688253824700734, 0.058702493889099115,
  0.05871681848210175, 0.05873122785177038, 0.05874572224813889,
  0.05876030192315397, 0.05877496713077991, 0.05878971812700056,
  0.058804555169825135, 0.05881947851924289, 0.058834488437348315,
  0.05884958518825984, 0.05886476903821807, 0.05888004025549695,
  0.058895399110509575, 0.05891084587578609, 0.058926380826019975,
  0.05894200423802856, 0.0589577163907825, 0.058973517565486015,
  0.0589894080455006, 0.05900538811646233, 0.05902145806616549,
  0.059037618184726935, 0.0590538687645044, 0.059070210100125045,
  0.05908664248853217, 0.05910316622901802, 0.059119781623168756,
  0.0591364889749574, 0.05915328859068364, 0.05917018077913672,
  0.05918716585142636, 0.05920424412112098, 0.0592214159042339,
  0.05923868151926951, 0.05925604128720099, 0.059273495531503656,
  0.05929104457818197, 0.05930868875580193, 0.05932642839548702,
  0.0593442638309293, 0.0593621953984663, 0.059380223437001306,
  0.05939834828820251, 0.059416570296266596, 0.05943488980818063,
  0.05945330717362189, 0.05947182274496036, 0.05949043687741756,
  0.05950914992893329, 0.05952796226022092, 0.059546874234895554,
  0.0595658862193565, 0.05958499858294826, 0.05960421169782944,
  0.059623525939172084, 0.059642941684987835, 0.059662459316367066,
  0.05968207921731038, 0.05970180177488656, 0.05972162737918552,
  0.059741556423428564, 0.059761589303823845, 0.05978172641982191,
  0.05980196817394342, 0.05982231497191839, 0.059842767222676646,
  0.059863325338397735, 0.0598839897345006, 0.05990476082968243,
  0.05992563904601103, 0.05994662480883775, 0.05996771854695204,
  0.0599889206924714, 0.060010231681018725, 0.06003165195168785,
  0.06005318194695415, 0.06007482211298177, 0.06009657289936387,
  0.06011843475936624, 0.060140408149829475, 0.0601624935312951,
  0.060184691367916175, 0.060207002127615934, 0.06022942628211834,
  0.060251964306848836, 0.060274616681068455, 0.06029738388794945,
  0.06032026641454295, 0.060343264751814084, 0.0603663793946507,
  0.06038961084197704, 0.060412959596814, 0.06043642616616172,
  0.06046001106122737, 0.060483714797252994, 0.06050753789374648,
  0.06053148087447934, 0.06055554426738554, 0.060579728604798294,
  0.06060403442340973, 0.06062846226420453, 0.06065301267272871,
  0.060677686198821384, 0.06070248339711069, 0.060727404826522474,
  0.06075245105070058, 0.06077762263793505, 0.06080292016125309,
  0.060828344198294776, 0.06085389533166625, 0.06087957414861288,
  0.06090538124134826, 0.060931317207107705, 0.06095738264790088,
  0.060983578170928636, 0.06100990438838752, 0.06103636191758544,
  0.06106295138106659, 0.061089673406569886, 0.061116528627114274,
  0.06114351768101233, 0.06117064121204501, 0.06119789986929575,
  0.06122529430750863, 0.06125282518680334, 0.06128049317306485,
  0.06130829893775519, 0.06133624315803866, 0.06136432651690598,
  0.0613925497031459, 0.061420913411493576, 0.061449418342561964,
  0.061478065203055834, 0.06150685470577585, 0.061535787569546946,
  0.061564864519548124, 0.061594086287133656, 0.061623453610028245,
  0.061652967232370404, 0.06168262790475504, 0.0617124363843372,
  0.061742393434853, 0.06177249982680757, 0.061802756337256515,
  0.06183316375033715, 0.06186372285686447, 0.06189443445479502,
  0.061925299349000644, 0.061956318351521086, 0.06198749228161023,
  0.06201882196584685, 0.06205030823801389, 0.062081951939437455,
  0.062113753919011416, 0.06214571503310633, 0.062177836145863606,
  0.062210118129148465, 0.062242561862726316, 0.062275168234285576,
  0.062307938139461325, 0.0623408724821251, 0.06237397217435717,
  0.062407238136437254, 0.062440671297112914, 0.06247427259366576,
  0.0625080429718414, 0.06254198338615564, 0.0625760947999001,
  0.06261037818526756, 0.06264483452334677, 0.06267946480439648,
  0.06271427002789504, 0.0627492512025244, 0.06278440934638573,
  0.06281974548718666, 0.06285526066221242, 0.06289095591843186,
  0.06292683231277582, 0.06296289091201332, 0.06299913279305581,
  0.06303555904310122, 0.06307217075951699, 0.06310896905029359,
  0.06314595503387173, 0.0631831298393861, 0.06322049460689437,
  0.06325805048735982, 0.06329579864279233, 0.06333374024642151,
  0.06337187648294007, 0.06341020854847419, 0.06344873765079441,
  0.06348746500939827, 0.0635263918558061, 0.0635655194335576,
  0.06360484899844752, 0.06364438181842332, 0.06368411917450884,
  0.06372406235963904, 0.06376421268027828, 0.063804571455556,
  0.06384514001772763, 0.06388591971253849, 0.06392691189916926,
  0.06396811795053678, 0.06400953925318555, 0.06405117720782735,
  0.06409303322953425, 0.06413510874744996, 0.06417740520554428,
  0.06421992406227739, 0.06426266679131559, 0.0643056348813906,
  0.06434882983641668, 0.06439225317621233, 0.06443590643577007,
  0.06447979116651908, 0.06452390893596882, 0.06456826132782363,
  0.06461284994243066, 0.06465767639704502, 0.06470274232601218,
  0.0647480493806605, 0.06479359923014433, 0.06483939356103942,
  0.06488543407816452, 0.06493172250445141, 0.0649782605812646,
  0.0650250500687671, 0.0650720927459428, 0.06511939041120679,
  0.06516694488245034, 0.06521475799705113, 0.065262831612795,
  0.06531116760768764, 0.06535976788023039, 0.06540863434984921,
  0.06545776895735106, 0.06550717366485953, 0.06555685045631414,
  0.06560680133774037, 0.0656570283376292, 0.0657075335072066,
  0.06575831892084968, 0.0658093866762073, 0.06586073889472537,
  0.06591237772187342, 0.06596430532766084, 0.06601652390691544,
  0.0660690356793822, 0.06612184289064758, 0.066174947811829,
  0.0662283527407914, 0.06628206000170263, 0.06633607194590566,
  0.06639039095232262, 0.06644501942752543, 0.0664999598066947,
  0.06655521455372093, 0.06661078616129519, 0.06666667715215968,
  0.06672289007889486, 0.0667794275247941, 0.06683629210388979,
  0.06689348646195661, 0.06695101327653648, 0.067008875257812,
  0.06706707514890095, 0.06712561572621205, 0.06718449980039679,
  0.06724373021664243, 0.06730330985510528, 0.06736324163188813,
  0.06742352849884065, 0.06748417344507901, 0.06754517949678,
  0.06760654971846894, 0.06766828721303215, 0.06773039512267766,
  0.06779287662944396, 0.06785573495608845, 0.06791897336644911,
  0.06798259516618448, 0.06804660370361709, 0.06811100237047892,
  0.06817579460230284, 0.06824098387949852, 0.06830657372808256,
  0.06837256772003739, 0.06843896947470625, 0.06850578265908301,
  0.06857301098905963, 0.0686406582298179, 0.06870872819713343,
  0.06877722475781645, 0.06884615183096442, 0.06891551338868247,
  0.0689853134568723, 0.06905555611651193, 0.06912624550459714,
  0.0691973858147497, 0.06926898129859904, 0.06934103626664846,
  0.06941355508944382, 0.06948654219874285, 0.06956000208814096,
  0.06963393931470767, 0.0697083584999752, 0.06978326433110003,
  0.06985866156210267, 0.06993455501502713, 0.0700109495812948,
  0.07008785022303576, 0.07016526197422795, 0.07024318994209426,
  0.07032163930887161, 0.07040061533257472, 0.07048012334889295,
  0.07056016877256552, 0.07064075709893715, 0.07072189390564018,
  0.07080358485355366, 0.07088583568922371, 0.07096865224648805,
  0.071052040446984, 0.07113600630414924, 0.07122055592248036,
  0.07130569550124372, 0.07139143133571327, 0.07147776981861285,
  0.07156471744317455, 0.0716522808041679, 0.07174046660033274,
  0.07182928163681052, 0.07191873282704178, 0.07200882719507291,
  0.07209957187739956, 0.07219097412615842, 0.07228304131117161,
  0.07237578092193502, 0.07246920057129719, 0.07256330799676602,
  0.07265811106393154, 0.0727536177695563, 0.07284983624329901,
  0.07294677475176947, 0.07304444170072161, 0.07314284563834851,
  0.07324199525886514, 0.07334189940496766, 0.07344256707123759,
  0.0735440074083847, 0.07364622972617024, 0.07374924349648006,
  0.07385305835826679, 0.07395768412014925, 0.07406313076494245,
  0.07416940845387826, 0.07427652752991684, 0.07438449852287148,
  0.07449333215311961, 0.07460303933733504, 0.0747136311907832,
  0.0748251190343337, 0.07493751439885658, 0.07505082902932042,
  0.07516507489144102, 0.0752802641753062, 0.07539640930265773,
  0.07551352293159026, 0.07563161796244051, 0.07575070754432163,
  0.0758708050812111, 0.07599192423777111, 0.07611407894706386,
  0.07623728341598315, 0.07636155213404133, 0.07648689987927863,
  0.07661334172595152, 0.07674089305329578, 0.07686956955249888,
  0.07699938723490778, 0.07713036244135019, 0.07726251185059116,
  0.07739585248829535, 0.07753040173650198, 0.07766617734369033,
  0.07780319743408812, 0.07794148051872928, 0.07808104550660151,
  0.07822191171459207, 0.07836409887963512, 0.07850762717143787,
  0.07865251720308553, 0.0787987900452287, 0.07894646723863978,
  0.07909557080823244, 0.07924612327722888, 0.0793981476820025,
  0.07955166758663282, 0.07970670709946451, 0.07986329088955597,
  0.08002144420274408, 0.08018119288080275, 0.0803425633782808,
  0.08050558278248804, 0.08067027883263767, 0.08083667994158816,
  0.08100481521504703, 0.08117471447535055, 0.08134640828427941,
  0.08151992796687017, 0.08169530563589425, 0.08187257421821456,
  0.08205176748191588, 0.08223292006432227, 0.08241606750003366,
  0.08260124625359619, 0.08278849374988154, 0.08297784840687716,
  0.08316934967084066, 0.0833630380522295, 0.0835589551638577,
  0.08375714375842327, 0.08395764777044173, 0.08416051235934185,
  0.08436578395404308, 0.08457351029882272, 0.08478374050284093,
  0.08499652509076279, 0.08521191605655698, 0.08542996691980542,
  0.08565073278304056, 0.0858742703939818, 0.08610063821088505,
  0.0863298964665416, 0.0865621072430484, 0.08679733454365546,
  0.08703564437176525, 0.08727710481219045, 0.08752178611655628,
  0.08776976079520621, 0.0880211037119185, 0.08827589218342669,
  0.08853420608482916, 0.08879612796147152, 0.0890617431445232,
  0.08933113987558143, 0.08960440943728767, 0.08988164628908217,
  0.09016294821199165, 0.09044841646512801, 0.09073815594429689,
  0.09103227535664357, 0.09133088739787532, 0.0916341089505213,
  0.09194206128273988, 0.09225487026677055, 0.09257266660975222,
  0.09289558609346668, 0.09322376983864708, 0.09355736457561047,
  0.09389652294166041, 0.09424140378977827, 0.09459217252378982,
  0.09494900145370064, 0.09531207017224008, 0.09568156596319645,
  0.09605768423134357, 0.09644062896864734, 0.09683061324818976,
  0.09722785975803222, 0.09763260137195404, 0.09804508176173332,
  0.09846555605786883, 0.09889429155943263, 0.09933156849706454,
  0.09977768085909958, 0.10023293728066235, 0.10069766200541516,
  0.10117219592764994, 0.10165689772007491, 0.10215214505534585,
  0.10265833593625949, 0.10317589013836426, 0.10370525078497772,
  0.10424688605833059, 0.10480129107816961, 0.10536898994389694,
  0.10595053797854054, 0.10654652419097209, 0.10715757397680346,
  0.10778435209350773, 0.10842756593906401, 0.10908796917674628,
  0.10976636574119807, 0.11046361428324351, 0.11118063311032408,
  0.11191840567768785, 0.11267798673375132, 0.1134605091688146,
  0.11426719171846339, 0.11509934759939439, 0.1159583942551442,
  0.11684586436446308, 0.11776341831361917, 0.11871285836709539,
  0.11969614484349853, 0.12071541459598996, 0.12177300224310428,
  0.12287146462499367, 0.12401360908268529, 0.12520252631296663,
  0.12644162868537906, 0.12773469512487529, 0.12908592398252508,
  0.13049999558554157, 0.13198214669807298, 0.13353825963655888,
  0.1351749696262274, 0.13689979502138885, 0.13872129634891353,
  0.1406492721626895, 0.14269500220754397, 0.14487155217180486,
  0.14719415938604596, 0.14968072645243646, 0.1523524605408998,
  0.15523471242947257, 0.1583580940186295, 0.16175999128288557,
  0.16548665072122593, 0.16959611701205476, 0.17416246859778775,
  0.17928209342441523, 0.18508328778673924, 0.1917414980133161,
  0.19950463254617876, 0.2087374637630829, 0.22000503548177544,
  0.23424380680372367, 0.25315713324910166, 0.2802986015980284,
  0.3249567967276586, 0.42569184393634385
  };

// ********************************************************
//   field x globals
// vector wavefunction globals
size_t _x_wavefunction_alloc_size = 0;
complex* _x_wavefunction = NULL;
complex* _active_x_wavefunction = NULL;

ptrdiff_t _x_wavefunction_basis = -1;

// vector driving_noise globals
size_t _x_driving_noise_alloc_size = 0;
complex* _x_driving_noise = NULL;
complex* _active_x_driving_noise = NULL;

ptrdiff_t _x_driving_noise_basis = -1;

uint32_t _gen_driving_noise_seeds[10];
dsfmt_t* _gen_driving_noise;

// vector pos_space_terms globals
size_t _x_pos_space_terms_alloc_size = 0;
complex* _x_pos_space_terms = NULL;
complex* _active_x_pos_space_terms = NULL;

ptrdiff_t _x_pos_space_terms_basis = -1;

// ********************************************************
//   Stochastic globals
real* _dkx_array_invsqrt = (real*) xmds_malloc(sizeof(real) * (_lattice_kx));

// ********************************************************
//   segment 1 (SI fixed-step integrator) globals
complex* _segment1_oldCopy_x_wavefunction;

// vector segment1_x_operators_operator0_field globals
size_t _x_segment1_x_operators_operator0_field_alloc_size = 0;
complex* _x_segment1_x_operators_operator0_field = NULL;
complex* _active_x_segment1_x_operators_operator0_field = NULL;

// ********************************************************
//   segment 2 (Breakpoint) globals
long _breakpointAutoNameCounter = 0;

// ********************************************************
//   segment 4 (RK89 adaptive-step integrator) globals
complex* _segment4_akafield_x_wavefunction;
complex* _segment4_akbfield_x_wavefunction;
complex* _segment4_akcfield_x_wavefunction;
complex* _segment4_akdfield_x_wavefunction;
complex* _segment4_akefield_x_wavefunction;
complex* _segment4_akffield_x_wavefunction;
complex* _segment4_akgfield_x_wavefunction;
complex* _segment4_akhfield_x_wavefunction;
complex* _segment4_akifield_x_wavefunction;
complex* _segment4_akjfield_x_wavefunction;
complex* _segment4_initial_x_wavefunction;

real _segment4_x_operators_operator0_last_timestep_size_map[14];

// vector segment4_x_operators_operator0_field globals
size_t _x_segment4_x_operators_operator0_field_alloc_size = 0;
complex* _x_segment4_x_operators_operator0_field = NULL;
complex* _active_x_segment4_x_operators_operator0_field = NULL;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;

// vector processed globals
size_t _mg0_output_processed_alloc_size = 0;
real* _mg0_output_processed = NULL;
real* _active_mg0_output_processed = NULL;
real* _mg0_output_sd = NULL;

// ********************************************************
//   field mg1_output globals
real* _mg1_output_t = NULL;
unsigned long _mg1_output_index_t = 0;

// vector processed globals
size_t _mg1_output_processed_alloc_size = 0;
real* _mg1_output_processed = NULL;
real* _active_mg1_output_processed = NULL;
real* _mg1_output_sd = NULL;

// vector raw globals
size_t _mg1_output_raw_alloc_size = 0;
real* _mg1_output_raw = NULL;
real* _active_mg1_output_raw = NULL;

// ********************************************************
//   field mg2_output globals
real* _mg2_output_t = NULL;
unsigned long _mg2_output_index_t = 0;

// vector processed globals
size_t _mg2_output_processed_alloc_size = 0;
real* _mg2_output_processed = NULL;
real* _active_mg2_output_processed = NULL;
real* _mg2_output_sd = NULL;

// vector raw globals
size_t _mg2_output_raw_alloc_size = 0;
real* _mg2_output_raw = NULL;
real* _active_mg2_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Transform Multiplexer function prototypes
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice);

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field x function prototypes
void _x_wavefunction_initialise();
void _x_wavefunction_basis_transform(ptrdiff_t new_basis);

void _x_driving_noise_basis_transform(ptrdiff_t new_basis);
void _x_driving_noise_evaluate(real _step);
void _x_driving_noise_split(real _new_step, real _old_step, complex* _old_array);

void _x_pos_space_terms_initialise();
void _x_pos_space_terms_basis_transform(ptrdiff_t new_basis);
void _x_pos_space_terms_evaluate();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (SI fixed-step integrator) function prototypes
void _segment1();
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_ip_evolve(int _exponent);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);

void _segment1_x_operators_calculate_operator0_field();

void _segment1_x_operators_evaluate_operator1(real _step);

// ********************************************************
//   segment 2 (Breakpoint) function prototypes
void _segment2();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   segment 3 (Filter) function prototypes
void _segment3();

void _segment3__evaluate_operator0();

// ********************************************************
//   segment 4 (RK89 adaptive-step integrator) function prototypes
void _segment4();
inline void _segment4_calculate_delta_a(real _step);
inline void _segment4_ip_evolve(int _exponent);
inline void _segment4_calculate_nonconstant_ip_fields(real _step, int _exponent);
real _segment4_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter);
real _segment4_x_wavefunction_timestep_error(complex* _checkfield);
bool _segment4_x_wavefunction_reset(complex* _reset_to);

void _segment4_x_operators_calculate_operator0_field(real _step, int _exponent);

void _segment4_x_operators_evaluate_operator1(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

void _mg0_output_processed_initialise();

// ********************************************************
//   moment group 1 function prototypes
void _mg1_sample();
void _mg1_process();
void _mg1_write_out(FILE* _outfile);

// ********************************************************
//   field mg1_output function prototypes
void _mg1_output_processed_initialise();

void _mg1_output_raw_initialise();

// ********************************************************
//   moment group 2 function prototypes
void _mg2_sample();
void _mg2_process();
void _mg2_write_out(FILE* _outfile);

// ********************************************************
//   field mg2_output function prototypes
void _mg2_output_processed_initialise();

void _mg2_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &_rank);
  
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'th_spgpe_spectral' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"chi", required_argument, 0, 'c'},
        {"omega_bar", required_argument, 0, 'o'},
        {"k0", required_argument, 0, 'k'},
        {"tl", required_argument, 0, 't'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hc:o:k:t:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'c':
        chi = strtod(optarg, NULL);
        break;
      
      case 'o':
        omega_bar = strtod(optarg, NULL);
        break;
      
      case 'k':
        k0 = strtod(optarg, NULL);
        break;
      
      case 't':
        tl = strtod(optarg, NULL);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  #line 31 "th_spgpe_spectral.xmds"
  
  R_tilde = sqrt(2.0)*1/(pow(chi,1.0/3.0)*omega_bar);
  rho0_tilde = pow(chi,-2.0/3.0);
  kth = 0.17;
  t_lim = tl*2*M_PI/omega_bar;
  t_lim_gs = log(5)/(omega_bar*1.0);
  sgT = sqrt(2.0* kth);
  mu=rho0_tilde;  
  
  #line 1748 "th_spgpe_spectral.cc"
  // **********************************************
  
    
  
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_kx) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_x) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_nx) * _x_wavefunction_ncomponents);
  _x_wavefunction_alloc_size = MAX(_x_wavefunction_alloc_size, (_lattice_x_4f) * _x_wavefunction_ncomponents);
  _mg1_output_raw_alloc_size = MAX(_mg1_output_raw_alloc_size, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_raw_ncomponents);
  _mg2_output_raw_alloc_size = MAX(_mg2_output_raw_alloc_size, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_raw_ncomponents);
  _mg1_output_processed_alloc_size = MAX(_mg1_output_processed_alloc_size, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents);
  _x_pos_space_terms_alloc_size = MAX(_x_pos_space_terms_alloc_size, (_lattice_x) * _x_pos_space_terms_ncomponents);
  _x_pos_space_terms_alloc_size = MAX(_x_pos_space_terms_alloc_size, (_lattice_x_4f) * _x_pos_space_terms_ncomponents);
  _x_driving_noise_alloc_size = MAX(_x_driving_noise_alloc_size, (_lattice_kx) * _x_driving_noise_ncomponents);
  _x_driving_noise_alloc_size = MAX(_x_driving_noise_alloc_size, (_lattice_x) * _x_driving_noise_ncomponents);
  _mg0_output_processed_alloc_size = MAX(_mg0_output_processed_alloc_size, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents);
  _mg2_output_processed_alloc_size = MAX(_mg2_output_processed_alloc_size, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents);
  _x_segment4_x_operators_operator0_field_alloc_size = MAX(_x_segment4_x_operators_operator0_field_alloc_size, (_lattice_nx) * _x_segment4_x_operators_operator0_field_ncomponents);
  _x_segment1_x_operators_operator0_field_alloc_size = MAX(_x_segment1_x_operators_operator0_field_alloc_size, (_lattice_nx) * _x_segment1_x_operators_operator0_field_ncomponents);
  _x = (real*) xmds_malloc(sizeof(real) * (_lattice_x+1));
  
  _nx = (long*) xmds_malloc(sizeof(long) * (_lattice_nx+1));
  
  _kx = (real*) xmds_malloc(sizeof(real) * (_lattice_kx+1));
  
  _nx_twiddle = (long*) xmds_malloc(sizeof(long) * (_lattice_nx_twiddle+1));
  
  _x_4f = (real*) xmds_malloc(sizeof(real) * (_lattice_x_4f+1));
  
  _x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _active_x_wavefunction = _x_wavefunction;
  
  
  _x_driving_noise = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_driving_noise_alloc_size,1));
  _active_x_driving_noise = _x_driving_noise;
  
  
  _x_pos_space_terms = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_pos_space_terms_alloc_size,1));
  _active_x_pos_space_terms = _x_pos_space_terms;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  _mg0_output_processed = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_processed_alloc_size,1));
  _active_mg0_output_processed = _mg0_output_processed;
  _mg0_output_sd = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_processed_alloc_size,1)); // alias for _mg0_output_processed
  _mg1_output_t = (real*) xmds_malloc(sizeof(real) * (_mg1_output_lattice_t+1));
  
  
  _mg1_output_processed = (real*) xmds_malloc(sizeof(real) * MAX(_mg1_output_processed_alloc_size,1));
  _active_mg1_output_processed = _mg1_output_processed;
  _mg1_output_sd = (real*) xmds_malloc(sizeof(real) * MAX(_mg1_output_processed_alloc_size,1)); // alias for _mg1_output_processed
  
  
  _mg1_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg1_output_raw_alloc_size,1));
  _active_mg1_output_raw = _mg1_output_raw;
  _mg2_output_t = (real*) xmds_malloc(sizeof(real) * (_mg2_output_lattice_t+1));
  
  
  _mg2_output_processed = (real*) xmds_malloc(sizeof(real) * MAX(_mg2_output_processed_alloc_size,1));
  _active_mg2_output_processed = _mg2_output_processed;
  _mg2_output_sd = (real*) xmds_malloc(sizeof(real) * MAX(_mg2_output_processed_alloc_size,1)); // alias for _mg2_output_processed
  
  
  _mg2_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg2_output_raw_alloc_size,1));
  _active_mg2_output_raw = _mg2_output_raw;
  
  
  // Run-time validation checks
  
  if (0 >= sqrt(1/(omega_bar)))
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'sqrt(1/(omega_bar))' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)0, (real)sqrt(1/(omega_bar)));
  
  if (t_lim_gs <= 0.0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The interval for segment 1 is not positive!\n"
                           "Interval = %e\n", t_lim_gs);
  
  if (t_lim <= 0.0)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The interval for segment 4 is not positive!\n"
                           "Interval = %e\n", t_lim);
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    _x[_index_x] = _hermite_zeros_x[_index_x] * sqrt(1/(omega_bar)) / sqrt(1.0);
    _dx_array[_index_x] = _hermite_gauss_weights_x[_index_x] * sqrt(1/(omega_bar)) / sqrt(1.0);
  }
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++)
    _nx[_index_nx] = _min_nx + _index_nx*_dnx;
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    _kx[_index_kx] = _hermite_zeros_x[_index_kx] * (1.0 / (sqrt(1/(omega_bar)))) / sqrt(1.0);
    _dkx_array[_index_kx] = _hermite_gauss_weights_x[_index_kx] * (1.0 / (sqrt(1/(omega_bar)))) / sqrt(1.0);
  }
  for (long _index_nx_twiddle = 0; _index_nx_twiddle < _lattice_nx_twiddle; _index_nx_twiddle++)
    _nx_twiddle[_index_nx_twiddle] = _min_nx_twiddle + _index_nx_twiddle*_dnx_twiddle;
  for (long _index_x_4f = 0; _index_x_4f < _lattice_x_4f; _index_x_4f++) {
    _x_4f[_index_x_4f] = _hermite_zeros_x[_index_x_4f] * sqrt(1/(omega_bar)) / sqrt(2.0);
    _dx_4f_array[_index_x_4f] = _hermite_gauss_weights_x[_index_x_4f] * sqrt(1/(omega_bar)) / sqrt(2.0);
  }
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  _active_mg0_output_processed = _mg0_output_sd;
  _mg0_output_processed_initialise();
  _active_mg0_output_processed = _mg0_output_processed;
  _mg0_output_processed_initialise();
  _active_mg1_output_processed = _mg1_output_sd;
  _mg1_output_processed_initialise();
  _active_mg1_output_processed = _mg1_output_processed;
  _mg1_output_processed_initialise();
  
  _active_mg1_output_raw = _mg1_output_raw;
  _mg1_output_raw_initialise();
  _active_mg2_output_processed = _mg2_output_sd;
  _mg2_output_processed_initialise();
  _active_mg2_output_processed = _mg2_output_processed;
  _mg2_output_processed_initialise();
  
  _active_mg2_output_raw = _mg2_output_raw;
  _mg2_output_raw_initialise();
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    _dkx_array_invsqrt[_index_kx] = (real)1.0/sqrt(_dkx_array[_index_kx] * (1.0));
  }
  
  #if HAVE_DEV_URANDOM
    uint32_t __seeds[10];
    FILE *__urandom_fp = fopen("/dev/urandom", "r");
  
    if (__urandom_fp == NULL) {
        _LOG(_ERROR_LOG_LEVEL, "Unable to seed random number generator from /dev/urandom.  Is it accessible?\n");
        // Implicit quit
    }
  
    size_t __entries_read = 0;
    __entries_read = fread(__seeds, sizeof(uint32_t), 10, __urandom_fp);
  
    if (__entries_read != 10) {
      _LOG(_ERROR_LOG_LEVEL, "Unable to read from /dev/urandom while seeding the random number generator.\n");
        // Implicit quit
    }
  
    fclose(__urandom_fp);
  
    for (unsigned long _i0=0; _i0 < 10; _i0++) {
      _gen_driving_noise_seeds[_i0] = (uint32_t) __seeds[_i0];
    }
  
  #else
  #error Do not have a run-time random number source! Please supply seeds manually.
  #endif
  
  
  #if defined(CBLAS_VECLIB)
  // We are using MPI. If we let vecLib spawn threads then overall performance will suffer
    setenv("VECLIB_MAXIMUM_THREADS", "1", 1);
  #endif
  
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (2 * _x_wavefunction_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_wavefunction_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_wavefunction);
  }
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 1)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 0)];
  _basis_transform->append(
    /* transform function */ _transform_1,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 2)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 0)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(0, 3)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 0)];
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 2)];
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 1)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(1, 3)];
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 1)];
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_5,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ _lattice_nx,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(2, 3)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_wavefunction_ncomponents * 2
  );
  
  _basis_transform = &_x_wavefunction_basis_map[_basis_pair(3, 2)];
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_wavefunction_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_wavefunction_alloc_size); // vector 'wavefunction' needs an out-of-place transform
  
  if (2 * _x_driving_noise_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_driving_noise_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_driving_noise);
  }
  _basis_transform = &_x_driving_noise_basis_map[_basis_pair(0, 2)];
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ false,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_driving_noise_ncomponents * 2
  );
  
  _basis_transform = &_x_driving_noise_basis_map[_basis_pair(2, 0)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_2,
    /* forward? */ true,
    /* out-of-place? */ false,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents
  );
  _basis_transform->append(
    /* transform function */ _transform_0,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_driving_noise_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_driving_noise_alloc_size); // vector 'driving_noise' needs an out-of-place transform
  
  if (2 * _x_pos_space_terms_alloc_size > _max_vector_size) {
    _max_vector_size = 2 * _x_pos_space_terms_alloc_size;
    _max_vector_array = reinterpret_cast<real*>(_x_pos_space_terms);
  }
  _basis_transform = &_x_pos_space_terms_basis_map[_basis_pair(2, 3)];
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_pos_space_terms_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice*/ _x_pos_space_terms_ncomponents * 2
  );
  
  _basis_transform = &_x_pos_space_terms_basis_map[_basis_pair(3, 2)];
  _basis_transform->append(
    /* transform function */ _transform_4,
    /* forward? */ true,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_pos_space_terms_ncomponents * 2
  );
  _basis_transform->append(
    /* transform function */ _transform_3,
    /* forward? */ false,
    /* out-of-place? */ true,
    /* prefix lattice */ 1,
    /* postfix lattice */ _x_pos_space_terms_ncomponents * 2
  );
  
  _auxiliary_array_size = MAX(_auxiliary_array_size, 2 * _x_pos_space_terms_alloc_size); // vector 'pos_space_terms' needs an out-of-place transform
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  // Get the time at which the simulation started
  timeval _tim;
  gettimeofday(&_tim, NULL);
  double _startTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  
  // Work out how long the simulation has run for
  gettimeofday(&_tim, NULL);
  double _endTime = _tim.tv_sec + (_tim.tv_usec/1e6);
  _LOG(_SIMULATION_LOG_LEVEL, "Time elapsed for simulation is: %.2f seconds\n", _endTime - _startTime);
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  // Bing!
  _LOG(_SIMULATION_LOG_LEVEL, "\a");
  
  xmds_free(_x_wavefunction);
  _active_x_wavefunction = _x_wavefunction = NULL;
  
  
  xmds_free(_x_driving_noise);
  _active_x_driving_noise = _x_driving_noise = NULL;
  
  
  xmds_free(_x_pos_space_terms);
  _active_x_pos_space_terms = _x_pos_space_terms = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  xmds_free(_mg0_output_processed);
  _active_mg0_output_processed = _mg0_output_processed = NULL;
  xmds_free(_mg0_output_sd); // alias for _mg0_output_processed
  _mg0_output_sd = NULL;
  
  xmds_free(_mg1_output_processed);
  _active_mg1_output_processed = _mg1_output_processed = NULL;
  xmds_free(_mg1_output_sd); // alias for _mg1_output_processed
  _mg1_output_sd = NULL;
  
  
  xmds_free(_mg1_output_raw);
  _active_mg1_output_raw = _mg1_output_raw = NULL;
  
  xmds_free(_mg2_output_processed);
  _active_mg2_output_processed = _mg2_output_processed = NULL;
  xmds_free(_mg2_output_sd); // alias for _mg2_output_processed
  _mg2_output_sd = NULL;
  
  
  xmds_free(_mg2_output_raw);
  _active_mg2_output_raw = _mg2_output_raw = NULL;
  
  
  MPI_Finalize();
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Transform Multiplexer function implementations
// kx <---> nx_twiddle transform
void _transform_0(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for kx <---> nx_twiddle transform...");
    
    long _even_kx = (_lattice_kx + 1)/2;
    long _odd_kx = _lattice_kx/2;
    long _even_nx_twiddle = (_lattice_nx_twiddle + 1)/2;
    long _odd_nx_twiddle = _lattice_nx_twiddle/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_kx * _even_nx_twiddle);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_kx * _odd_nx_twiddle);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx_twiddle * _even_kx);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx_twiddle * _odd_kx);
    
    for (long _i0 = 0; _i0 < _even_kx; _i0++) {
      long __i0 = _lattice_kx - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(1.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx_twiddle);
      const real expFactor2 = exp(-_root * _root / _lattice_nx_twiddle);
      const real normalisation = 1.0/sqrt((1.0 / (sqrt(1/(omega_bar)))));
      for (long _i1 = 0; _i1 < _lattice_nx_twiddle; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx_twiddle - _i1 - 1) / _lattice_nx_twiddle) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_kx) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_kx + (_odd_kx -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dkx_array[__i0];
            _mmt_matrix_backward_odd[(_odd_kx -1 - _i0) * _odd_nx_twiddle + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_kx + _i0] = \
            hermiteGauss * correctionFactor * _dkx_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx_twiddle + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_kx;
      for (long _i1 = 0; _i1 < _lattice_kx/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_kx - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx_twiddle+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_kx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_kx+1)/2,
                  /* B */ source_data + _i0 * _lattice_kx * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx_twiddle * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx_twiddle/2,
                  /* nelem */ innerLoopSize,
                  _lattice_kx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_kx/2,
                  /* B */ source_data + (_i0 * _lattice_kx + (_lattice_kx+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx_twiddle + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_kx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx_twiddle+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx_twiddle+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx_twiddle * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_kx * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_kx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx_twiddle/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx_twiddle/2,
                  /* B */ source_data + (_i0 * _lattice_nx_twiddle + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_kx + (_lattice_kx+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_kx;
      for (long _i1 = 0; _i1 < _lattice_kx/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_kx - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// nx <---> nx_twiddle transform
void _transform_1(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static const complex _forward_multipliers[4] = {1, -i, -1, i};
  static const complex _backward_multipliers[4] = {1, i, -1, -i};
  complex* const __restrict__ source_data = reinterpret_cast<complex* const>(_data_in);
  complex* const __restrict__ dest_data = reinterpret_cast<complex* const>(_data_out);
  
  const complex* const __restrict__ _multipliers = _forward ? _forward_multipliers : _backward_multipliers;
  
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
      long multiplier_index = (_i1 & 3);
      
      const complex multiplier = _multipliers[multiplier_index];
      
      #pragma ivdep
      for (long _i2 = 0; _i2 < _postfix_lattice; _i2++) {
        ptrdiff_t _index = (_i0 * _lattice_nx + _i1) * _postfix_lattice + _i2;
        dest_data[_index] = multiplier * source_data[_index];
      }
    }
  }
}


// nx <---> nx_twiddle transform
void _transform_2(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static const complex _forward_multipliers[4] = {1, -i, -1, i};
  static const complex _backward_multipliers[4] = {1, i, -1, -i};
  complex* const __restrict__ source_data = reinterpret_cast<complex* const>(_data_in);
  
  const complex* const __restrict__ _multipliers = _forward ? _forward_multipliers : _backward_multipliers;
  
  for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
    for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
      long multiplier_index = (_i1 & 3);
      if (multiplier_index == 0) continue;
      
      const complex multiplier = _multipliers[multiplier_index];
      
      #pragma ivdep
      for (long _i2 = 0; _i2 < _postfix_lattice; _i2++) {
        ptrdiff_t _index = (_i0 * _lattice_nx + _i1) * _postfix_lattice + _i2;
        source_data[_index] *= multiplier;
      }
    }
  }
}


// x <---> nx transform
void _transform_3(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for x <---> nx transform...");
    
    long _even_x = (_lattice_x + 1)/2;
    long _odd_x = _lattice_x/2;
    long _even_nx = (_lattice_nx + 1)/2;
    long _odd_nx = _lattice_nx/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_x * _even_nx);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_x * _odd_nx);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx * _even_x);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx * _odd_x);
    
    for (long _i0 = 0; _i0 < _even_x; _i0++) {
      long __i0 = _lattice_x - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(1.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx);
      const real expFactor2 = exp(-_root * _root / _lattice_nx);
      const real normalisation = 1.0/sqrt(sqrt(1/(omega_bar)));
      for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx - _i1 - 1) / _lattice_nx) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_x) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_x + (_odd_x -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dx_array[__i0];
            _mmt_matrix_backward_odd[(_odd_x -1 - _i0) * _odd_nx + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_x + _i0] = \
            hermiteGauss * correctionFactor * _dx_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x;
      for (long _i1 = 0; _i1 < _lattice_x/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_x - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_x+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_x+1)/2,
                  /* B */ source_data + _i0 * _lattice_x * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_x/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_x/2,
                  /* B */ source_data + (_i0 * _lattice_x + (_lattice_x+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_x+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_x * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_x/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx/2,
                  /* B */ source_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_x + (_lattice_x+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x;
      for (long _i1 = 0; _i1 < _lattice_x/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_x - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// x_4f <---> nx transform
void _transform_4(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  static bool _initialised = false;
  static real *_mmt_matrix_forward_even = NULL;
  static real *_mmt_matrix_forward_odd  = NULL;
  static real *_mmt_matrix_backward_even = NULL;
  static real *_mmt_matrix_backward_odd  = NULL;
  ptrdiff_t innerLoopSize = _postfix_lattice;
  real* const __restrict__ source_data = reinterpret_cast<real* const>(_data_in);
  real* const __restrict__ dest_data = reinterpret_cast<real* const>(_data_out);
  
  if (!_initialised) {
    _LOG(_SIMULATION_LOG_LEVEL, "Building matrices for x_4f <---> nx transform...");
    
    long _even_x_4f = (_lattice_x_4f + 1)/2;
    long _odd_x_4f = _lattice_x_4f/2;
    long _even_nx = (_lattice_nx + 1)/2;
    long _odd_nx = _lattice_nx/2;
    _mmt_matrix_forward_even = (real *)xmds_malloc(sizeof(real) * _even_x_4f * _even_nx);
    _mmt_matrix_forward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_x_4f * _odd_nx);
    _mmt_matrix_backward_even = (real *)xmds_malloc(sizeof(real) * _even_nx * _even_x_4f);
    _mmt_matrix_backward_odd  = (real *)xmds_malloc(sizeof(real) * _odd_nx * _odd_x_4f);
    
    for (long _i0 = 0; _i0 < _even_x_4f; _i0++) {
      long __i0 = _lattice_x_4f - 1 - _i0;
      real hermiteGaussMinusOne = 0.0;
      real hermiteGaussMinusTwo = 0.0;
      const real _root = _hermite_zeros_x[__i0] / sqrt(2.0);
      const real expFactor = exp(-0.5 * _root * _root / _lattice_nx);
      const real expFactor2 = exp(-_root * _root / _lattice_nx);
      const real normalisation = 1.0/sqrt(sqrt(1/(omega_bar)));
      for (long _i1 = 0; _i1 < _lattice_nx; _i1++) {
        real hermiteGauss;
        const real correctionFactor = exp( -0.5 * _root * _root * (_lattice_nx - _i1 - 1) / _lattice_nx) * normalisation;
        if (_i1 == 0)
          hermiteGauss = pow(M_PI, -0.25) * expFactor;
        else if (_i1 == 1)
          hermiteGauss = sqrt(2.0) * _root * hermiteGaussMinusOne * expFactor;
        else
          hermiteGauss = sqrt(2.0/_i1) * _root * hermiteGaussMinusOne * expFactor \
                         - sqrt((_i1-1.0)/_i1) * hermiteGaussMinusTwo * expFactor2;
        
        if (_i1 & 1) {
          // _i1 is odd
          if (_i0 < _odd_x_4f) {
            long __i1 = _i1/2;
            _mmt_matrix_forward_odd[__i1 * _odd_x_4f + (_odd_x_4f -1 - _i0)] = \
              hermiteGauss * correctionFactor * _dx_4f_array[__i0];
            _mmt_matrix_backward_odd[(_odd_x_4f -1 - _i0) * _odd_nx + __i1] = \
              hermiteGauss * correctionFactor;
          }
        } else {
          // _i1 is even
          long __i1 = _i1/2;
          _mmt_matrix_forward_even[__i1 * _even_x_4f + _i0] = \
            hermiteGauss * correctionFactor * _dx_4f_array[__i0];
          _mmt_matrix_backward_even[_i0 * _even_nx + __i1] = \
            hermiteGauss * correctionFactor;
        }
        
        hermiteGaussMinusTwo = hermiteGaussMinusOne;
        hermiteGaussMinusOne = hermiteGauss;
      }
    }
    
    _LOG(_SIMULATION_LOG_LEVEL, " done.\n");
    _initialised = true;
  }
  
  if (_forward) {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      // Loop to create symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x_4f;
      for (long _i1 = 0; _i1 < _lattice_x_4f/2; _i1++) {
        real* __restrict__ _low = &source_data[outerOffset + _i1 * innerLoopSize];
        real* __restrict__ _high = &source_data[outerOffset + (_lattice_x_4f - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          _low[_i2] += _high[_i2];  // _low stores the symmetric component
          _high[_i2] -= _temp; // _high stores the antisymmetric component
        }
      }
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_nx+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_x_4f+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_even, (_lattice_x_4f+1)/2,
                  /* B */ source_data + _i0 * _lattice_x_4f * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_nx * innerLoopSize,
                  2 * innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_nx/2,
                  /* nelem */ innerLoopSize,
                  _lattice_x_4f/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_forward_odd, _lattice_x_4f/2,
                  /* B */ source_data + (_i0 * _lattice_x_4f + (_lattice_x_4f+1)/2) * innerLoopSize,
                          innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                  2 * innerLoopSize);
    }
  } else {
    for (long _i0 = 0; _i0 < _prefix_lattice; _i0++) {
      const real alpha = 1.0;
      const real beta = 0.0;
      
      // Symmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  (_lattice_x_4f+1)/2,
                  /* nelem */ innerLoopSize,
                  (_lattice_nx+1)/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_even, (_lattice_nx+1)/2,
                  /* B */ source_data + _i0 * _lattice_nx * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + _i0 * _lattice_x_4f * innerLoopSize,
                  innerLoopSize);
      // Antisymmetric component of the transform
      cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                  _lattice_x_4f/2,
                  /* nelem */ innerLoopSize,
                  _lattice_nx/2,
                  /* alpha */ alpha,
                  /* A */ _mmt_matrix_backward_odd, _lattice_nx/2,
                  /* B */ source_data + (_i0 * _lattice_nx + 1) * innerLoopSize,
                          2 * innerLoopSize,
                  /* beta */ beta,
                  /* C */ dest_data + (_i0 * _lattice_x_4f + (_lattice_x_4f+1)/2) * innerLoopSize,
                  innerLoopSize);
      // Loop to unravel symmetric and antisymmetric components.
      real _temp;
      long outerOffset = _i0 * innerLoopSize * _lattice_x_4f;
      for (long _i1 = 0; _i1 < _lattice_x_4f/2; _i1++) {
        // _low stored the symmetric component
        real* __restrict__ _low = &dest_data[outerOffset + _i1 * innerLoopSize];
        // _high stored the antisymmetric component
        real* __restrict__ _high = &dest_data[outerOffset + (_lattice_x_4f - 1 - _i1) * innerLoopSize];
        for (long _i2 = 0; _i2 < innerLoopSize; _i2++) {
          _temp = _low[_i2];
          // _low is the negative domain
          _low[_i2] -= _high[_i2];
          // _high is the positive domain
          _high[_i2] += _temp;
        }
      }
    }
  }
}


// Out-of-place copy
void _transform_5(bool _forward, real _multiplier, real* const __restrict__ _data_in, real* const __restrict__ _data_out, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
{
  if (_prefix_lattice <= 0 || _postfix_lattice <= 0) return;
  memcpy(_data_out, _data_in, _prefix_lattice * _postfix_lattice * sizeof(real));
}

// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: th_spgpe_spectral --chi <real> --omega_bar <real> --k0 <real> --tl <real>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-c,  --chi\treal \t\t0.0786\n"
                         "-o,  --omega_bar\treal \t\t0.0057\n"
                         "-k,  --k0\treal \t\t7.0\n"
                         "-t,  --tl\treal \t\t1.0\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   MPI Multipath Simulation Driver function implementations
void _segment0()
{
  
  
  uint32_t _gen_driving_noise_local_seeds[10] = {
  _gen_driving_noise_seeds[0]+(0 + _rank)*1,
  _gen_driving_noise_seeds[1]+(0 + _rank)*2,
  _gen_driving_noise_seeds[2]+(0 + _rank)*3,
  _gen_driving_noise_seeds[3]+(0 + _rank)*4,
  _gen_driving_noise_seeds[4]+(0 + _rank)*5,
  _gen_driving_noise_seeds[5]+(0 + _rank)*6,
  _gen_driving_noise_seeds[6]+(0 + _rank)*7,
  _gen_driving_noise_seeds[7]+(0 + _rank)*8,
  _gen_driving_noise_seeds[8]+(0 + _rank)*9,
  _gen_driving_noise_seeds[9]+(0 + _rank)*10
  };
  
  
  _gen_driving_noise = (dsfmt_t *)xmds_malloc(sizeof(dsfmt_t));
  dsfmt_init_by_array(_gen_driving_noise, _gen_driving_noise_local_seeds, 10);
  
  
  
  _x_segment1_x_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_segment1_x_operators_operator0_field_alloc_size,1));
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field;
  _segment1_oldCopy_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  
  _x_segment4_x_operators_operator0_field = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_segment4_x_operators_operator0_field_alloc_size,1));
  _active_x_segment4_x_operators_operator0_field = _x_segment4_x_operators_operator0_field;
  _segment4_akafield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akbfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akcfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akdfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akefield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akffield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akgfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akhfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akifield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_akjfield_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  _segment4_initial_x_wavefunction = (complex*) xmds_malloc(sizeof(complex) * MAX(_x_wavefunction_alloc_size,1));
  
  memset(_segment4_x_operators_operator0_last_timestep_size_map, 0, sizeof(_segment4_x_operators_operator0_last_timestep_size_map));
  _segment1_x_operators_calculate_operator0_field();
  
  for (long _i0 = _rank; _i0 < _n_paths; _i0+=_size) {
    _LOG(_PATH_LOG_LEVEL, "Starting path %li\n", _i0 + 1);
  
    
    _mg0_output_raw_initialise();  _mg1_output_raw_initialise();  _mg2_output_raw_initialise();  
    t = 0.0;
    
    _mg0_output_raw_initialise();
    _mg1_output_raw_initialise();
    _mg2_output_raw_initialise();
    _active_x_wavefunction = _x_wavefunction;
    _x_wavefunction_initialise();
    _mg0_output_index_t = 0;
    _mg1_output_index_t = 0;
    _mg2_output_index_t = 0;
    _mg0_sample();
    _mg1_sample();
    _mg2_sample();
    _segment1();
    _segment2();
    _segment3();
    _segment4();
    
    _mg0_process();
    _mg1_process();
    _mg2_process();
  }
  
  
  
  xmds_free(_x_segment1_x_operators_operator0_field);
  _active_x_segment1_x_operators_operator0_field = _x_segment1_x_operators_operator0_field = NULL;
  xmds_free(_segment1_oldCopy_x_wavefunction);
  
  xmds_free(_x_segment4_x_operators_operator0_field);
  _active_x_segment4_x_operators_operator0_field = _x_segment4_x_operators_operator0_field = NULL;
  xmds_free(_segment4_akafield_x_wavefunction);
  xmds_free(_segment4_akbfield_x_wavefunction);
  xmds_free(_segment4_akcfield_x_wavefunction);
  xmds_free(_segment4_akdfield_x_wavefunction);
  xmds_free(_segment4_akefield_x_wavefunction);
  xmds_free(_segment4_akffield_x_wavefunction);
  xmds_free(_segment4_akgfield_x_wavefunction);
  xmds_free(_segment4_akhfield_x_wavefunction);
  xmds_free(_segment4_akifield_x_wavefunction);
  xmds_free(_segment4_akjfield_x_wavefunction);
  xmds_free(_segment4_initial_x_wavefunction);
  
  
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg0_output_raw, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg0_output_raw, NULL, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg0_output_processed, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg0_output_processed, NULL, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg0_output_sd, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg0_output_sd, NULL, (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg1_output_processed, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg1_output_processed, NULL, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg1_output_sd, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg1_output_sd, NULL, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg1_output_raw, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg1_output_raw, NULL, (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg2_output_processed, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg2_output_processed, NULL, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg2_output_sd, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg2_output_sd, NULL, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
    
  if (_rank == 0)
    MPI_Reduce(MPI_IN_PLACE, _mg2_output_raw, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
  else
    MPI_Reduce(_mg2_output_raw, NULL, (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_raw_ncomponents,
               MPI_REAL, MPI_SUM, 0, MPI_COMM_WORLD);
}


// ********************************************************
//   field x function implementations
// initialisation for vector wavefunction
void _x_wavefunction_initialise()
{
  
  // HDF5 initialisation has three stages.
  // 1. Initialise the vector to zero.
  // 2. Execute any CDATA code if there is any.
  // 3. Read data from the HDF5 file.
  
  {
    // Stage 1 of initialisation
    bzero(_active_x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
    // Stage 2 of initialisation
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    #define x _x[_index_x + 0]
    #define dx (_dx_array[_index_x + 0] * (1.0))
    
    for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
      // Stage 2 of initialisation
      
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      // **********************************************
      #undef t
      // Increment index pointers for vectors in field x (or having the same dimensions)
      _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
      
    }
    #undef x
    #undef dx
    #undef psi
  }
  
  htri_t result;
  hid_t hdf5_file = H5Fopen("psi_gs.h5", H5F_ACC_RDONLY, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_ERROR_LOG_LEVEL, "Unable to open input HDF5 file 'psi_gs.h5'. Does it exist?\n");
  }
  hid_t hdf5_parent = 0;
  if ((result = H5Lexists(hdf5_file, "/1", H5P_DEFAULT)) > 0) {
    hdf5_parent = H5Gopen(hdf5_file, "/1");
  } else if (!result) {
    hdf5_parent = hdf5_file;
  } else {
    _LOG(_ERROR_LOG_LEVEL, "Unable to determine if group '/1' exists in HDF5 file 'psi_gs.h5'. Is the file corrupt?\n");
  }
  
  hsize_t file_dims[1];
  
  hid_t dataset_x;
  if ((result = H5Lexists(hdf5_parent, "x", H5P_DEFAULT))>0)
    dataset_x = H5Dopen(hdf5_parent, "x");
  else if (!result)
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to find dimension 'x' in HDF5 file.\n");
  else
    _LOG(_ERROR_LOG_LEVEL, "Error: Unable to determine if dimension 'x' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataspace_x = H5Dget_space(dataset_x);
  file_dims[0] = H5Sget_simple_extent_npoints(dataspace_x);
  real* x_inputdata = (real*)xmds_malloc(file_dims[0] * sizeof(real));
  H5Dread(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, x_inputdata);
  for (long _i0 = 0; _i0 < _lattice_x-1; _i0++) {
    real step = _x[_i0+1] - _x[_i0];
    if (abs(_x[_i0] - x_inputdata[_i0]) > 0.01 * step) {
      // _LOG will cause the simulation to exit
      _LOG(_ERROR_LOG_LEVEL, "Geometry matching mode is strict for dimension 'x'.\n"
                             "This means that the coordinates must be the same as for the input grid.\n"
                             "The problem was found at input_x: %e, simulation_x: %e, difference: %e\n",
                             (real)x_inputdata[_i0], (real)_x[_i0], (real)x_inputdata[_i0] - _x[_i0]);
    }
  }
  
  hid_t file_dataspace;
  file_dataspace = H5Screate_simple(1, file_dims, NULL);
  bool _variablesFound = false;
  hid_t dataset_psiR = 0;
  if ((result = H5Lexists(hdf5_parent, "psiR", H5P_DEFAULT))>0) {
    dataset_psiR = H5Dopen(hdf5_parent, "psiR");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'psiR' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'psiR' exists in HDF5 file. Is the file corrupt?\n");
  hid_t dataset_psiI = 0;
  if ((result = H5Lexists(hdf5_parent, "psiI", H5P_DEFAULT))>0) {
    dataset_psiI = H5Dopen(hdf5_parent, "psiI");
    _variablesFound = true;
  } else if (!result)
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to find variable name 'psiI' in HDF5 file.\n");
  else
    _LOG(_WARNING_LOG_LEVEL, "Warning: Unable to determine if variable 'psiI' exists in HDF5 file. Is the file corrupt?\n");
  
  if (!_variablesFound) {
    // We haven't found anything. There's a problem with the input file.
    _LOG(_ERROR_LOG_LEVEL, "Error: None of the variables were found in the HDF5 file. Please check the file.\n");
  }
  /* Create the data space */
  hsize_t file_start[1] = {(unsigned long long int)0};
  hsize_t mem_dims[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
  hsize_t mem_start[2] = {0, 0};
  hsize_t mem_stride[2] = {1, 1};
  hsize_t mem_count[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
  
  
  hid_t mem_dataspace;
  mem_dims[1] = 2;
  mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
  mem_stride[1] = 2;
  
  // Select hyperslabs of memory and file data spaces for data transfer operation
  mem_start[1] = 0;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_psiR)
    H5Dread(dataset_psiR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
  mem_start[1] = 1;
  H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
  H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
  
  if (dataset_psiI)
    H5Dread(dataset_psiI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
  
  H5Sclose(mem_dataspace);
  
  
  if (dataset_psiR) H5Dclose(dataset_psiR);
  if (dataset_psiI) H5Dclose(dataset_psiI);
  H5Sclose(file_dataspace);
  
  xmds_free(x_inputdata);
  H5Sclose(dataspace_x);
  H5Dclose(dataset_x);
  if (hdf5_parent != hdf5_file)
    H5Gclose(hdf5_parent);
  H5Fclose(hdf5_file);
  
  _x_wavefunction_basis = 2;
}


void _x_wavefunction_basis_transform(ptrdiff_t new_basis)
{
  if (_x_wavefunction_basis == new_basis)
    return;
  
  if (_x_wavefunction_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_wavefunction' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_wavefunction_basis_map.count(_basis_pair(_x_wavefunction_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_wavefunction' from basis %s to basis %s.\n",
      _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_wavefunction_basis_map[_basis_pair(_x_wavefunction_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_wavefunction' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_wavefunction_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_wavefunction);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_wavefunction_basis = new_basis;
}

void _x_driving_noise_basis_transform(ptrdiff_t new_basis)
{
  if (_x_driving_noise_basis == new_basis)
    return;
  
  if (_x_driving_noise_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_driving_noise' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_driving_noise_basis_map.count(_basis_pair(_x_driving_noise_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_driving_noise' from basis %s to basis %s.\n",
      _basis_identifiers[_x_driving_noise_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_driving_noise_basis_map[_basis_pair(_x_driving_noise_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_driving_noise' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_driving_noise_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_driving_noise);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_driving_noise_basis = new_basis;
}


void _x_driving_noise_evaluate(real _step)
{
  const ptrdiff_t _vector_size = 2 * (_lattice_kx) * _x_driving_noise_ncomponents;
  const real _var = 0.5 / (1.0* _step);
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
      _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_x_driving_noise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_x_driving_noise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_x_driving_noise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
        _v2 = (2.0*dsfmt_genrand_close1_open2(_gen_driving_noise) - 3.0);
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_x_driving_noise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
  long _x_driving_noise_index_pointer = 0;
  #define dW _active_x_driving_noise[_x_driving_noise_index_pointer + 0]
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx_array[_index_kx + 0] * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    dW *= _dkx_array_invsqrt[_index_kx + 0];
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_driving_noise_index_pointer += 1 * _x_driving_noise_ncomponents;
    
  }
  #undef kx
  #undef dkx
  #undef dW
  _x_driving_noise_basis = 0;
}


void _x_driving_noise_split(real _new_step, real _old_step, complex* _old_array)
{
  const ptrdiff_t _vector_size = 2 * (_lattice_kx) * _x_driving_noise_ncomponents;
  // Split a gaussian noise
  _x_driving_noise_evaluate((_new_step * _old_step)/(_old_step - _new_step));
  
  // Now complete creation of the new noise.
  
  {
    _MAKE_AUTOVEC_VARIABLE(_old_array);
    _MAKE_AUTOVEC_VARIABLE(_active_x_driving_noise);
    #pragma ivdep
    for (long _i0 = 0; _i0 < 2 * (_lattice_kx) * _x_driving_noise_ncomponents; _i0++) {
      _AUTOVEC(_active_x_driving_noise)[_i0] += _AUTOVEC(_old_array)[_i0];
    }
  
  }
  
  _x_driving_noise_basis = 0;
}

// initialisation for computed vector pos_space_terms
void _x_pos_space_terms_initialise()
{
  
  _x_pos_space_terms_basis = 3;
}


void _x_pos_space_terms_basis_transform(ptrdiff_t new_basis)
{
  if (_x_pos_space_terms_basis == new_basis)
    return;
  
  if (_x_pos_space_terms_basis == -1) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: Attempted to transform the vector 'x_pos_space_terms' to basis %s, but the vector doesn't have a basis specified yet!\n"
      "       Please report this error to xmds-devel@lists.sourceforge.net\n",
      _basis_identifiers[new_basis]
      );
  }
  
  if (_x_pos_space_terms_basis_map.count(_basis_pair(_x_pos_space_terms_basis, new_basis)) == 0) {
    _LOG(
      _ERROR_LOG_LEVEL,
      "Error: We should have information about how to do every needed transform, but it seems we don't for this transform.\n"
      "       The transform is for the vector 'x_pos_space_terms' from basis %s to basis %s.\n",
      _basis_identifiers[_x_pos_space_terms_basis], _basis_identifiers[new_basis]
    );
  }
  _basis_transform_t &_t = _x_pos_space_terms_basis_map[_basis_pair(_x_pos_space_terms_basis, new_basis)];
  if (_t._transform_steps.size() == 0) {
    _LOG(_ERROR_LOG_LEVEL, "Error: It looks like we tried to create plans for this transform, but failed.\n"
                           "       The transform was for the vector 'x_pos_space_terms' from basis %s to basis %s.\n",
                           _basis_identifiers[_x_pos_space_terms_basis], _basis_identifiers[new_basis]);
  }
  real *_source_data = reinterpret_cast<real*>(_active_x_pos_space_terms);
  real *_dest_data = _auxiliary_array;
  for (vector<_transform_step>::iterator _it = _t._transform_steps.begin(); _it != _t._transform_steps.end(); ++_it) {
    _it->_func(_it->_forward, _t._multiplier, _source_data, _dest_data, _it->_prefix_lattice, _it->_postfix_lattice);
    if (_it->_out_of_place) {
      real *_temp = _source_data;
      _source_data = _dest_data;
      _dest_data = _temp;
    }
  }
  _x_pos_space_terms_basis = new_basis;
}


void _x_pos_space_terms_evaluate()
{
  // Transforming vectors to basis (x_4f)
  _x_wavefunction_basis_transform(3); // (x_4f)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _x_pos_space_terms_index_pointer = 0;
  #define U _active_x_pos_space_terms[_x_pos_space_terms_index_pointer + 0]
  #define x_4f _x_4f[_index_x_4f + 0]
  #define dx_4f (_dx_4f_array[_index_x_4f + 0] * (1.0))
  
  for (long _index_x_4f = 0; _index_x_4f < _lattice_x_4f; _index_x_4f++) {
    // ************* Evaluation code ****************
    #line 65 "th_spgpe_spectral.xmds"
    
    U = mod2(psi)*psi;
    
    #line 3435 "th_spgpe_spectral.cc"
    // **********************************************
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    _x_pos_space_terms_index_pointer += 1 * _x_pos_space_terms_ncomponents;
    
  }
  #undef x_4f
  #undef dx_4f
  #undef psi
  #undef U
  
  _x_pos_space_terms_basis = 3;
}

// ********************************************************
//   segment 1 (SI fixed-step integrator) function implementations
void _segment1()
{
  real _step = t_lim_gs/(real)7000;
  real _noiseStep = t_lim_gs/(real)7000;
  
  complex* _oldCopy_x_wavefunction = _segment1_oldCopy_x_wavefunction;
  
  
  for (long _istep = 0; _istep < 7000; _istep++) {
    
    _active_x_driving_noise = _x_driving_noise;
    _x_driving_noise_evaluate(_noiseStep);
    
    _segment1_calculate_nonconstant_ip_fields(_step, 1);
    
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    _x_wavefunction_basis_transform(2); // (x)
    
    memcpy(_oldCopy_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
    
    _active_x_wavefunction = _x_wavefunction;
    
    
    for (int _iteration = 0; _iteration < 3; _iteration++) {
      if (_iteration < 3 - 1) {
        _segment1_calculate_delta_a(0.5*_step);  } else {
        _segment1_calculate_delta_a(_step);  }
      
      _x_wavefunction_basis_transform(2); // (x)
      
      {
        _MAKE_AUTOVEC_VARIABLE(_oldCopy_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          // a = oldCopy + a
          _AUTOVEC(_x_wavefunction)[_i0] += _AUTOVEC(_oldCopy_x_wavefunction)[_i0];
        }
      
      }
    }
    
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    // Check if a component of any integration vector is non-finite
    // no need to check all components since they will be quickly mixed
    if (_xmds_isnonfinite(_active_x_wavefunction[0].Re())) {
      // One of the integration vectors has gone non-finite.
      // Sample any moment groups that have pending samples,
      // then leave the integrator.
      _LOG(_WARNING_LOG_LEVEL, "WARNING: halt_non_finite: Integration halted at t = %e.\n"
                               "         Non-finite number in integration vector in segment 1.\n", t);
      
      if (_mg0_output_index_t < _mg0_output_lattice_t)
        _mg0_sample();
      if (_mg1_output_index_t < _mg1_output_lattice_t)
        _mg1_sample();
      if (_mg2_output_index_t < _mg2_output_lattice_t)
        _mg2_sample();
      
      goto _SEGMENT1_END;
    }
    
    if ((_istep % 700) == 699.0)
      _mg0_sample();
    if ((_istep % 700) == 699.0)
      _mg1_sample();
    if ((_istep % 700) == 699.0)
      _mg2_sample();
  }
  
  _SEGMENT1_END:;
  
}


inline void _segment1_calculate_delta_a(real _step)
{
  _x_pos_space_terms_evaluate();
  
  
  // Delta A propagation operator for field x
  _segment1_x_operators_evaluate_operator1(_step);
  
}


inline void _segment1_ip_evolve(int _exponent)
{
  
  _x_wavefunction_basis_transform(1); // (nx)
  
  if (_exponent > 0) {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi *= /* L_st[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  } else {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment1_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi /= /* L_st[psi] */ _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment1_x_operators_operator0_field_index_pointer += _x_segment1_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  }
  
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}

// ConstantIPOperator
void _segment1_x_operators_calculate_operator0_field()
{
  real _step = t_lim_gs/(real)7000;
  real _noiseStep = t_lim_gs/(real)7000;
  
  long _x_segment1_x_operators_operator0_field_index_pointer = 0;
  #define nx _nx[_index_nx + 0]
  #define dnx (_dnx * (1.0))
  
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++) {
    complex L_st;
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in a constant IP operator/
    // The user probably shouldn't be doing this, but if they must, they should use a non-constant EX
    // operator instead
    #define t Dont_use_propagation_dimension_t_in_constant_IP_operator___Use_non_constant_EX_operator_instead
    // ************** Operator code *****************
    #line 82 "th_spgpe_spectral.xmds"
    
    L_st = -(nx+0.5)*omega_bar*(i+kth);
    
    #line 3604 "th_spgpe_spectral.cc"
    // **********************************************
    #undef t
        
    _x_segment1_x_operators_operator0_field[_x_segment1_x_operators_operator0_field_index_pointer + 0] = exp(L_st * 0.5 * _step);
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_segment1_x_operators_operator0_field_index_pointer += 1 * _x_segment1_x_operators_operator0_field_ncomponents;
    
  }
  #undef nx
  #undef dnx
}

// Delta A propagation operator for field x
void _segment1_x_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (x)
  _x_pos_space_terms_basis_transform(2); // (x)
  _x_driving_noise_basis_transform(2); // (x)
  _x_wavefunction_basis_transform(2); // (x)
  
  long _x_pos_space_terms_index_pointer = 0;
  #define U _active_x_pos_space_terms[_x_pos_space_terms_index_pointer + 0]
  long _x_driving_noise_index_pointer = 0;
  #define dW _active_x_driving_noise[_x_driving_noise_index_pointer + 0]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    complex dpsi_dt;
    
    #define dt _step
    
    // ************* Propagation code ***************
    #line 88 "th_spgpe_spectral.xmds"
    
    dpsi_dt = 0.0-(i+kth)*U+kth*mu*psi+sgT*dW;
    
    #line 3644 "th_spgpe_spectral.cc"
    // **********************************************
    
    #undef dt
    
    
    _active_x_wavefunction[_x_wavefunction_index_pointer + 0] = dpsi_dt * _step;
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_pos_space_terms_index_pointer += 1 * _x_pos_space_terms_ncomponents;
    _x_driving_noise_index_pointer += 1 * _x_driving_noise_ncomponents;
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef U
  #undef dW
  #undef psi
}

// ********************************************************
//   segment 2 (Breakpoint) function implementations
void _segment2()
{
  
  _x_wavefunction_basis_transform(2); // (x)
  
  
  char *_baseFilename = (char*)malloc(255);
  snprintf(_baseFilename, 255, "%s%s", "psi_gs", gsArgsAndValues.c_str());
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", _baseFilename);
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", _baseFilename);
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"breakpoint\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">1</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>3</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "x psiR psiI \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>3</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", _baseFilename);
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", _baseFilename);
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _lattice_x;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_x;
  if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
    dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_x = H5Dopen(hdf5_file, "/1/x");
  H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_x, "x");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_lattice_x};
  hid_t file_dataspace = H5Screate_simple(1, file_dims, NULL);
  
  hid_t dataset_psiR;
  if (!H5Lexists(hdf5_file, "/1/psiR", H5P_DEFAULT))
    dataset_psiR = H5Dcreate(hdf5_file, "/1/psiR", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_psiR = H5Dopen(hdf5_file, "/1/psiR");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_psiR, dataset_x, 0);
  #endif
  hid_t dataset_psiI;
  if (!H5Lexists(hdf5_file, "/1/psiI", H5P_DEFAULT))
    dataset_psiI = H5Dcreate(hdf5_file, "/1/psiI", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_psiI = H5Dopen(hdf5_file, "/1/psiI");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_psiI, dataset_x, 0);
  #endif
  H5Dclose(dataset_x);
  
  
  if ((_lattice_x)) {
    /* Create the data space */
    hsize_t file_start[1] = {(unsigned long long int)0};
    hsize_t mem_dims[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
    hsize_t mem_start[2] = {0, 0};
    hsize_t mem_stride[2] = {1, 1};
    hsize_t mem_count[2] = {(unsigned long long int)_lattice_x, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[1] = 2;
    mem_dataspace = H5Screate_simple(2, mem_dims, NULL);
    mem_stride[1] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[1] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_psiR)
      H5Dwrite(dataset_psiR, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
    mem_start[1] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_psiI)
      H5Dwrite(dataset_psiI, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_x_wavefunction);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_psiR);
  H5Dclose(dataset_psiI);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "        <name>th_spgpe_spectral</name>\n");
  fprintf(fp, "        <author/>\n");
  fprintf(fp, "        <description>\n");
  fprintf(fp, "                \n");
  fprintf(fp, "        </description>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <features>\n");
  fprintf(fp, "                <auto_vectorise/>\n");
  fprintf(fp, "                <benchmark/>\n");
  fprintf(fp, "                <bing/>\n");
  fprintf(fp, "                <halt_non_finite/>\n");
  fprintf(fp, "                <validation kind=\"run-time\"/>\n");
  fprintf(fp, "                <globals>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        real R_tilde;\n");
  fprintf(fp, "                        real rho0_tilde;\n");
  fprintf(fp, "                        real t_lim;\n");
  fprintf(fp, "                        real t_lim_gs;\n");
  fprintf(fp, "                        real kth; \n");
  fprintf(fp, "                        real sgT;\n");
  fprintf(fp, "                        real mu;\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </globals>\n");
  fprintf(fp, "                <arguments>\n");
  fprintf(fp, "                        <argument default_value=\"0.0786\" name=\"chi\" type=\"real\"/>\n");
  fprintf(fp, "                        <argument default_value=\"0.0057\" name=\"omega_bar\" type=\"real\"/>\n");
  fprintf(fp, "                        <argument default_value=\"7.0\" name=\"k0\" type=\"real\"/>\n");
  fprintf(fp, "                        <argument default_value=\"1.0\" name=\"tl\" type=\"real\"/>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        R_tilde = sqrt(2.0)*1/(pow(chi,1.0/3.0)*omega_bar);\n");
  fprintf(fp, "                        rho0_tilde = pow(chi,-2.0/3.0);\n");
  fprintf(fp, "                        kth = 0.17;\n");
  fprintf(fp, "                        t_lim = tl*2*M_PI/omega_bar;\n");
  fprintf(fp, "                        t_lim_gs = log(5)/(omega_bar*1.0);\n");
  fprintf(fp, "                        sgT = sqrt(2.0* kth);\n");
  fprintf(fp, "                        mu=rho0_tilde;  \n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </arguments>\n");
  fprintf(fp, "        </features>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <geometry>\n");
  fprintf(fp, "                <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "                <transverse_dimensions>\n");
  fprintf(fp, "                        <dimension lattice=\"1502\" length_scale=\"sqrt(1/(omega_bar))\" name=\"x\" spectral_lattice=\"1502\" transform=\"hermite-gauss\"/>\n");
  fprintf(fp, "                </transverse_dimensions>\n");
  fprintf(fp, "        </geometry>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <driver name=\"mpi-multi-path\" paths=\"6\"/>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <vector initial_basis=\"x\" name=\"wavefunction\" type=\"complex\">\n");
  fprintf(fp, "                <components> psi </components>\n");
  fprintf(fp, "                <initialisation kind=\"hdf5\">\n");
  fprintf(fp, "                        <filename> psi_gs.h5 </filename>\n");
  fprintf(fp, "                </initialisation>\n");
  fprintf(fp, "        </vector>\n");
  fprintf(fp, "        \n");
  fprintf(fp, "    <computed_vector dimensions=\"x\" name=\"pos_space_terms\" type=\"complex\">\n");
  fprintf(fp, "      <components>\n");
  fprintf(fp, "                  U\n");
  fprintf(fp, "      </components>\n");
  fprintf(fp, "      <evaluation>\n");
  fprintf(fp, "        <dependencies basis=\"x_4f\">wavefunction</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "          U = mod2(psi)*psi;\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </evaluation>\n");
  fprintf(fp, "    </computed_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <noise_vector dimensions=\"x\" initial_basis=\"kx\" kind=\"wiener\" method=\"dsfmt\" name=\"driving_noise\" type=\"complex\">\n");
  fprintf(fp, "                <components> dW </components>\n");
  fprintf(fp, "        </noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <sequence>\n");
  fprintf(fp, "\n");
  fprintf(fp, "                <integrate algorithm=\"SI\" interval=\"t_lim_gs\" steps=\"7000\" tolerance=\"1e-4\">\n");
  fprintf(fp, "                        <samples>10 10 10</samples>\n");
  fprintf(fp, "                        <operators>\n");
  fprintf(fp, "                                <operator kind=\"ip\" type=\"complex\">\n");
  fprintf(fp, "                                        <operator_names>L_st</operator_names>\n");
  fprintf(fp, "                                        <![CDATA[\n");
  fprintf(fp, "                                        L_st = -(nx+0.5)*omega_bar*(i+kth);\n");
  fprintf(fp, "                                        ]]>\n");
  fprintf(fp, "                                </operator>\n");
  fprintf(fp, "                                <integration_vectors>wavefunction</integration_vectors>\n");
  fprintf(fp, "                                <dependencies>driving_noise pos_space_terms</dependencies>\n");
  fprintf(fp, "                                <![CDATA[\n");
  fprintf(fp, "                                dpsi_dt = L_st[psi]-(i+kth)*U+kth*mu*psi+sgT*dW;\n");
  fprintf(fp, "                                ]]>\n");
  fprintf(fp, "                        </operators>\n");
  fprintf(fp, "                </integrate>\n");
  fprintf(fp, "                \n");
  fprintf(fp, "                <breakpoint filename=\"psi_gs.xsil\">\n");
  fprintf(fp, "                        <dependencies basis=\"x\">wavefunction</dependencies>\n");
  fprintf(fp, "                </breakpoint>\n");
  fprintf(fp, "\n");
  fprintf(fp, "            <filter>\n");
  fprintf(fp, "                <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "              <![CDATA[\n");
  fprintf(fp, "                psi *= cos(2.0*k0*x)*sqrt(2);\n");
  fprintf(fp, "              ]]>\n");
  fprintf(fp, "            </filter>\n");
  fprintf(fp, "\n");
  fprintf(fp, "                <integrate algorithm=\"ARK89\" interval=\"t_lim\" tolerance=\"1.0e-3\">\n");
  fprintf(fp, "                        <samples> 2500 2500 2500 </samples>\n");
  fprintf(fp, "                        <operators>\n");
  fprintf(fp, "                                <operator kind=\"ip\" type=\"imaginary\">\n");
  fprintf(fp, "                                        <operator_names> L </operator_names>\n");
  fprintf(fp, "                                        <![CDATA[\n");
  fprintf(fp, "                                        L = -(nx+0.5)*omega_bar*i;\n");
  fprintf(fp, "                                        ]]>\n");
  fprintf(fp, "                                </operator>\n");
  fprintf(fp, "                                <integration_vectors> wavefunction </integration_vectors>\n");
  fprintf(fp, "                                <dependencies> pos_space_terms </dependencies>\n");
  fprintf(fp, "                                <![CDATA[\n");
  fprintf(fp, "                                dpsi_dt = L[psi]-i*U;\n");
  fprintf(fp, "                                ]]>\n");
  fprintf(fp, "                        </operators>\n");
  fprintf(fp, "                </integrate>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        </sequence>\n");
  fprintf(fp, "  \n");
  fprintf(fp, "        <output>\n");
  fprintf(fp, "                <sampling_group basis=\"x\" initial_sample=\"yes\">\n");
  fprintf(fp, "                        <moments> pos_dens pos_phase </moments>\n");
  fprintf(fp, "                        <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        pos_dens = mod2(psi);\n");
  fprintf(fp, "                        pos_phase = arg(psi);\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "\n");
  fprintf(fp, "        <sampling_group basis=\"nx\" initial_sample=\"yes\">\n");
  fprintf(fp, "          <moments> herm_dens herm_phase </moments>\n");
  fprintf(fp, "          <dependencies>wavefunction</dependencies>\n");
  fprintf(fp, "          <![CDATA[\n");
  fprintf(fp, "            herm_dens = mod2(psi);\n");
  fprintf(fp, "                        herm_phase = arg(psi);\n");
  fprintf(fp, "          ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "        \n");
  fprintf(fp, "                <sampling_group basis=\"kx\" initial_sample=\"yes\">\n");
  fprintf(fp, "                        <moments> mom_dens mom_phase </moments>\n");
  fprintf(fp, "                        <dependencies> wavefunction </dependencies>\n");
  fprintf(fp, "                        <![CDATA[\n");
  fprintf(fp, "                        mom_dens = mod2(psi);\n");
  fprintf(fp, "                        mom_phase = arg(psi);\n");
  fprintf(fp, "                        ]]>\n");
  fprintf(fp, "                </sampling_group>\n");
  fprintf(fp, "        </output>\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 3.0.0 \"Release the Kraken\" (r3072)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument chi = %e\n", chi);
  
  fprintf(fp, "  Command line argument omega_bar = %e\n", omega_bar);
  
  fprintf(fp, "  Command line argument k0 = %e\n", k0);
  
  fprintf(fp, "  Command line argument tl = %e\n", tl);
  fprintf(fp, "\nNo seeds were provided for noise vector 'driving_noise'. The seeds generated were:\n");
  fprintf(fp, "    %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", _gen_driving_noise_seeds[0], _gen_driving_noise_seeds[1], _gen_driving_noise_seeds[2], _gen_driving_noise_seeds[3], _gen_driving_noise_seeds[4], _gen_driving_noise_seeds[5], _gen_driving_noise_seeds[6], _gen_driving_noise_seeds[7], _gen_driving_noise_seeds[8], _gen_driving_noise_seeds[9]);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   segment 3 (Filter) function implementations
void _segment3()
{
  
  // Filter operator
  _segment3__evaluate_operator0();
}

// Filter operator
void _segment3__evaluate_operator0()
{
  // Transforming vectors to basis (x)
  _x_wavefunction_basis_transform(2); // (x)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    
    // ************** Filter code *****************
    #line 100 "th_spgpe_spectral.xmds"
    
    psi *= cos(2.0*k0*x)*sqrt(2);
    
    #line 4054 "th_spgpe_spectral.cc"
    // **********************************************
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
}

// ********************************************************
//   segment 4 (RK89 adaptive-step integrator) function implementations
void _segment4()
{
  real _step = t_lim/(real)1000;
  real _old_step = _step;
  real _min_step = _step;
  real _max_step = _step;
  long _attempted_steps = 0;
  long _unsuccessful_steps = 0;
  
  real _tolerance = 0.001;
  
  real _error, _last_norm_error = 1.0;
  real _segment4_x_wavefunction_error;
  
  bool _discard = false;
  bool _break_next = false;
  
  bool _next_sample_flag[5];
  for (long _i0 = 0; _i0 < 5; _i0++)
    _next_sample_flag[_i0] = false;
  
  long _next_sample_counter[3];
  for (long _i0 = 0; _i0 < 3; _i0++)
    _next_sample_counter[_i0] = 1;
  
  real _t_local = 0.0;
  
  real _t_break_next = _segment4_setup_sampling(_next_sample_flag, _next_sample_counter);
  
  if ( (_t_local + _step)*(1.0 + _EPSILON) >= _t_break_next) {
    _break_next = true;
    _step = _t_break_next - _t_local;
  }
  
  complex* _akafield_x_wavefunction = _segment4_akafield_x_wavefunction;
  complex* _akbfield_x_wavefunction = _segment4_akbfield_x_wavefunction;
  complex* _akcfield_x_wavefunction = _segment4_akcfield_x_wavefunction;
  complex* _akdfield_x_wavefunction = _segment4_akdfield_x_wavefunction;
  complex* _akefield_x_wavefunction = _segment4_akefield_x_wavefunction;
  complex* _akffield_x_wavefunction = _segment4_akffield_x_wavefunction;
  complex* _akgfield_x_wavefunction = _segment4_akgfield_x_wavefunction;
  complex* _akhfield_x_wavefunction = _segment4_akhfield_x_wavefunction;
  complex* _akifield_x_wavefunction = _segment4_akifield_x_wavefunction;
  complex* _akjfield_x_wavefunction = _segment4_akjfield_x_wavefunction;
  complex* _initial_x_wavefunction = _segment4_initial_x_wavefunction;
  
  
  // Runge Kutta method constants 
  real _a_raw[16];
  real _a[16];
  real _b[16][16];
  real _c[16];
  real _cs[16];
  real _d[16];
  
  for (unsigned long _i0 = 0; _i0 < 16; _i0++) {
    _a_raw[_i0] = _c[_i0] = _d[_i0] = 0.0;
    for (unsigned long _i1 = 0; _i1 < 16; _i1++)
     _b[_i0][_i1] = 0.0;
  }
  
  _a_raw[1]  = 0.02173913043478260869565217391304347;
  _a_raw[2]  = 0.09629581047800066670113001679819925;
  _a_raw[3]  = 0.14444371571700100005169502519729888;
  _a_raw[4]  = 0.52205882352941176470588235294117647;
  _a_raw[5]  = 0.22842443612863469578031459099794265;
  _a_raw[6]  = 0.54360353589933733219171338103002937;
  _a_raw[7]  = 0.64335664335664335664335664335664335;
  _a_raw[8]  = 0.48251748251748251748251748251748251;
  _a_raw[9]  = 0.06818181818181818181818181818181818;
  _a_raw[10] = 0.25060827250608272506082725060827250;
  _a_raw[11] = 0.66736715965600568968278165443304378;
  _a_raw[12] = 0.85507246376811594202898550724637681;
  _a_raw[13] = 0.89795918367346938775510204081632653;
  _a_raw[14] = 1.0;
  _a_raw[15] = 1.0;
  
  _a[0] = 0.0;
  for (unsigned long _i0 = 1; _i0 < 16; _i0++)
    _a[_i0] = _a_raw[_i0] - _a_raw[_i0 - 1];
  
  _b[1][0]   = 1.0/46.0;
  _b[2][0]   =-0.11698050118114486205818241524969622;
  _b[2][1]   = 0.21327631165914552875931243204789548;
  _b[3][0]   = 0.03611092892925025001292375629932472;
  _b[3][2]   = 0.10833278678775075003877126889797416;
  _b[4][0]   = 1.57329743908138605107331820072051125;
  _b[4][2]   =-5.98400943754042002888532938159655553;
  _b[4][3]   = 4.93277082198844574251789353381722074;
  _b[5][0]   = 0.05052046351120380909008334360006234;
  _b[5][3]   = 0.17686653884807108146683657390397612;
  _b[5][4]   = 0.00103743376935980522339467349390418;
  _b[6][0]   = 0.10543148021953768958529340893598138;
  _b[6][3]   =-0.16042415162569842979496486916719383;
  _b[6][4]   = 0.11643956912829316045688724281285250;
  _b[6][5]   = 0.48215663817720491194449759844838932;
  _b[7][0]   = 0.07148407148407148407148407148407148;
  _b[7][5]   = 0.32971116090443908023196389566296464;
  _b[7][6]   = 0.24216141096813279233990867620960722;
  _b[8][0]   = 0.07162368881118881118881118881118881;
  _b[8][5]   = 0.32859867301674234161492268975519694;
  _b[8][6]   = 0.11622213117906185418927311444060725;
  _b[8][7]   =-0.03392701048951048951048951048951048;
  _b[9][0]   = 0.04861540768024729180628870095388582;
  _b[9][5]   = 0.03998502200331629058445317782406268;
  _b[9][6]   = 0.10715724786209388876739304914053506;
  _b[9][7]   =-0.02177735985419485163815426357369818;
  _b[9][8]   =-0.10579849950964443770179884616296721;
  _b[10][0]  =-0.02540141041535143673515871979014924;
  _b[10][5]  = 1.0/30.0;
  _b[10][6]  =-0.16404854760069182073503553020238782;
  _b[10][7]  = 0.03410548898794737788891414566528526;
  _b[10][8]  = 0.15836825014108792658008718465091487;
  _b[10][9]  = 0.21425115805975734472868683695127609;
  _b[11][0]  = 0.00584833331460742801095934302256470;
  _b[11][5]  =-0.53954170547283522916525526480339109;
  _b[11][6]  = 0.20128430845560909506500331018201158;
  _b[11][7]  = 0.04347222773254789483240207937678906;
  _b[11][8]  =-0.00402998571475307250775349983910179;
  _b[11][9]  = 0.16541535721570612771420482097898952;
  _b[11][10] = 0.79491862412512344573322086551518180;
  _b[12][0]  =-0.39964965968794892497157706711861448;
  _b[12][5]  =-3.79096577568393158554742638116249372;
  _b[12][6]  =-0.40349325653530103387515807815498044;
  _b[12][7]  =-2.82463879530435263378049668286220715;
  _b[12][8]  = 1.04226892772185985533374283289821416;
  _b[12][9]  = 1.12510956420436603974237036536924078;
  _b[12][10] = 3.32746188718986816186934832571938138;
  _b[12][11] = 2.77897957186355606325818219255783627;
  _b[13][0]  = 0.39545306350085237157098218205756922;
  _b[13][5]  = 5.82534730759650564865380791881446903;
  _b[13][6]  =-0.36527452339161313311889856846974452;
  _b[13][7]  = 1.18860324058346533283780076203192232;
  _b[13][8]  = 0.57970467638357921347110271762687972;
  _b[13][9]  =-0.86824862589087693262676988867897834;
  _b[13][10] =-5.20227677296454721392873650976792184;
  _b[13][11] =-0.79895541420753382543211121058675915;
  _b[13][12] = 0.14360623206363792632792463778889008;
  _b[14][0]  = 8.49173149061346398013352206978380938;
  _b[14][5]  = 86.32213734729036800877634194386790750;
  _b[14][6]  = 1.02560575501091662034511526187393241;
  _b[14][7]  = 85.77427969817339941806831550695235092;
  _b[14][8]  =-13.98699305104110611795532466113248067;
  _b[14][9]  =-20.71537405501426352265946477613161883;
  _b[14][10] =-72.16597156619946800281180102605140463;
  _b[14][11] =-76.71211139107806345587696023064419687;
  _b[14][12] = 4.22319427707298828839851258893735507;
  _b[14][13] =-1.25649850482823521641825667745565428;
  _b[15][0]  =-0.42892119881959353241190195318730008;
  _b[15][5]  =-9.16865700950084689999297912545025359;
  _b[15][6]  = 1.08317616770620939241547721530003920;
  _b[15][7]  =-1.23501525358323653198215832293981810;
  _b[15][8]  =-1.21438272617593906232943856422371019;
  _b[15][9]  = 1.37226168507232166621351243731869914;
  _b[15][10] = 9.15723239697162418155377135344394113;
  _b[15][11] = 1.30616301842220047563298585480401671;
  _b[15][12] =-0.25285618808937955976690569433069974;
  _b[15][13] = 0.38099910799663987066763679926508552;
  
  _c[0]  = 0.01490902081978461022483617102382552;
  _c[7]  =-0.20408044692054151258349120934134791;
  _c[8]  = 0.22901438600570447264772469337066476;
  _c[9]  = 0.12800558251147375669208211573729202;
  _c[10] = 0.22380626846054143649770066956485937;
  _c[11] = 0.39553165293700054420552389156421651;
  _c[12] = 0.05416646758806981196568364538360743;
  _c[13] = 0.12691439652445903685643385312168037;
  _c[14] =-0.00052539244262118876455834655383035;
  _c[15] = 1.0/31.0;
  
  _cs[0]  = 0.00653047880643482012034413441159249;
  _cs[7]  =-2.31471038197461347517552506241529830;
  _cs[8]  = 0.43528227238866280799530900822377013;
  _cs[9]  = 0.14907947287101933118545845390618763;
  _cs[10] = 0.17905535442235532311850533252768020;
  _cs[11] = 2.53400872222767706921176214508820825;
  _cs[12] =-0.55430437423209112896721332268159015;
  _cs[13] = 0.56924788787870083224213506297615260;
  _cs[14] =-0.03644749690427461198884026816573513;
  _cs[15] = 1.0/31.0;
  
  _d[0] = 1.0-_b[15][5]/_b[14][5];
  _d[1] = _b[15][0]-_b[14][0]*_b[15][5]/_b[14][5];
  _d[2] = _b[15][5]/_b[14][5];
  _d[3] = _b[15][6]-_b[14][6]*_b[15][5]/_b[14][5];
  _d[4] = _b[15][7]-_b[14][7]*_b[15][5]/_b[14][5];
  _d[5] = _b[15][8]-_b[14][8]*_b[15][5]/_b[14][5];
  _d[6] = _b[15][9]-_b[14][9]*_b[15][5]/_b[14][5];
  _d[7] = _b[15][10]-_b[14][10]*_b[15][5]/_b[14][5];
  _d[8] = _b[15][11]-_b[14][11]*_b[15][5]/_b[14][5];
  _d[9] = _b[15][12]-_b[14][12]*_b[15][5]/_b[14][5];
  _d[10] = _b[15][13]-_b[14][13]*_b[15][5]/_b[14][5];
  
  do {
    
    do {
      
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 1
      
      memcpy(_akafield_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
      
      _segment4_calculate_nonconstant_ip_fields(_step, 1);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(1);
      _x_wavefunction_basis_transform(2); // (x)
      
      _active_x_wavefunction = _akafield_x_wavefunction;
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(1);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 2
      
      t += _a[1] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akbfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[1][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akbfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 2);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-2);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(2);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 3
      
      t += _a[2] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akcfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[2][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[2][1]*_AUTOVEC(_akbfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akcfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 3);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-3);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(3);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 4
      
      t += _a[3] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akdfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[3][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[3][1]*_AUTOVEC(_akbfield_x_wavefunction)[_i0]
              + _b[3][2]*_AUTOVEC(_akcfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akdfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 4);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-4);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(4);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 5
      
      t += _a[4] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akefield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[4][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[4][1]*_AUTOVEC(_akbfield_x_wavefunction)[_i0]
              + _b[4][2]*_AUTOVEC(_akcfield_x_wavefunction)[_i0] + _b[4][3]*_AUTOVEC(_akdfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akefield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 5);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-5);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(5);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 6
      
      t += _a[5] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akifield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[5][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[5][3]*_AUTOVEC(_akdfield_x_wavefunction)[_i0]
              + _b[5][4]*_AUTOVEC(_akefield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akifield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 6);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-6);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(6);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 7
      
      t += _a[6] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akjfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[6][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[6][3]*_AUTOVEC(_akdfield_x_wavefunction)[_i0]
              + _b[6][4]*_AUTOVEC(_akefield_x_wavefunction)[_i0] + _b[6][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akjfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 7);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-7);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(7);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 8
      
      t += _a[7] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akbfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[7][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[7][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[7][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akbfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 8);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-8);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(8);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 9
      
      t += _a[8] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akcfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[8][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[8][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[8][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[8][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akcfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 9);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-9);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(9);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 10
      
      t += _a[9] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akdfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[9][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[9][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[9][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[9][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0]+ _b[9][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akdfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 10);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-10);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(10);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 11
      
      t += _a[10] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akefield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[10][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[10][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[10][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[10][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _b[10][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _b[10][9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akefield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 11);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-11);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(11);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 12
      
      t += _a[11] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akffield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[11][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[11][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[11][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0] + _b[11][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _b[11][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _b[11][9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _b[11][10]*_AUTOVEC(_akefield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akffield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 12);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-12);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(12);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 13
      
      t += _a[12] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akgfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[12][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[12][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[12][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[12][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _b[12][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _b[12][9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _b[12][10]*_AUTOVEC(_akefield_x_wavefunction)[_i0] + _b[12][11]*_AUTOVEC(_akffield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akgfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 13);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-13);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(13);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 14
      
      t += _a[13] * _step;
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akhfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akhfield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[13][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[13][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[13][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[13][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _b[13][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _b[13][9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _b[13][10]*_AUTOVEC(_akefield_x_wavefunction)[_i0] + _b[13][11]*_AUTOVEC(_akffield_x_wavefunction)[_i0]
              + _b[13][12]*_AUTOVEC(_akgfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _akhfield_x_wavefunction;
      
      _segment4_calculate_nonconstant_ip_fields(_step, 14);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(-14);
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      
      // a_i=D(a_2*dt)[y1]
      _segment4_ip_evolve(14);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Step 15 and 16 combined to reduce memory use 
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akhfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akifield_x_wavefunction)[_i0] = _AUTOVEC(_x_wavefunction)[_i0] + _b[14][0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _b[14][5]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _b[14][6]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]+ _b[14][7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _b[14][8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _b[14][9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _b[14][10]*_AUTOVEC(_akefield_x_wavefunction)[_i0] + _b[14][11]*_AUTOVEC(_akffield_x_wavefunction)[_i0]
              + _b[14][12]*_AUTOVEC(_akgfield_x_wavefunction)[_i0] + _b[14][13]*_AUTOVEC(_akhfield_x_wavefunction)[_i0];
        }
      
      }
      
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akhfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akjfield_x_wavefunction)[_i0] = _d[0]*_AUTOVEC(_x_wavefunction)[_i0]
                + _d[1]*_AUTOVEC(_akafield_x_wavefunction)[_i0]
                + _d[2]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
                + _d[3]*_AUTOVEC(_akjfield_x_wavefunction)[_i0]
                + _d[4]*_AUTOVEC(_akbfield_x_wavefunction)[_i0]
                + _d[5]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
                + _d[6]*_AUTOVEC(_akdfield_x_wavefunction)[_i0]
                + _d[7]*_AUTOVEC(_akefield_x_wavefunction)[_i0]
                + _d[8]*_AUTOVEC(_akffield_x_wavefunction)[_i0]
                + _d[9]*_AUTOVEC(_akgfield_x_wavefunction)[_i0]
                + _d[10]*_AUTOVEC(_akhfield_x_wavefunction)[_i0];
        }
      
      }
      
      t += _a[14] * _step;
      
      _active_x_wavefunction = _akifield_x_wavefunction;
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      _x_wavefunction_basis_transform(2); // (x)
      
      t += _a[15] * _step;
      
      _active_x_wavefunction = _akjfield_x_wavefunction;
      
      // a_k=G[a_k, t]
      _segment4_calculate_delta_a(_step);
      _x_wavefunction_basis_transform(2); // (x)
      
      // Take full step
      
      // ai = a
      memcpy(_initial_x_wavefunction, _x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
      
      // a = a + etc
      {
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akhfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_x_wavefunction)[_i0] += _c[0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _c[7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0] + _c[8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0]
              + _c[9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _c[10]*_AUTOVEC(_akefield_x_wavefunction)[_i0] + _c[11]*_AUTOVEC(_akffield_x_wavefunction)[_i0]
              + _c[12]*_AUTOVEC(_akgfield_x_wavefunction)[_i0] + _c[13]*_AUTOVEC(_akhfield_x_wavefunction)[_i0] + _c[14]*_AUTOVEC(_akifield_x_wavefunction)[_i0]
              + _c[15]*_AUTOVEC(_akjfield_x_wavefunction)[_i0];
        }
      
      }
      
      // a* = a + etc
      {
        _MAKE_AUTOVEC_VARIABLE(_initial_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akffield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akjfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akefield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akcfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akdfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akhfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akifield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akgfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akbfield_x_wavefunction);
        _MAKE_AUTOVEC_VARIABLE(_akafield_x_wavefunction);
        #pragma ivdep
        for (long _i0 = 0; _i0 < 2 * (_lattice_x) * _x_wavefunction_ncomponents; _i0++) {
          _AUTOVEC(_akafield_x_wavefunction)[_i0] = _AUTOVEC(_initial_x_wavefunction)[_i0] + _cs[0]*_AUTOVEC(_akafield_x_wavefunction)[_i0] + _cs[7]*_AUTOVEC(_akbfield_x_wavefunction)[_i0]
              + _cs[8]*_AUTOVEC(_akcfield_x_wavefunction)[_i0] + _cs[9]*_AUTOVEC(_akdfield_x_wavefunction)[_i0] + _cs[10]*_AUTOVEC(_akefield_x_wavefunction)[_i0]
              + _cs[11]*_AUTOVEC(_akffield_x_wavefunction)[_i0] + _cs[12]*_AUTOVEC(_akgfield_x_wavefunction)[_i0] + _cs[13]*_AUTOVEC(_akhfield_x_wavefunction)[_i0]
              + _cs[14]*_AUTOVEC(_akifield_x_wavefunction)[_i0] + _cs[15]*_AUTOVEC(_akjfield_x_wavefunction)[_i0];
        }
      
      }
      
      _active_x_wavefunction = _x_wavefunction;
      
      
      
      _error = 0.0;
      
      _segment4_x_wavefunction_error = _segment4_x_wavefunction_timestep_error(_akafield_x_wavefunction);
      if (_segment4_x_wavefunction_error > _error)
        _error = _segment4_x_wavefunction_error;
      
      _attempted_steps++;
      
      if (_error < _tolerance) {
        _t_local += _step;
        if (_step > _max_step)
          _max_step = _step;
        if (!_break_next && _step < _min_step)
          _min_step = _step;
        _discard = false;
      } else {
        t -= _step;
  
        if (_segment4_x_wavefunction_reset(_initial_x_wavefunction) == false) {
  
          _LOG(_WARNING_LOG_LEVEL, "WARNING: NaN present. Integration halted at t = %e.\n"
                             "         Non-finite number in integration vector \"wavefunction\" in segment 4.\n", t);
          if (_mg0_output_index_t < _mg0_output_lattice_t)
            _mg0_sample();
          if (_mg1_output_index_t < _mg1_output_lattice_t)
            _mg1_sample();
          if (_mg2_output_index_t < _mg2_output_lattice_t)
            _mg2_sample();
          
          goto _SEGMENT4_END;
        }
  
        _segment4_ip_evolve(-1);
        
        _discard = true;
        _break_next = false;
        _unsuccessful_steps++;
      }
      
      _old_step = _step;
      
      // Resize step
      if (_error < 0.5*_tolerance || _error > _tolerance) {
        const real _safetyFactor = 0.90;
        real _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-0.7/9.0)) * pow(_last_norm_error, real(0.4/9.0));
        _scalingFactor = MAX(_scalingFactor, 1.0/5.0);
        _scalingFactor = MIN(_scalingFactor, 7.0);
        if (_error > _tolerance && _scalingFactor > 1.0) {
          // If our step failed don't try and increase our step size. That would be silly.
          _scalingFactor = _safetyFactor * pow(abs(_error/_tolerance), real(-1.0/9.0));
        }
        _old_step = _step;
        _last_norm_error = pow(_safetyFactor/_scalingFactor*pow(_last_norm_error, real(0.4/9.0)), real(9.0/0.7));
        _step *= _scalingFactor;
      }
      
    } while (_discard);
    // Check if a component of any integration vector is non-finite
    // no need to check all components since they will be quickly mixed
    if (_xmds_isnonfinite(_active_x_wavefunction[0].Re())) {
      // One of the integration vectors has gone non-finite.
      // Sample any moment groups that have pending samples,
      // then leave the integrator.
      _LOG(_WARNING_LOG_LEVEL, "WARNING: halt_non_finite: Integration halted at t = %e.\n"
                               "         Non-finite number in integration vector in segment 4.\n", t);
      
      if (_mg0_output_index_t < _mg0_output_lattice_t)
        _mg0_sample();
      if (_mg1_output_index_t < _mg1_output_lattice_t)
        _mg1_sample();
      if (_mg2_output_index_t < _mg2_output_lattice_t)
        _mg2_sample();
      
      goto _SEGMENT4_END;
    }
    
    if (_break_next) {
      if (_next_sample_flag[0]) {
        _mg0_sample();
        _next_sample_counter[0]++;
      }
      if (_next_sample_flag[1]) {
        _mg1_sample();
        _next_sample_counter[1]++;
      }
      if (_next_sample_flag[2]) {
        _mg2_sample();
        _next_sample_counter[2]++;
      }
      if (_next_sample_flag[3])
        _next_sample_flag[4] = true;
      else {
        _break_next = false;
        _t_break_next = _segment4_setup_sampling(_next_sample_flag, _next_sample_counter);
      }
    }
    
    if ( (_t_local + _step)*(1.0 + _EPSILON) > _t_break_next) {
      _break_next = true;
      _LOG(_SAMPLE_LOG_LEVEL, "Current timestep: %e\n", _old_step);
      _step = _t_break_next - _t_local;
    }
  } while (!_next_sample_flag[4]);
  
  _SEGMENT4_END:;
  
  _LOG(_SEGMENT_LOG_LEVEL, "Segment 4: minimum timestep: %e maximum timestep: %e\n", _min_step, _max_step);
  _LOG(_SEGMENT_LOG_LEVEL, "  Attempted %li steps, %.2f%% steps failed.\n", _attempted_steps, (100.0*_unsuccessful_steps)/_attempted_steps);
}


inline void _segment4_calculate_delta_a(real _step)
{
  _x_pos_space_terms_evaluate();
  
  
  // Delta A propagation operator for field x
  _segment4_x_operators_evaluate_operator1(_step);
  
}


inline void _segment4_ip_evolve(int _exponent)
{
  unsigned long _segment4_x_operators_operator0_exponentIndex = (abs(_exponent) - 1) * 1;
  
  _x_wavefunction_basis_transform(1); // (nx)
  
  if (_exponent > 0) {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment4_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi *= /* L[psi] */ _x_segment4_x_operators_operator0_field[_x_segment4_x_operators_operator0_field_index_pointer + 0 + _segment4_x_operators_operator0_exponentIndex];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment4_x_operators_operator0_field_index_pointer += _x_segment4_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  } else {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    
    long _x_segment4_x_operators_operator0_field_index_pointer = 0;
    for (long _i0 = 0; _i0 < (_lattice_nx); _i0++) {
      psi /= /* L[psi] */ _x_segment4_x_operators_operator0_field[_x_segment4_x_operators_operator0_field_index_pointer + 0 + _segment4_x_operators_operator0_exponentIndex];
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
      _x_segment4_x_operators_operator0_field_index_pointer += _x_segment4_x_operators_operator0_field_ncomponents;
    }
    #undef psi
  }
  
}


inline void _segment4_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
  // NonConstantIPOperator
  _segment4_x_operators_calculate_operator0_field(_step, _exponent);
}
real _segment4_setup_sampling(bool* _next_sample_flag, long* _next_sample_counter)
{
  // The numbers of the moment groups that need to be sampled at the next sampling point.
  // An entry of N+1 means "reached end of integration interval"
  long _momentGroupNumbersNeedingSamplingNext[4];
  long _numberOfMomentGroupsToBeSampledNext = 1;
  
  long _previous_m = 1;
  long _previous_M = 1;
  
  real _t_break_next = (real)t_lim;
  _momentGroupNumbersNeedingSamplingNext[0] = 3;
  
  // initialise all flags to false
  for (long _i0 = 0; _i0 < 4; _i0++)
    _next_sample_flag[_i0] = false;
  
  /* Check if moment group needs sampling at the same time as another already discovered sample (or the final time).
   * If so, add this moment group to the to-be-sampled list. If moment group demands sampling earlier than all
   * previously noted moment groups, erase all previous ones from list and set the sample time to this earlier one.
   */
  if (_next_sample_counter[0] * _previous_M == _previous_m * 2500) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 0;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[0] * _previous_M < _previous_m * 2500) {
    _t_break_next = _next_sample_counter[0] * ((real)t_lim) / ((real)2500);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 0;
    _previous_M = 2500;
    _previous_m = _next_sample_counter[0];
  }
  
  if (_next_sample_counter[1] * _previous_M == _previous_m * 2500) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 1;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[1] * _previous_M < _previous_m * 2500) {
    _t_break_next = _next_sample_counter[1] * ((real)t_lim) / ((real)2500);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 1;
    _previous_M = 2500;
    _previous_m = _next_sample_counter[1];
  }
  
  if (_next_sample_counter[2] * _previous_M == _previous_m * 2500) {
    _momentGroupNumbersNeedingSamplingNext[_numberOfMomentGroupsToBeSampledNext] = 2;
    _numberOfMomentGroupsToBeSampledNext++;
  } else if (_next_sample_counter[2] * _previous_M < _previous_m * 2500) {
    _t_break_next = _next_sample_counter[2] * ((real)t_lim) / ((real)2500);
    _numberOfMomentGroupsToBeSampledNext = 1;
    _momentGroupNumbersNeedingSamplingNext[0] = 2;
    _previous_M = 2500;
    _previous_m = _next_sample_counter[2];
  }
  
  // _momentGroupNumbersNeedingSamplingNext now contains the complete list of moment groups that need
  // to be sampled at the next sampling point. Set their flags to true.
  for (long _i0 = 0; _i0 < _numberOfMomentGroupsToBeSampledNext; _i0++)
    _next_sample_flag[_momentGroupNumbersNeedingSamplingNext[_i0]] = true;
  
  return _t_break_next;
}

real _segment4_x_wavefunction_timestep_error(complex* _checkfield)
{
  real _error = 1e-24;
  real _temp_error = 0.0;
  real _temp_mod = 0.0;

  
  // Find the peak value for each component of the field
  real _cutoff[_x_wavefunction_ncomponents];
  
  for (long _i0 = 0; _i0 < _x_wavefunction_ncomponents; _i0++)
    _cutoff[_i0] = 0.0;
  
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
      for (long _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
        _temp_mod = mod2(_x_wavefunction[_x_wavefunction_index_pointer + _i1]);
        if (_xmds_isnonfinite(_temp_mod))
          _cutoff[_i1] = INFINITY;
        else if (_cutoff[_i1] < _temp_mod)
          _cutoff[_i1] = _temp_mod;
      }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  
  for (long _i0 = 0; _i0 < _x_wavefunction_ncomponents; _i0++) {
    if (_xmds_isnonfinite(_cutoff[_i0]))
      // Return an error two times the tolerance in this case because the timestep must be reduced.
      return 2.0*0.001;
    _cutoff[_i0] *= 0.001;
    _cutoff[_i0] *= 0.001;
  }
  
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
      for (long  _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
        if (mod2(_x_wavefunction[_x_wavefunction_index_pointer + _i1]) > _cutoff[_i1]) {
          _temp_error = abs(_x_wavefunction[_x_wavefunction_index_pointer + _i1] - _checkfield[_x_wavefunction_index_pointer + _i1]) / (0.5*abs(_x_wavefunction[_x_wavefunction_index_pointer + _i1]) + 0.5*abs(_checkfield[_x_wavefunction_index_pointer + _i1]));
          
          if (_xmds_isnonfinite(_temp_error)) {
            /* For _temp_error to be NaN, both the absolute value of the higher and lower order solutions
               must BOTH be zero. This therefore implies that their difference is zero, and that there is no error. */
            _temp_error = 0.0;
          }
          
          if (_error < _temp_error) // UNVECTORISABLE
            _error = _temp_error;
        }
      }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  
  return _error;
}

bool _segment4_x_wavefunction_reset(complex* _reset_to_x_wavefunction)
{
  memcpy(_x_wavefunction, _reset_to_x_wavefunction, sizeof(complex) * _x_wavefunction_alloc_size);
  
  /* return false if there's a NaN somewhere in the vector, otherwise return true */
  bool bNoNaNsPresent = true;
  {
    long _x_wavefunction_index_pointer = 0;
    #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
    for (long _i0 = 0; _i0 < (_lattice_x); _i0++) {
        for (long _i1 = 0; _i1 < _x_wavefunction_ncomponents; _i1++) {
          if (_xmds_isnonfinite(_x_wavefunction[_x_wavefunction_index_pointer + _i1].Re())
            || _xmds_isnonfinite(_x_wavefunction[_x_wavefunction_index_pointer + _i1].Im())) bNoNaNsPresent = false;
        }
    
      _x_wavefunction_index_pointer += _x_wavefunction_ncomponents;
    }
    #undef psi
  }
  return bNoNaNsPresent;
}

// NonConstantIPOperator
void _segment4_x_operators_calculate_operator0_field(real _step, int _exponent)
{
  static const real _propagationStepFractions[] = {
    1.000000000000000,
    0.978260869565217,
    0.903704189521999,
    0.855556284282999,
    0.477941176470588,
    0.771575563871365,
    0.456396464100663,
    0.356643356643357,
    0.517482517482518,
    0.931818181818182,
    0.749391727493917,
    0.332632840343994,
    0.144927536231884,
    0.102040816326531,
  };
  const long _arrayIndex = _exponent - 1;
  const real _propagationStepFraction = _propagationStepFractions[_arrayIndex];
  
  // If the timestep hasn't changed from the last time, then we're done.
  if (_propagationStepFraction * _step == _segment4_x_operators_operator0_last_timestep_size_map[_arrayIndex])
    return;
  
  long _x_segment4_x_operators_operator0_field_index_pointer = 0;
  #define nx _nx[_index_nx + 0]
  #define dnx (_dnx * (1.0))
  
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++) {
    complex L;
    // The purpose of the following define is to give a (somewhat helpful) compile-time error
    // if the user has attempted to use the propagation dimension variable in a constant IP operator/
    // The user probably shouldn't be doing this, but if they must, they should use a non-constant EX
    // operator instead
    #define t Dont_use_propagation_dimension_t_in_constant_IP_operator___Use_non_constant_EX_operator_instead
    // ************** Operator code *****************
    #line 110 "th_spgpe_spectral.xmds"
    
    L = -(nx+0.5)*omega_bar*i;
    
    #line 5201 "th_spgpe_spectral.cc"
    // **********************************************
    #undef t
    
    _x_segment4_x_operators_operator0_field[_x_segment4_x_operators_operator0_field_index_pointer + _arrayIndex * 1 + 0] = cis(L.Im() * _propagationStepFraction * _step);
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_segment4_x_operators_operator0_field_index_pointer += 1 * _x_segment4_x_operators_operator0_field_ncomponents;
    
  }
  #undef nx
  #undef dnx
  
  _segment4_x_operators_operator0_last_timestep_size_map[_arrayIndex] = _propagationStepFraction * _step;
}

// Delta A propagation operator for field x
void _segment4_x_operators_evaluate_operator1(real _step)
{
  // Transforming vectors to basis (x)
  _x_pos_space_terms_basis_transform(2); // (x)
  _x_wavefunction_basis_transform(2); // (x)
  
  long _x_pos_space_terms_index_pointer = 0;
  #define U _active_x_pos_space_terms[_x_pos_space_terms_index_pointer + 0]
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    complex dpsi_dt;
    
    #define dt _step
    
    // ************* Propagation code ***************
    #line 116 "th_spgpe_spectral.xmds"
    
    dpsi_dt = 0.0-i*U;
    
    #line 5240 "th_spgpe_spectral.cc"
    // **********************************************
    
    #undef dt
    
    
    _active_x_wavefunction[_x_wavefunction_index_pointer + 0] = dpsi_dt * _step;
    // Increment index pointers for vectors in field x (or having the same dimensions)
    _x_pos_space_terms_index_pointer += 1 * _x_pos_space_terms_ncomponents;
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef U
  #undef psi
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for th_spgpe_spectral\n");
  
  // If we aren't rank 0, then we don't want to write anything.
  if (_rank != 0)
    return;
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  _mg1_write_out(_outfile);
  _mg2_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  // Transforming vectors to basis (t, x)
  _x_wavefunction_basis_transform(2); // (x)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _mg0_output_raw_index_pointer = 0;
  #define pos_dens _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define pos_phase _active_mg0_output_raw[_mg0_output_raw_index_pointer + 1]
  #define x _x[_index_x + 0]
  #define dx (_dx_array[_index_x + 0] * (1.0))
  
  for (long _index_x = 0; _index_x < _lattice_x; _index_x++) {
    // Set index pointers explicitly for (some) vectors
    _mg0_output_raw_index_pointer = ( 0
       + _mg0_output_index_t  * _lattice_x
       + _index_x * 1 ) * _mg0_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 128 "th_spgpe_spectral.xmds"
    
    pos_dens = mod2(psi);
    pos_phase = arg(psi);
    
    #line 5322 "th_spgpe_spectral.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef x
  #undef dx
  #undef psi
  #undef pos_dens
  #undef pos_phase
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  {
    _MAKE_AUTOVEC_VARIABLE(_active_mg0_output_raw);
    _MAKE_AUTOVEC_VARIABLE(_active_mg0_output_processed);
    _MAKE_AUTOVEC_VARIABLE(_mg0_output_sd);
    #pragma ivdep
    for (long _i0 = 0; _i0 < (_mg0_output_lattice_t * _lattice_x) * _mg0_output_raw_ncomponents; _i0++) {
      _AUTOVEC(_active_mg0_output_processed)[_i0] += _AUTOVEC(_active_mg0_output_raw)[_i0];
      _AUTOVEC(_mg0_output_sd)[_i0] += _AUTOVEC(_active_mg0_output_raw)[_i0] * _AUTOVEC(_active_mg0_output_raw)[_i0];
    }
  
  }
}


void _mg0_write_out(FILE* _outfile)
{
  #pragma novector
  for (long _i0 = 0; _i0 < (_mg0_output_lattice_t * _lattice_x) * _mg0_output_processed_ncomponents; _i0++) {
    // Calculate the mean
    _active_mg0_output_processed[_i0] /= (real) _n_paths;
    
    // Calculate the standard error
    _mg0_output_sd[_i0] /= (real) _n_paths;
    _mg0_output_sd[_i0] -= _active_mg0_output_processed[_i0] * _active_mg0_output_processed[_i0];
    if (_mg0_output_sd[_i0] > 0.0) // UNVECTORISABLE
      _mg0_output_sd[_i0] = sqrt(_mg0_output_sd[_i0] / _n_paths);
    else
      _mg0_output_sd[_i0] = 0.0;
  }
  
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>6</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t x mean_pos_dens mean_pos_phase stderr_pos_dens stderr_pos_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_x);
    fprintf(_outfile, "    <Dim>6</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_x;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_x;
  if (!H5Lexists(hdf5_file, "/1/x", H5P_DEFAULT))
    dataset_x = H5Dcreate(hdf5_file, "/1/x", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_x = H5Dopen(hdf5_file, "/1/x");
  H5Dwrite(dataset_x, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _x);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_x, "x");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_x};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_mean_pos_dens;
  if (!H5Lexists(hdf5_file, "/1/mean_pos_dens", H5P_DEFAULT))
    dataset_mean_pos_dens = H5Dcreate(hdf5_file, "/1/mean_pos_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_pos_dens = H5Dopen(hdf5_file, "/1/mean_pos_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_pos_dens, dataset_t, 0);
    H5DSattach_scale(dataset_mean_pos_dens, dataset_x, 1);
  #endif
  hid_t dataset_mean_pos_phase;
  if (!H5Lexists(hdf5_file, "/1/mean_pos_phase", H5P_DEFAULT))
    dataset_mean_pos_phase = H5Dcreate(hdf5_file, "/1/mean_pos_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_pos_phase = H5Dopen(hdf5_file, "/1/mean_pos_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_pos_phase, dataset_t, 0);
    H5DSattach_scale(dataset_mean_pos_phase, dataset_x, 1);
  #endif
  hid_t dataset_stderr_pos_dens;
  if (!H5Lexists(hdf5_file, "/1/stderr_pos_dens", H5P_DEFAULT))
    dataset_stderr_pos_dens = H5Dcreate(hdf5_file, "/1/stderr_pos_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_pos_dens = H5Dopen(hdf5_file, "/1/stderr_pos_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_pos_dens, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_pos_dens, dataset_x, 1);
  #endif
  hid_t dataset_stderr_pos_phase;
  if (!H5Lexists(hdf5_file, "/1/stderr_pos_phase", H5P_DEFAULT))
    dataset_stderr_pos_phase = H5Dcreate(hdf5_file, "/1/stderr_pos_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_pos_phase = H5Dopen(hdf5_file, "/1/stderr_pos_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_pos_phase, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_pos_phase, dataset_x, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_x);
  
  
  if ((_mg0_output_lattice_t * _lattice_x)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_x, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_x, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_pos_dens)
      H5Dwrite(dataset_mean_pos_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_processed);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_pos_phase)
      H5Dwrite(dataset_mean_pos_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_processed);
    
    H5Sclose(mem_dataspace);
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_pos_dens)
      H5Dwrite(dataset_stderr_pos_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg0_output_sd);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_pos_phase)
      H5Dwrite(dataset_stderr_pos_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg0_output_sd);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_mean_pos_dens);
  H5Dclose(dataset_mean_pos_phase);
  H5Dclose(dataset_stderr_pos_dens);
  H5Dclose(dataset_stderr_pos_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

// initialisation for vector processed
void _mg0_output_processed_initialise()
{
  
  bzero(_active_mg0_output_processed, sizeof(real) * _mg0_output_processed_alloc_size);
}

// ********************************************************
//   moment group 1 function implementations
void _mg1_sample()
{
  
  // Transforming vectors to basis (t, nx)
  _x_wavefunction_basis_transform(1); // (nx)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _mg1_output_raw_index_pointer = 0;
  #define herm_dens _active_mg1_output_raw[_mg1_output_raw_index_pointer + 0]
  #define herm_phase _active_mg1_output_raw[_mg1_output_raw_index_pointer + 1]
  #define nx _nx[_index_nx + 0]
  #define dnx (_dnx * (1.0))
  
  for (long _index_nx = 0; _index_nx < _lattice_nx; _index_nx++) {
    // Set index pointers explicitly for (some) vectors
    _mg1_output_raw_index_pointer = ( 0
       + _mg1_output_index_t  * _lattice_nx
       + _index_nx * 1 ) * _mg1_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 137 "th_spgpe_spectral.xmds"
    
    herm_dens = mod2(psi);
                herm_phase = arg(psi);
    
    #line 5605 "th_spgpe_spectral.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg1_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef nx
  #undef dnx
  #undef psi
  #undef herm_dens
  #undef herm_phase
  
  _mg1_output_t[0 + _mg1_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #2) at t = %e\n", t);
  
}


void _mg1_process()
{
  {
    _MAKE_AUTOVEC_VARIABLE(_mg1_output_sd);
    _MAKE_AUTOVEC_VARIABLE(_active_mg1_output_raw);
    _MAKE_AUTOVEC_VARIABLE(_active_mg1_output_processed);
    #pragma ivdep
    for (long _i0 = 0; _i0 < (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_raw_ncomponents; _i0++) {
      _AUTOVEC(_active_mg1_output_processed)[_i0] += _AUTOVEC(_active_mg1_output_raw)[_i0];
      _AUTOVEC(_mg1_output_sd)[_i0] += _AUTOVEC(_active_mg1_output_raw)[_i0] * _AUTOVEC(_active_mg1_output_raw)[_i0];
    }
  
  }
}


void _mg1_write_out(FILE* _outfile)
{
  #pragma novector
  for (long _i0 = 0; _i0 < (_mg1_output_lattice_t * _lattice_nx) * _mg1_output_processed_ncomponents; _i0++) {
    // Calculate the mean
    _active_mg1_output_processed[_i0] /= (real) _n_paths;
    
    // Calculate the standard error
    _mg1_output_sd[_i0] /= (real) _n_paths;
    _mg1_output_sd[_i0] -= _active_mg1_output_processed[_i0] * _active_mg1_output_processed[_i0];
    if (_mg1_output_sd[_i0] > 0.0) // UNVECTORISABLE
      _mg1_output_sd[_i0] = sqrt(_mg1_output_sd[_i0] / _n_paths);
    else
      _mg1_output_sd[_i0] = 0.0;
  }
  
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_2\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>6</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t nx mean_herm_dens mean_herm_phase stderr_herm_dens stderr_herm_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg1_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_nx);
    fprintf(_outfile, "    <Dim>6</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/2", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/2", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/2");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/2\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg1_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/2/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/2/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/2/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg1_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_nx;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_nx;
  if (!H5Lexists(hdf5_file, "/2/nx", H5P_DEFAULT))
    dataset_nx = H5Dcreate(hdf5_file, "/2/nx", H5T_NATIVE_LONG, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_nx = H5Dopen(hdf5_file, "/2/nx");
  H5Dwrite(dataset_nx, H5T_NATIVE_LONG, H5S_ALL, H5S_ALL, H5P_DEFAULT, _nx);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_nx, "nx");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg1_output_lattice_t, _lattice_nx};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_mean_herm_dens;
  if (!H5Lexists(hdf5_file, "/2/mean_herm_dens", H5P_DEFAULT))
    dataset_mean_herm_dens = H5Dcreate(hdf5_file, "/2/mean_herm_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_herm_dens = H5Dopen(hdf5_file, "/2/mean_herm_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_herm_dens, dataset_t, 0);
    H5DSattach_scale(dataset_mean_herm_dens, dataset_nx, 1);
  #endif
  hid_t dataset_mean_herm_phase;
  if (!H5Lexists(hdf5_file, "/2/mean_herm_phase", H5P_DEFAULT))
    dataset_mean_herm_phase = H5Dcreate(hdf5_file, "/2/mean_herm_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_herm_phase = H5Dopen(hdf5_file, "/2/mean_herm_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_herm_phase, dataset_t, 0);
    H5DSattach_scale(dataset_mean_herm_phase, dataset_nx, 1);
  #endif
  hid_t dataset_stderr_herm_dens;
  if (!H5Lexists(hdf5_file, "/2/stderr_herm_dens", H5P_DEFAULT))
    dataset_stderr_herm_dens = H5Dcreate(hdf5_file, "/2/stderr_herm_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_herm_dens = H5Dopen(hdf5_file, "/2/stderr_herm_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_herm_dens, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_herm_dens, dataset_nx, 1);
  #endif
  hid_t dataset_stderr_herm_phase;
  if (!H5Lexists(hdf5_file, "/2/stderr_herm_phase", H5P_DEFAULT))
    dataset_stderr_herm_phase = H5Dcreate(hdf5_file, "/2/stderr_herm_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_herm_phase = H5Dopen(hdf5_file, "/2/stderr_herm_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_herm_phase, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_herm_phase, dataset_nx, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_nx);
  
  
  if ((_mg1_output_lattice_t * _lattice_nx)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg1_output_lattice_t, (unsigned long long int)_lattice_nx, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg1_output_lattice_t, (unsigned long long int)_lattice_nx, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_herm_dens)
      H5Dwrite(dataset_mean_herm_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg1_output_processed);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_herm_phase)
      H5Dwrite(dataset_mean_herm_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg1_output_processed);
    
    H5Sclose(mem_dataspace);
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_herm_dens)
      H5Dwrite(dataset_stderr_herm_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg1_output_sd);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_herm_phase)
      H5Dwrite(dataset_stderr_herm_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg1_output_sd);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_mean_herm_dens);
  H5Dclose(dataset_mean_herm_phase);
  H5Dclose(dataset_stderr_herm_dens);
  H5Dclose(dataset_stderr_herm_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg1_output function implementations
// initialisation for vector processed
void _mg1_output_processed_initialise()
{
  
  bzero(_active_mg1_output_processed, sizeof(real) * _mg1_output_processed_alloc_size);
}

// initialisation for vector raw
void _mg1_output_raw_initialise()
{
  
  bzero(_active_mg1_output_raw, sizeof(real) * _mg1_output_raw_alloc_size);
}

// ********************************************************
//   moment group 2 function implementations
void _mg2_sample()
{
  
  // Transforming vectors to basis (t, kx)
  _x_wavefunction_basis_transform(0); // (kx)
  
  long _x_wavefunction_index_pointer = 0;
  #define psi _active_x_wavefunction[_x_wavefunction_index_pointer + 0]
  long _mg2_output_raw_index_pointer = 0;
  #define mom_dens _active_mg2_output_raw[_mg2_output_raw_index_pointer + 0]
  #define mom_phase _active_mg2_output_raw[_mg2_output_raw_index_pointer + 1]
  #define kx _kx[_index_kx + 0]
  #define dkx (_dkx_array[_index_kx + 0] * (1.0))
  
  for (long _index_kx = 0; _index_kx < _lattice_kx; _index_kx++) {
    // Set index pointers explicitly for (some) vectors
    _mg2_output_raw_index_pointer = ( 0
       + _mg2_output_index_t  * _lattice_kx
       + _index_kx * 1 ) * _mg2_output_raw_ncomponents;
    #define _SAMPLE_COMPLEX(variable) \
              variable ## R = variable.Re(); variable ## I = variable.Im();
    
    // *************** Sampling code ****************
    #line 146 "th_spgpe_spectral.xmds"
    
    mom_dens = mod2(psi);
    mom_phase = arg(psi);
    
    #line 5888 "th_spgpe_spectral.cc"
    // **********************************************
    
    #undef _SAMPLE_COMPLEX
    // Increment index pointers for vectors in field mg2_sampling (or having the same dimensions)
    _x_wavefunction_index_pointer += 1 * _x_wavefunction_ncomponents;
    
  }
  #undef kx
  #undef dkx
  #undef psi
  #undef mom_dens
  #undef mom_phase
  
  _mg2_output_t[0 + _mg2_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #3) at t = %e\n", t);
  
}


void _mg2_process()
{
  {
    _MAKE_AUTOVEC_VARIABLE(_active_mg2_output_raw);
    _MAKE_AUTOVEC_VARIABLE(_active_mg2_output_processed);
    _MAKE_AUTOVEC_VARIABLE(_mg2_output_sd);
    #pragma ivdep
    for (long _i0 = 0; _i0 < (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_raw_ncomponents; _i0++) {
      _AUTOVEC(_active_mg2_output_processed)[_i0] += _AUTOVEC(_active_mg2_output_raw)[_i0];
      _AUTOVEC(_mg2_output_sd)[_i0] += _AUTOVEC(_active_mg2_output_raw)[_i0] * _AUTOVEC(_active_mg2_output_raw)[_i0];
    }
  
  }
}


void _mg2_write_out(FILE* _outfile)
{
  #pragma novector
  for (long _i0 = 0; _i0 < (_mg2_output_lattice_t * _lattice_kx) * _mg2_output_processed_ncomponents; _i0++) {
    // Calculate the mean
    _active_mg2_output_processed[_i0] /= (real) _n_paths;
    
    // Calculate the standard error
    _mg2_output_sd[_i0] /= (real) _n_paths;
    _mg2_output_sd[_i0] -= _active_mg2_output_processed[_i0] * _active_mg2_output_processed[_i0];
    if (_mg2_output_sd[_i0] > 0.0) // UNVECTORISABLE
      _mg2_output_sd[_i0] = sqrt(_mg2_output_sd[_i0] / _n_paths);
    else
      _mg2_output_sd[_i0] = 0.0;
  }
  
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_3\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">2</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>6</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t kx mean_mom_dens mean_mom_phase stderr_mom_dens stderr_mom_phase \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg2_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_kx);
    fprintf(_outfile, "    <Dim>6</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/3", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/3", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/3");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/3\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("th_spgpe_spectral" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg2_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/3/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/3/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/3/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg2_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_kx;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_kx;
  if (!H5Lexists(hdf5_file, "/3/kx", H5P_DEFAULT))
    dataset_kx = H5Dcreate(hdf5_file, "/3/kx", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_kx = H5Dopen(hdf5_file, "/3/kx");
  H5Dwrite(dataset_kx, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _kx);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_kx, "kx");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg2_output_lattice_t, _lattice_kx};
  hid_t file_dataspace = H5Screate_simple(2, file_dims, NULL);
  
  hid_t dataset_mean_mom_dens;
  if (!H5Lexists(hdf5_file, "/3/mean_mom_dens", H5P_DEFAULT))
    dataset_mean_mom_dens = H5Dcreate(hdf5_file, "/3/mean_mom_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_mom_dens = H5Dopen(hdf5_file, "/3/mean_mom_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_mom_dens, dataset_t, 0);
    H5DSattach_scale(dataset_mean_mom_dens, dataset_kx, 1);
  #endif
  hid_t dataset_mean_mom_phase;
  if (!H5Lexists(hdf5_file, "/3/mean_mom_phase", H5P_DEFAULT))
    dataset_mean_mom_phase = H5Dcreate(hdf5_file, "/3/mean_mom_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_mean_mom_phase = H5Dopen(hdf5_file, "/3/mean_mom_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_mean_mom_phase, dataset_t, 0);
    H5DSattach_scale(dataset_mean_mom_phase, dataset_kx, 1);
  #endif
  hid_t dataset_stderr_mom_dens;
  if (!H5Lexists(hdf5_file, "/3/stderr_mom_dens", H5P_DEFAULT))
    dataset_stderr_mom_dens = H5Dcreate(hdf5_file, "/3/stderr_mom_dens", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_mom_dens = H5Dopen(hdf5_file, "/3/stderr_mom_dens");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_mom_dens, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_mom_dens, dataset_kx, 1);
  #endif
  hid_t dataset_stderr_mom_phase;
  if (!H5Lexists(hdf5_file, "/3/stderr_mom_phase", H5P_DEFAULT))
    dataset_stderr_mom_phase = H5Dcreate(hdf5_file, "/3/stderr_mom_phase", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_stderr_mom_phase = H5Dopen(hdf5_file, "/3/stderr_mom_phase");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_stderr_mom_phase, dataset_t, 0);
    H5DSattach_scale(dataset_stderr_mom_phase, dataset_kx, 1);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_kx);
  
  
  if ((_mg2_output_lattice_t * _lattice_kx)) {
    /* Create the data space */
    hsize_t file_start[2] = {(unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[3] = {(unsigned long long int)_mg2_output_lattice_t, (unsigned long long int)_lattice_kx, (unsigned long long int)1};
    hsize_t mem_start[3] = {0, 0, 0};
    hsize_t mem_stride[3] = {1, 1, 1};
    hsize_t mem_count[3] = {(unsigned long long int)_mg2_output_lattice_t, (unsigned long long int)_lattice_kx, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_mom_dens)
      H5Dwrite(dataset_mean_mom_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg2_output_processed);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_mean_mom_phase)
      H5Dwrite(dataset_mean_mom_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg2_output_processed);
    
    H5Sclose(mem_dataspace);
    mem_dims[2] = 2;
    mem_dataspace = H5Screate_simple(3, mem_dims, NULL);
    mem_stride[2] = 2;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[2] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_mom_dens)
      H5Dwrite(dataset_stderr_mom_dens, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg2_output_sd);
    mem_start[2] = 1;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_stderr_mom_phase)
      H5Dwrite(dataset_stderr_mom_phase, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _mg2_output_sd);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_mean_mom_dens);
  H5Dclose(dataset_mean_mom_phase);
  H5Dclose(dataset_stderr_mom_dens);
  H5Dclose(dataset_stderr_mom_phase);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg2_output function implementations
// initialisation for vector processed
void _mg2_output_processed_initialise()
{
  
  bzero(_active_mg2_output_processed, sizeof(real) * _mg2_output_processed_alloc_size);
}

// initialisation for vector raw
void _mg2_output_raw_initialise()
{
  
  bzero(_active_mg2_output_raw, sizeof(real) * _mg2_output_raw_alloc_size);
}

